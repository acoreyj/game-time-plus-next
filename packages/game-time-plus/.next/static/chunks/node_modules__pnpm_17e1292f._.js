(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules__pnpm_17e1292f._.js", {

"[project]/node_modules/.pnpm/next@15.2.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$2$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.2.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.2.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray;
    new ("function" === typeof WeakMap ? WeakMap : Map)();
    var createTask = console.createTask ? console.createTask : function() {
        return null;
    }, specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, Error("react-stack-top-frame"), createTask(getTaskName(type)));
    };
}();
}}),
"[project]/node_modules/.pnpm/next@15.2.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$2$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.2.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.2.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/.pnpm/tinybase@5.4.8_@cloudflare+workers-types@4.20250224.0_prettier@3.5.2_react-dom@19.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCheckpoints": (()=>createCheckpoints),
    "createIndexes": (()=>createIndexes),
    "createMergeableStore": (()=>createMergeableStore),
    "createMetrics": (()=>createMetrics),
    "createQueries": (()=>createQueries),
    "createRelationships": (()=>createRelationships),
    "createStore": (()=>createStore),
    "defaultSorter": (()=>defaultSorter),
    "getUniqueId": (()=>getUniqueId)
});
const getTypeOf = (thing)=>typeof thing;
const EMPTY_STRING = '';
const STRING = getTypeOf(EMPTY_STRING);
const BOOLEAN = getTypeOf(true);
const NUMBER = getTypeOf(0);
const FUNCTION = getTypeOf(getTypeOf);
const TYPE = 'type';
const DEFAULT = 'default';
const SUM = 'sum';
const AVG = 'avg';
const MIN = 'min';
const MAX = 'max';
const LISTENER = 'Listener';
const RESULT = 'Result';
const GET = 'get';
const SET = 'set';
const ADD = 'add';
const DEL = 'del';
const HAS = 'Has';
const IDS = 'Ids';
const TABLE = 'Table';
const TABLES = TABLE + 's';
const TABLE_IDS = TABLE + IDS;
const ROW = 'Row';
const ROW_COUNT = ROW + 'Count';
const ROW_IDS = ROW + IDS;
const SORTED_ROW_IDS = 'Sorted' + ROW + IDS;
const CELL = 'Cell';
const CELL_IDS = CELL + IDS;
const VALUE = 'Value';
const VALUES = VALUE + 's';
const VALUE_IDS = VALUE + IDS;
const TRANSACTION = 'Transaction';
const id = (key)=>EMPTY_STRING + key;
const strStartsWith = (str, prefix)=>str.startsWith(prefix);
const strEndsWith = (str, suffix)=>str.endsWith(suffix);
const strSplit = (str, separator = EMPTY_STRING, limit)=>str.split(separator, limit);
const GLOBAL = globalThis;
const math = Math;
const mathMax = math.max;
const mathMin = math.min;
const mathFloor = math.floor;
const isFiniteNumber = isFinite;
const isInstanceOf = (thing, cls)=>thing instanceof cls;
const isUndefined = (thing)=>thing == void 0;
const ifNotUndefined = (value, then, otherwise)=>isUndefined(value) ? otherwise?.() : then(value);
const isTypeStringOrBoolean = (type)=>type == STRING || type == BOOLEAN;
const isString = (thing)=>getTypeOf(thing) == STRING;
const isFunction = (thing)=>getTypeOf(thing) == FUNCTION;
const isArray = (thing)=>Array.isArray(thing);
const slice = (arrayOrString, start, end)=>arrayOrString.slice(start, end);
const size = (arrayOrString)=>arrayOrString.length;
const test = (regex, subject)=>regex.test(subject);
const getUndefined = ()=>void 0;
const arrayHas = (array, value)=>array.includes(value);
const arrayEvery = (array, cb)=>array.every(cb);
const arrayIsEqual = (array1, array2)=>size(array1) === size(array2) && arrayEvery(array1, (value1, index)=>array2[index] === value1);
const arrayIsSorted = (array, sorter)=>arrayEvery(array, (value, index)=>index == 0 || sorter(array[index - 1], value) <= 0);
const arraySort = (array, sorter)=>array.sort(sorter);
const arrayForEach = (array, cb)=>array.forEach(cb);
const arrayMap = (array, cb)=>array.map(cb);
const arraySum = (array)=>arrayReduce(array, (i, j)=>i + j, 0);
const arrayIsEmpty = (array)=>size(array) == 0;
const arrayReduce = (array, cb, initial)=>array.reduce(cb, initial);
const arrayClear = (array, to)=>array.splice(0, to);
const arrayPush = (array, ...values)=>array.push(...values);
const arrayPop = (array)=>array.pop();
const arrayUnshift = (array, ...values)=>array.unshift(...values);
const arrayShift = (array)=>array.shift();
const object = Object;
const getPrototypeOf = (obj)=>object.getPrototypeOf(obj);
const objEntries = object.entries;
const objFrozen = object.isFrozen;
const isObject = (obj)=>!isUndefined(obj) && ifNotUndefined(getPrototypeOf(obj), (objPrototype)=>objPrototype == object.prototype || isUndefined(getPrototypeOf(objPrototype)), /* istanbul ignore next */ ()=>true);
const objIds = object.keys;
const objFreeze = object.freeze;
const objNew = (entries = [])=>object.fromEntries(entries);
const objHas = (obj, id)=>id in obj;
const objDel = (obj, id)=>{
    delete obj[id];
    return obj;
};
const objForEach = (obj, cb)=>arrayForEach(objEntries(obj), ([id, value])=>cb(value, id));
const objToArray = (obj, cb)=>arrayMap(objEntries(obj), ([id, value])=>cb(value, id));
const objMap = (obj, cb)=>objNew(objToArray(obj, (value, id)=>[
            id,
            cb(value, id)
        ]));
const objSize = (obj)=>size(objIds(obj));
const objIsEmpty = (obj)=>isObject(obj) && objSize(obj) == 0;
const objEnsure = (obj, id, getDefaultValue)=>{
    if (!objHas(obj, id)) {
        obj[id] = getDefaultValue();
    }
    return obj[id];
};
const objValidate = (obj, validateChild, onInvalidObj, emptyIsValid = 0)=>{
    if (isUndefined(obj) || !isObject(obj) || !emptyIsValid && objIsEmpty(obj) || objFrozen(obj)) {
        onInvalidObj?.();
        return false;
    }
    objForEach(obj, (child, id)=>{
        if (!validateChild(child, id)) {
            objDel(obj, id);
        }
    });
    return emptyIsValid ? true : !objIsEmpty(obj);
};
const collSizeN = (collSizer)=>(coll)=>arrayReduce(collValues(coll), (total, coll2)=>total + collSizer(coll2), 0);
const collSize = (coll)=>coll?.size ?? 0;
const collSize2 = collSizeN(collSize);
const collSize3 = collSizeN(collSize2);
const collSize4 = collSizeN(collSize3);
const collHas = (coll, keyOrValue)=>coll?.has(keyOrValue) ?? false;
const collIsEmpty = (coll)=>isUndefined(coll) || collSize(coll) == 0;
const collValues = (coll)=>[
        ...coll?.values() ?? []
    ];
const collClear = (coll)=>coll.clear();
const collForEach = (coll, cb)=>coll?.forEach(cb);
const collDel = (coll, keyOrValue)=>coll?.delete(keyOrValue);
const mapNew = (entries)=>new Map(entries);
const mapKeys = (map)=>[
        ...map?.keys() ?? []
    ];
const mapGet = (map, key)=>map?.get(key);
const mapForEach = (map, cb)=>collForEach(map, (value, key)=>cb(key, value));
const mapMap = (coll, cb)=>arrayMap([
        ...coll?.entries() ?? []
    ], ([key, value])=>cb(value, key));
const mapSet = (map, key, value)=>isUndefined(value) ? (collDel(map, key), map) : map?.set(key, value);
const mapEnsure = (map, key, getDefaultValue, hadExistingValue)=>{
    if (!collHas(map, key)) {
        mapSet(map, key, getDefaultValue());
    } else {
        hadExistingValue?.(mapGet(map, key));
    }
    return mapGet(map, key);
};
const mapMatch = (map, obj, set, del = mapSet)=>{
    objMap(obj, (value, id)=>set(map, id, value));
    mapForEach(map, (id)=>objHas(obj, id) ? 0 : del(map, id));
    return map;
};
const mapToObj = (map, valueMapper, excludeMapValue, excludeObjValue)=>{
    const obj = {};
    collForEach(map, (mapValue, id)=>{
        if (!excludeMapValue?.(mapValue, id)) {
            const objValue = valueMapper ? valueMapper(mapValue, id) : mapValue;
            if (!excludeObjValue?.(objValue)) {
                obj[id] = objValue;
            }
        }
    });
    return obj;
};
const mapToObj2 = (map, valueMapper, excludeMapValue)=>mapToObj(map, (childMap)=>mapToObj(childMap, valueMapper, excludeMapValue), collIsEmpty, objIsEmpty);
const mapToObj3 = (map, valueMapper, excludeMapValue)=>mapToObj(map, (childMap)=>mapToObj2(childMap, valueMapper, excludeMapValue), collIsEmpty, objIsEmpty);
const mapClone = (map, mapValue)=>{
    const map2 = mapNew();
    collForEach(map, (value, key)=>map2.set(key, mapValue?.(value) ?? value));
    return map2;
};
const mapClone2 = (map)=>mapClone(map, mapClone);
const mapClone3 = (map)=>mapClone(map, mapClone2);
const visitTree = (node, path, ensureLeaf, pruneLeaf, p = 0)=>ifNotUndefined((ensureLeaf ? mapEnsure : mapGet)(node, path[p], p > size(path) - 2 ? ensureLeaf : mapNew), (nodeOrLeaf)=>{
        if (p > size(path) - 2) {
            if (pruneLeaf?.(nodeOrLeaf)) {
                mapSet(node, path[p]);
            }
            return nodeOrLeaf;
        }
        const leaf = visitTree(nodeOrLeaf, path, ensureLeaf, pruneLeaf, p + 1);
        if (collIsEmpty(nodeOrLeaf)) {
            mapSet(node, path[p]);
        }
        return leaf;
    });
const getCellOrValueType = (cellOrValue)=>{
    const type = getTypeOf(cellOrValue);
    return isTypeStringOrBoolean(type) || type == NUMBER && isFiniteNumber(cellOrValue) ? type : void 0;
};
const isCellOrValueOrNullOrUndefined = (cellOrValue)=>isUndefined(cellOrValue) || !isUndefined(getCellOrValueType(cellOrValue));
const setOrDelCell = (store, tableId, rowId, cellId, cell)=>isUndefined(cell) ? store.delCell(tableId, rowId, cellId, true) : store.setCell(tableId, rowId, cellId, cell);
const setOrDelValue = (store, valueId, value)=>isUndefined(value) ? store.delValue(valueId) : store.setValue(valueId, value);
const setNew = (entryOrEntries)=>new Set(isArray(entryOrEntries) || isUndefined(entryOrEntries) ? entryOrEntries : [
        entryOrEntries
    ]);
const setAdd = (set, value)=>set?.add(value);
const getDefinableFunctions = (store, getDefaultThing, validateRowValue, addListener, callListeners)=>{
    const hasRow = store.hasRow;
    const tableIds = mapNew();
    const things = mapNew();
    const thingIdListeners = mapNew();
    const allRowValues = mapNew();
    const allSortKeys = mapNew();
    const storeListenerIds = mapNew();
    const getStore = ()=>store;
    const getThingIds = ()=>mapKeys(tableIds);
    const forEachThing = (cb)=>mapForEach(things, cb);
    const hasThing = (id)=>collHas(things, id);
    const getTableId = (id)=>mapGet(tableIds, id);
    const getThing = (id)=>mapGet(things, id);
    const setThing = (id, thing)=>mapSet(things, id, thing);
    const addStoreListeners = (id, andCall, ...listenerIds)=>{
        const set = mapEnsure(storeListenerIds, id, setNew);
        arrayForEach(listenerIds, (listenerId)=>setAdd(set, listenerId) && andCall && store.callListener(listenerId));
        return listenerIds;
    };
    const delStoreListeners = (id, ...listenerIds)=>ifNotUndefined(mapGet(storeListenerIds, id), (allListenerIds)=>{
            arrayForEach(arrayIsEmpty(listenerIds) ? collValues(allListenerIds) : listenerIds, (listenerId)=>{
                store.delListener(listenerId);
                collDel(allListenerIds, listenerId);
            });
            if (collIsEmpty(allListenerIds)) {
                mapSet(storeListenerIds, id);
            }
        });
    const setDefinition = (id, tableId)=>{
        mapSet(tableIds, id, tableId);
        if (!collHas(things, id)) {
            mapSet(things, id, getDefaultThing());
            mapSet(allRowValues, id, mapNew());
            mapSet(allSortKeys, id, mapNew());
            callListeners(thingIdListeners);
        }
    };
    const setDefinitionAndListen = (id, tableId, onChanged, getRowValue, getSortKey)=>{
        setDefinition(id, tableId);
        const changedRowValues = mapNew();
        const changedSortKeys = mapNew();
        const rowValues = mapGet(allRowValues, id);
        const sortKeys = mapGet(allSortKeys, id);
        const processRow = (rowId)=>{
            const getCell = (cellId)=>store.getCell(tableId, rowId, cellId);
            const oldRowValue = mapGet(rowValues, rowId);
            const newRowValue = hasRow(tableId, rowId) ? validateRowValue(getRowValue(getCell, rowId)) : void 0;
            if (!(oldRowValue === newRowValue || isArray(oldRowValue) && isArray(newRowValue) && arrayIsEqual(oldRowValue, newRowValue))) {
                mapSet(changedRowValues, rowId, [
                    oldRowValue,
                    newRowValue
                ]);
            }
            if (!isUndefined(getSortKey)) {
                const oldSortKey = mapGet(sortKeys, rowId);
                const newSortKey = hasRow(tableId, rowId) ? getSortKey(getCell, rowId) : void 0;
                if (oldSortKey != newSortKey) {
                    mapSet(changedSortKeys, rowId, newSortKey);
                }
            }
        };
        const processTable = (force)=>{
            onChanged(()=>{
                collForEach(changedRowValues, ([, newRowValue], rowId)=>mapSet(rowValues, rowId, newRowValue));
                collForEach(changedSortKeys, (newSortKey, rowId)=>mapSet(sortKeys, rowId, newSortKey));
            }, changedRowValues, changedSortKeys, rowValues, sortKeys, force);
            collClear(changedRowValues);
            collClear(changedSortKeys);
        };
        mapForEach(rowValues, processRow);
        if (store.hasTable(tableId)) {
            arrayForEach(store.getRowIds(tableId), (rowId)=>{
                if (!collHas(rowValues, rowId)) {
                    processRow(rowId);
                }
            });
        }
        processTable(true);
        delStoreListeners(id);
        addStoreListeners(id, 0, store.addRowListener(tableId, null, (_store, _tableId, rowId)=>processRow(rowId)), store.addTableListener(tableId, ()=>processTable()));
    };
    const delDefinition = (id)=>{
        mapSet(tableIds, id);
        mapSet(things, id);
        mapSet(allRowValues, id);
        mapSet(allSortKeys, id);
        delStoreListeners(id);
        callListeners(thingIdListeners);
    };
    const addThingIdsListener = (listener)=>addListener(listener, thingIdListeners);
    const destroy = ()=>mapForEach(storeListenerIds, delDefinition);
    return [
        getStore,
        getThingIds,
        forEachThing,
        hasThing,
        getTableId,
        getThing,
        setThing,
        setDefinition,
        setDefinitionAndListen,
        delDefinition,
        addThingIdsListener,
        destroy,
        addStoreListeners,
        delStoreListeners
    ];
};
const getRowCellFunction = (getRowCell, defaultCellValue)=>isString(getRowCell) ? (getCell)=>getCell(getRowCell) : getRowCell ?? (()=>defaultCellValue ?? EMPTY_STRING);
const getCreateFunction = (getFunction, initFunction)=>{
    const thingsByStore = /* @__PURE__ */ new WeakMap();
    return (store)=>{
        if (!thingsByStore.has(store)) {
            thingsByStore.set(store, getFunction(store));
        }
        const thing = thingsByStore.get(store);
        initFunction?.(thing);
        return thing;
    };
};
const INTEGER = /^\d+$/;
const getPoolFunctions = ()=>{
    const pool = [];
    let nextId = 0;
    return [
        (reuse)=>(reuse ? arrayShift(pool) : null) ?? EMPTY_STRING + nextId++,
        (id)=>{
            if (test(INTEGER, id) && size(pool) < 1e3) {
                arrayPush(pool, id);
            }
        }
    ];
};
const getWildcardedLeaves = (deepIdSet, path = [
    EMPTY_STRING
])=>{
    const leaves = [];
    const deep = (node, p)=>p == size(path) ? arrayPush(leaves, node) : path[p] === null ? collForEach(node, (node2)=>deep(node2, p + 1)) : arrayForEach([
            path[p],
            null
        ], (id)=>deep(mapGet(node, id), p + 1));
    deep(deepIdSet, 0);
    return leaves;
};
const getListenerFunctions = (getThing)=>{
    let thing;
    const [getId, releaseId] = getPoolFunctions();
    const allListeners = mapNew();
    const addListener = (listener, idSetNode, path, pathGetters = [], extraArgsGetter = ()=>[])=>{
        thing ??= getThing();
        const id = getId(1);
        mapSet(allListeners, id, [
            listener,
            idSetNode,
            path,
            pathGetters,
            extraArgsGetter
        ]);
        setAdd(visitTree(idSetNode, path ?? [
            EMPTY_STRING
        ], setNew), id);
        return id;
    };
    const callListeners = (idSetNode, ids, ...extraArgs)=>arrayForEach(getWildcardedLeaves(idSetNode, ids), (set)=>collForEach(set, (id)=>mapGet(allListeners, id)[0](thing, ...ids ?? [], ...extraArgs)));
    const delListener = (id)=>ifNotUndefined(mapGet(allListeners, id), ([, idSetNode, idOrNulls])=>{
            visitTree(idSetNode, idOrNulls ?? [
                EMPTY_STRING
            ], void 0, (idSet)=>{
                collDel(idSet, id);
                return collIsEmpty(idSet) ? 1 : 0;
            });
            mapSet(allListeners, id);
            releaseId(id);
            return idOrNulls;
        });
    const callListener = (id)=>ifNotUndefined(mapGet(allListeners, id), ([listener, , path = [], pathGetters, extraArgsGetter])=>{
            const callWithIds = (...ids)=>{
                const index = size(ids);
                if (index == size(path)) {
                    listener(thing, ...ids, ...extraArgsGetter(ids));
                } else if (isUndefined(path[index])) {
                    arrayForEach(pathGetters[index]?.(...ids) ?? [], (id2)=>callWithIds(...ids, id2));
                } else {
                    callWithIds(...ids, path[index]);
                }
            };
            callWithIds();
        });
    return [
        addListener,
        callListeners,
        delListener,
        callListener
    ];
};
const createCheckpoints = getCreateFunction((store)=>{
    let backwardIdsSize = 100;
    let currentId;
    let cellsDelta = mapNew();
    let valuesDelta = mapNew();
    let listening = 1;
    let nextCheckpointId;
    let checkpointsChanged;
    const checkpointIdsListeners = mapNew();
    const checkpointListeners = mapNew();
    const [addListener, callListeners, delListenerImpl] = getListenerFunctions(()=>checkpoints);
    const deltas = mapNew();
    const labels = mapNew();
    const backwardIds = [];
    const forwardIds = [];
    const updateStore = (oldOrNew, checkpointId)=>{
        listening = 0;
        store.transaction(()=>{
            const [cellsDelta2, valuesDelta2] = mapGet(deltas, checkpointId);
            collForEach(cellsDelta2, (table, tableId)=>collForEach(table, (row, rowId)=>collForEach(row, (oldNew, cellId)=>setOrDelCell(store, tableId, rowId, cellId, oldNew[oldOrNew]))));
            collForEach(valuesDelta2, (oldNew, valueId)=>setOrDelValue(store, valueId, oldNew[oldOrNew]));
        });
        listening = 1;
    };
    const clearCheckpointId = (checkpointId)=>{
        mapSet(deltas, checkpointId);
        mapSet(labels, checkpointId);
        callListeners(checkpointListeners, [
            checkpointId
        ]);
    };
    const clearCheckpointIds = (checkpointIds, to)=>arrayForEach(arrayClear(checkpointIds, to ?? size(checkpointIds)), clearCheckpointId);
    const trimBackwardsIds = ()=>clearCheckpointIds(backwardIds, size(backwardIds) - backwardIdsSize);
    const storeChanged = ()=>ifNotUndefined(currentId, ()=>{
            arrayPush(backwardIds, currentId);
            trimBackwardsIds();
            clearCheckpointIds(forwardIds);
            currentId = void 0;
            checkpointsChanged = 1;
        });
    const storeUnchanged = ()=>{
        currentId = arrayPop(backwardIds);
        checkpointsChanged = 1;
    };
    let cellListenerId;
    let valueListenerId;
    const addCheckpointImpl = (label = EMPTY_STRING)=>{
        if (isUndefined(currentId)) {
            currentId = EMPTY_STRING + nextCheckpointId++;
            mapSet(deltas, currentId, [
                cellsDelta,
                valuesDelta
            ]);
            setCheckpoint(currentId, label);
            cellsDelta = mapNew();
            valuesDelta = mapNew();
            checkpointsChanged = 1;
        }
        return currentId;
    };
    const goBackwardImpl = ()=>{
        if (!arrayIsEmpty(backwardIds)) {
            arrayUnshift(forwardIds, addCheckpointImpl());
            updateStore(0, currentId);
            currentId = arrayPop(backwardIds);
            checkpointsChanged = 1;
        }
    };
    const goForwardImpl = ()=>{
        if (!arrayIsEmpty(forwardIds)) {
            arrayPush(backwardIds, currentId);
            currentId = arrayShift(forwardIds);
            updateStore(1, currentId);
            checkpointsChanged = 1;
        }
    };
    const callListenersIfChanged = ()=>{
        if (checkpointsChanged) {
            callListeners(checkpointIdsListeners);
            checkpointsChanged = 0;
        }
    };
    const setSize = (size2)=>{
        backwardIdsSize = size2;
        trimBackwardsIds();
        return checkpoints;
    };
    const addCheckpoint = (label)=>{
        const id = addCheckpointImpl(label);
        callListenersIfChanged();
        return id;
    };
    const setCheckpoint = (checkpointId, label)=>{
        if (hasCheckpoint(checkpointId) && mapGet(labels, checkpointId) !== label) {
            mapSet(labels, checkpointId, label);
            callListeners(checkpointListeners, [
                checkpointId
            ]);
        }
        return checkpoints;
    };
    const getStore = ()=>store;
    const getCheckpointIds = ()=>[
            [
                ...backwardIds
            ],
            currentId,
            [
                ...forwardIds
            ]
        ];
    const forEachCheckpoint = (checkpointCallback)=>mapForEach(labels, checkpointCallback);
    const hasCheckpoint = (checkpointId)=>collHas(deltas, checkpointId);
    const getCheckpoint = (checkpointId)=>mapGet(labels, checkpointId);
    const goBackward = ()=>{
        goBackwardImpl();
        callListenersIfChanged();
        return checkpoints;
    };
    const goForward = ()=>{
        goForwardImpl();
        callListenersIfChanged();
        return checkpoints;
    };
    const goTo = (checkpointId)=>{
        const action = arrayHas(backwardIds, checkpointId) ? goBackwardImpl : arrayHas(forwardIds, checkpointId) ? goForwardImpl : null;
        while(!isUndefined(action) && checkpointId != currentId){
            action();
        }
        callListenersIfChanged();
        return checkpoints;
    };
    const addCheckpointIdsListener = (listener)=>addListener(listener, checkpointIdsListeners);
    const addCheckpointListener = (checkpointId, listener)=>addListener(listener, checkpointListeners, [
            checkpointId
        ]);
    const delListener = (listenerId)=>{
        delListenerImpl(listenerId);
        return checkpoints;
    };
    const clear = ()=>{
        clearCheckpointIds(backwardIds);
        clearCheckpointIds(forwardIds);
        if (!isUndefined(currentId)) {
            clearCheckpointId(currentId);
        }
        currentId = void 0;
        nextCheckpointId = 0;
        addCheckpoint();
        return checkpoints;
    };
    const clearForward = ()=>{
        if (!arrayIsEmpty(forwardIds)) {
            clearCheckpointIds(forwardIds);
            callListeners(checkpointIdsListeners);
        }
        return checkpoints;
    };
    const destroy = ()=>{
        store.delListener(cellListenerId);
        store.delListener(valueListenerId);
    };
    const getListenerStats = ()=>({
            checkpointIds: collSize2(checkpointIdsListeners),
            checkpoint: collSize2(checkpointListeners)
        });
    const _registerListeners = ()=>{
        cellListenerId = store.addCellListener(null, null, null, (_store, tableId, rowId, cellId, newCell, oldCell)=>{
            if (listening) {
                storeChanged();
                const table = mapEnsure(cellsDelta, tableId, mapNew);
                const row = mapEnsure(table, rowId, mapNew);
                const oldNew = mapEnsure(row, cellId, ()=>[
                        oldCell,
                        void 0
                    ]);
                oldNew[1] = newCell;
                if (oldNew[0] === newCell && collIsEmpty(mapSet(row, cellId)) && collIsEmpty(mapSet(table, rowId)) && collIsEmpty(mapSet(cellsDelta, tableId))) {
                    storeUnchanged();
                }
                callListenersIfChanged();
            }
        });
        valueListenerId = store.addValueListener(null, (_store, valueId, newValue, oldValue)=>{
            if (listening) {
                storeChanged();
                const oldNew = mapEnsure(valuesDelta, valueId, ()=>[
                        oldValue,
                        void 0
                    ]);
                oldNew[1] = newValue;
                if (oldNew[0] === newValue && collIsEmpty(mapSet(valuesDelta, valueId))) {
                    storeUnchanged();
                }
                callListenersIfChanged();
            }
        });
    };
    const checkpoints = {
        setSize,
        addCheckpoint,
        setCheckpoint,
        getStore,
        getCheckpointIds,
        forEachCheckpoint,
        hasCheckpoint,
        getCheckpoint,
        goBackward,
        goForward,
        goTo,
        addCheckpointIdsListener,
        addCheckpointListener,
        delListener,
        clear,
        clearForward,
        destroy,
        getListenerStats,
        _registerListeners
    };
    return objFreeze(checkpoints.clear());
}, (checkpoints)=>checkpoints._registerListeners());
const MASK6 = 63;
const ENCODE = /* @__PURE__ */ strSplit('-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz');
const DECODE = /* @__PURE__ */ mapNew(/* @__PURE__ */ arrayMap(ENCODE, (char, index)=>[
        char,
        index
    ]));
const encode = (num)=>ENCODE[num & MASK6];
const decode = (str, pos)=>mapGet(DECODE, str[pos]) ?? 0;
const getRandomValues = GLOBAL.crypto ? (array)=>GLOBAL.crypto.getRandomValues(array) : /* istanbul ignore next */ (array)=>arrayMap(array, ()=>mathFloor(math.random() * 256));
const defaultSorter = (sortKey1, sortKey2)=>(sortKey1 ?? 0) < (sortKey2 ?? 0) ? -1 : 1;
const getUniqueId = (length = 16)=>arrayReduce(getRandomValues(new Uint8Array(length)), (uniqueId, number)=>uniqueId + encode(number), '');
const createIndexes = getCreateFunction((store)=>{
    const sliceIdsListeners = mapNew();
    const sliceRowIdsListeners = mapNew();
    const [addListener, callListeners, delListenerImpl] = getListenerFunctions(()=>indexes);
    const [getStore, getIndexIds, forEachIndexImpl, hasIndex, getTableId, getIndex, setIndex, , setDefinitionAndListen, delDefinition, addIndexIdsListener, destroy] = getDefinableFunctions(store, mapNew, (value)=>isUndefined(value) ? EMPTY_STRING : isArray(value) ? arrayMap(value, id) : id(value), addListener, callListeners);
    const hasSlice = (indexId, sliceId)=>collHas(getIndex(indexId), sliceId);
    const setIndexDefinition = (indexId, tableId, getSliceIdOrIds, getSortKey, sliceIdSorter, rowIdSorter = defaultSorter)=>{
        const sliceIdArraySorter = isUndefined(sliceIdSorter) ? void 0 : ([id1], [id2])=>sliceIdSorter(id1, id2);
        setDefinitionAndListen(indexId, tableId, (change, changedSliceIds, changedSortKeys, sliceIds, sortKeys, force)=>{
            let sliceIdsChanged = 0;
            const changedSlices = setNew();
            const unsortedSlices = setNew();
            const index = getIndex(indexId);
            collForEach(changedSliceIds, ([oldSliceIdOrIds, newSliceIdOrIds], rowId)=>{
                const oldSliceIds = setNew(oldSliceIdOrIds);
                const newSliceIds = setNew(newSliceIdOrIds);
                collForEach(oldSliceIds, (oldSliceId)=>collDel(newSliceIds, oldSliceId) ? collDel(oldSliceIds, oldSliceId) : 0);
                collForEach(oldSliceIds, (oldSliceId)=>{
                    setAdd(changedSlices, oldSliceId);
                    ifNotUndefined(mapGet(index, oldSliceId), (oldSlice)=>{
                        collDel(oldSlice, rowId);
                        if (collIsEmpty(oldSlice)) {
                            mapSet(index, oldSliceId);
                            sliceIdsChanged = 1;
                        }
                    });
                });
                collForEach(newSliceIds, (newSliceId)=>{
                    setAdd(changedSlices, newSliceId);
                    if (!collHas(index, newSliceId)) {
                        mapSet(index, newSliceId, setNew());
                        sliceIdsChanged = 1;
                    }
                    setAdd(mapGet(index, newSliceId), rowId);
                    if (!isUndefined(getSortKey)) {
                        setAdd(unsortedSlices, newSliceId);
                    }
                });
            });
            change();
            if (!collIsEmpty(sortKeys)) {
                if (force) {
                    mapForEach(index, (sliceId)=>setAdd(unsortedSlices, sliceId));
                } else {
                    mapForEach(changedSortKeys, (rowId)=>ifNotUndefined(mapGet(sliceIds, rowId), (sliceId)=>setAdd(unsortedSlices, sliceId)));
                }
                collForEach(unsortedSlices, (sliceId)=>{
                    const rowIdArraySorter = (rowId1, rowId2)=>rowIdSorter(mapGet(sortKeys, rowId1), mapGet(sortKeys, rowId2), sliceId);
                    const sliceArray = [
                        ...mapGet(index, sliceId)
                    ];
                    if (!arrayIsSorted(sliceArray, rowIdArraySorter)) {
                        mapSet(index, sliceId, setNew(arraySort(sliceArray, rowIdArraySorter)));
                        setAdd(changedSlices, sliceId);
                    }
                });
            }
            if (sliceIdsChanged || force) {
                if (!isUndefined(sliceIdArraySorter)) {
                    const indexArray = [
                        ...index
                    ];
                    if (!arrayIsSorted(indexArray, sliceIdArraySorter)) {
                        setIndex(indexId, mapNew(arraySort(indexArray, sliceIdArraySorter)));
                        sliceIdsChanged = 1;
                    }
                }
            }
            if (sliceIdsChanged) {
                callListeners(sliceIdsListeners, [
                    indexId
                ]);
            }
            collForEach(changedSlices, (sliceId)=>callListeners(sliceRowIdsListeners, [
                    indexId,
                    sliceId
                ]));
        }, getRowCellFunction(getSliceIdOrIds), ifNotUndefined(getSortKey, getRowCellFunction));
        return indexes;
    };
    const forEachIndex = (indexCallback)=>forEachIndexImpl((indexId, slices)=>indexCallback(indexId, (sliceCallback)=>forEachSliceImpl(indexId, sliceCallback, slices)));
    const forEachSlice = (indexId, sliceCallback)=>forEachSliceImpl(indexId, sliceCallback, getIndex(indexId));
    const forEachSliceImpl = (indexId, sliceCallback, slices)=>{
        const tableId = getTableId(indexId);
        collForEach(slices, (rowIds, sliceId)=>sliceCallback(sliceId, (rowCallback)=>collForEach(rowIds, (rowId)=>rowCallback(rowId, (cellCallback)=>store.forEachCell(tableId, rowId, cellCallback)))));
    };
    const delIndexDefinition = (indexId)=>{
        delDefinition(indexId);
        return indexes;
    };
    const getSliceIds = (indexId)=>mapKeys(getIndex(indexId));
    const getSliceRowIds = (indexId, sliceId)=>collValues(mapGet(getIndex(indexId), sliceId));
    const addSliceIdsListener = (indexId, listener)=>addListener(listener, sliceIdsListeners, [
            indexId
        ]);
    const addSliceRowIdsListener = (indexId, sliceId, listener)=>addListener(listener, sliceRowIdsListeners, [
            indexId,
            sliceId
        ]);
    const delListener = (listenerId)=>{
        delListenerImpl(listenerId);
        return indexes;
    };
    const getListenerStats = ()=>({
            sliceIds: collSize2(sliceIdsListeners),
            sliceRowIds: collSize3(sliceRowIdsListeners)
        });
    const indexes = {
        setIndexDefinition,
        delIndexDefinition,
        getStore,
        getIndexIds,
        forEachIndex,
        forEachSlice,
        hasIndex,
        hasSlice,
        getTableId,
        getSliceIds,
        getSliceRowIds,
        addIndexIdsListener,
        addSliceIdsListener,
        addSliceRowIdsListener,
        delListener,
        destroy,
        getListenerStats
    };
    return objFreeze(indexes);
});
const numericAggregators = /* @__PURE__ */ mapNew([
    [
        AVG,
        [
            (numbers, length)=>arraySum(numbers) / length,
            (metric, add, length)=>metric + (add - metric) / (length + 1),
            (metric, remove, length)=>metric + (metric - remove) / (length - 1),
            (metric, add, remove, length)=>metric + (add - remove) / length
        ]
    ],
    [
        MAX,
        [
            (numbers)=>mathMax(...numbers),
            (metric, add)=>mathMax(add, metric),
            (metric, remove)=>remove == metric ? void 0 : metric,
            (metric, add, remove)=>remove == metric ? void 0 : mathMax(add, metric)
        ]
    ],
    [
        MIN,
        [
            (numbers)=>mathMin(...numbers),
            (metric, add)=>mathMin(add, metric),
            (metric, remove)=>remove == metric ? void 0 : metric,
            (metric, add, remove)=>remove == metric ? void 0 : mathMin(add, metric)
        ]
    ],
    [
        SUM,
        [
            (numbers)=>arraySum(numbers),
            (metric, add)=>metric + add,
            (metric, remove)=>metric - remove,
            (metric, add, remove)=>metric - remove + add
        ]
    ]
]);
const getAggregateValue = (aggregateValue, oldLength, newValues, changedValues, aggregators, force = false)=>{
    if (collIsEmpty(newValues)) {
        return void 0;
    }
    const [aggregate, aggregateAdd, aggregateRemove, aggregateReplace] = aggregators;
    force ||= isUndefined(aggregateValue);
    collForEach(changedValues, ([oldValue, newValue])=>{
        if (!force) {
            aggregateValue = isUndefined(oldValue) ? aggregateAdd?.(aggregateValue, newValue, oldLength++) : isUndefined(newValue) ? aggregateRemove?.(aggregateValue, oldValue, oldLength--) : aggregateReplace?.(aggregateValue, newValue, oldValue, oldLength);
            force ||= isUndefined(aggregateValue);
        }
    });
    return force ? aggregate(collValues(newValues), collSize(newValues)) : aggregateValue;
};
const createMetrics = getCreateFunction((store)=>{
    const metricListeners = mapNew();
    const [addListener, callListeners, delListenerImpl] = getListenerFunctions(()=>metrics);
    const [getStore, getMetricIds, forEachMetric, hasMetric, getTableId, getMetric, setMetric, , setDefinitionAndListen, delDefinition, addMetricIdsListener, destroy] = getDefinableFunctions(store, getUndefined, (value)=>isNaN(value) || isUndefined(value) || value === true || value === false || value === EMPTY_STRING ? void 0 : value * 1, addListener, callListeners);
    const setMetricDefinition = (metricId, tableId, aggregate, getNumber, aggregateAdd, aggregateRemove, aggregateReplace)=>{
        const aggregators = isFunction(aggregate) ? [
            aggregate,
            aggregateAdd,
            aggregateRemove,
            aggregateReplace
        ] : mapGet(numericAggregators, aggregate) ?? mapGet(numericAggregators, SUM);
        setDefinitionAndListen(metricId, tableId, (change, changedNumbers, _changedSortKeys, numbers, _sortKeys, force)=>{
            const oldMetric = getMetric(metricId);
            const oldLength = collSize(numbers);
            force ||= isUndefined(oldMetric);
            change();
            let newMetric = getAggregateValue(oldMetric, oldLength, numbers, changedNumbers, aggregators, force);
            if (!isFiniteNumber(newMetric)) {
                newMetric = void 0;
            }
            if (newMetric != oldMetric) {
                setMetric(metricId, newMetric);
                callListeners(metricListeners, [
                    metricId
                ], newMetric, oldMetric);
            }
        }, getRowCellFunction(getNumber, 1));
        return metrics;
    };
    const delMetricDefinition = (metricId)=>{
        delDefinition(metricId);
        return metrics;
    };
    const addMetricListener = (metricId, listener)=>addListener(listener, metricListeners, [
            metricId
        ]);
    const delListener = (listenerId)=>{
        delListenerImpl(listenerId);
        return metrics;
    };
    const getListenerStats = ()=>({
            metric: collSize2(metricListeners)
        });
    const metrics = {
        setMetricDefinition,
        delMetricDefinition,
        getStore,
        getMetricIds,
        forEachMetric,
        hasMetric,
        getTableId,
        getMetric,
        addMetricIdsListener,
        addMetricListener,
        delListener,
        destroy,
        getListenerStats
    };
    return objFreeze(metrics);
});
const createQueries = getCreateFunction((store)=>{
    const createStore = store.createStore;
    const preStore = createStore();
    const resultStore = createStore();
    const preStoreListenerIds = mapNew();
    const { addListener, callListeners, delListener: delListenerImpl } = resultStore;
    const [getStore, getQueryIds, forEachQuery, hasQuery, getTableId, , , setDefinition, , delDefinition, addQueryIdsListenerImpl, destroy, addStoreListeners, delStoreListeners] = getDefinableFunctions(store, ()=>true, getUndefined, addListener, callListeners);
    const addPreStoreListener = (preStore2, queryId, ...listenerIds)=>arrayForEach(listenerIds, (listenerId)=>setAdd(mapEnsure(mapEnsure(preStoreListenerIds, queryId, mapNew), preStore2, setNew), listenerId));
    const resetPreStores = (queryId)=>{
        ifNotUndefined(mapGet(preStoreListenerIds, queryId), (queryPreStoreListenerIds)=>{
            mapForEach(queryPreStoreListenerIds, (preStore2, listenerIds)=>collForEach(listenerIds, (listenerId)=>preStore2.delListener(listenerId)));
            collClear(queryPreStoreListenerIds);
        });
        arrayForEach([
            resultStore,
            preStore
        ], (store2)=>store2.delTable(queryId));
    };
    const synchronizeTransactions = (queryId, fromStore, toStore)=>addPreStoreListener(fromStore, queryId, fromStore.addStartTransactionListener(toStore.startTransaction), fromStore.addDidFinishTransactionListener(()=>toStore.finishTransaction()));
    const setQueryDefinition = (queryId, tableId, build)=>{
        setDefinition(queryId, tableId);
        resetPreStores(queryId);
        const selectEntries = [];
        const joinEntries = [
            [
                null,
                [
                    tableId,
                    null,
                    null,
                    [],
                    mapNew()
                ]
            ]
        ];
        const wheres = [];
        const groupEntries = [];
        const havings = [];
        const select = (arg1, arg2)=>{
            const selectEntry = isFunction(arg1) ? [
                size(selectEntries) + EMPTY_STRING,
                arg1
            ] : [
                isUndefined(arg2) ? arg1 : arg2,
                (getTableCell)=>getTableCell(arg1, arg2)
            ];
            arrayPush(selectEntries, selectEntry);
            return {
                as: (selectedCellId)=>selectEntry[0] = selectedCellId
            };
        };
        const join = (joinedTableId, arg1, arg2)=>{
            const fromIntermediateJoinedTableId = isUndefined(arg2) || isFunction(arg1) ? null : arg1;
            const onArg = isUndefined(fromIntermediateJoinedTableId) ? arg1 : arg2;
            const joinEntry = [
                joinedTableId,
                [
                    joinedTableId,
                    fromIntermediateJoinedTableId,
                    isFunction(onArg) ? onArg : (getCell)=>getCell(onArg),
                    [],
                    mapNew()
                ]
            ];
            arrayPush(joinEntries, joinEntry);
            return {
                as: (joinedTableId2)=>joinEntry[0] = joinedTableId2
            };
        };
        const where = (arg1, arg2, arg3)=>arrayPush(wheres, isFunction(arg1) ? arg1 : isUndefined(arg3) ? (getTableCell)=>getTableCell(arg1) === arg2 : (getTableCell)=>getTableCell(arg1, arg2) === arg3);
        const group = (selectedCellId, aggregate, aggregateAdd, aggregateRemove, aggregateReplace)=>{
            const groupEntry = [
                selectedCellId,
                [
                    selectedCellId,
                    isFunction(aggregate) ? [
                        aggregate,
                        aggregateAdd,
                        aggregateRemove,
                        aggregateReplace
                    ] : mapGet(numericAggregators, aggregate) ?? [
                        (_cells, length)=>length
                    ]
                ]
            ];
            arrayPush(groupEntries, groupEntry);
            return {
                as: (groupedCellId)=>groupEntry[0] = groupedCellId
            };
        };
        const having = (arg1, arg2)=>arrayPush(havings, isFunction(arg1) ? arg1 : (getSelectedOrGroupedCell)=>getSelectedOrGroupedCell(arg1) === arg2);
        build({
            select,
            join,
            where,
            group,
            having
        });
        const selects = mapNew(selectEntries);
        if (collIsEmpty(selects)) {
            return queries;
        }
        const joins = mapNew(joinEntries);
        mapForEach(joins, (asTableId, [, fromAsTableId])=>ifNotUndefined(mapGet(joins, fromAsTableId), ({ 3: toAsTableIds })=>isUndefined(asTableId) ? 0 : arrayPush(toAsTableIds, asTableId)));
        const groups = mapNew(groupEntries);
        let selectJoinWhereStore = preStore;
        if (collIsEmpty(groups) && arrayIsEmpty(havings)) {
            selectJoinWhereStore = resultStore;
        } else {
            synchronizeTransactions(queryId, selectJoinWhereStore, resultStore);
            const groupedSelectedCellIds = mapNew();
            mapForEach(groups, (groupedCellId, [selectedCellId, aggregators])=>setAdd(mapEnsure(groupedSelectedCellIds, selectedCellId, setNew), [
                    groupedCellId,
                    aggregators
                ]));
            const groupBySelectedCellIds = setNew();
            mapForEach(selects, (selectedCellId)=>collHas(groupedSelectedCellIds, selectedCellId) ? 0 : setAdd(groupBySelectedCellIds, selectedCellId));
            const tree = mapNew();
            const writeGroupRow = (leaf, changedGroupedSelectedCells, selectedRowId, forceRemove)=>ifNotUndefined(leaf, ([selectedCells, selectedRowIds, groupRowId, groupRow])=>{
                    mapForEach(changedGroupedSelectedCells, (selectedCellId, [newCell])=>{
                        const selectedCell = mapEnsure(selectedCells, selectedCellId, mapNew);
                        const oldLeafCell = mapGet(selectedCell, selectedRowId);
                        const newLeafCell = forceRemove ? void 0 : newCell;
                        if (oldLeafCell !== newLeafCell) {
                            const oldNewSet = setNew([
                                [
                                    oldLeafCell,
                                    newLeafCell
                                ]
                            ]);
                            const oldLength = collSize(selectedCell);
                            mapSet(selectedCell, selectedRowId, newLeafCell);
                            collForEach(mapGet(groupedSelectedCellIds, selectedCellId), ([groupedCellId, aggregators])=>{
                                const aggregateValue = getAggregateValue(groupRow[groupedCellId], oldLength, selectedCell, oldNewSet, aggregators);
                                groupRow[groupedCellId] = isUndefined(getCellOrValueType(aggregateValue)) ? null : aggregateValue;
                            });
                        }
                    });
                    if (collIsEmpty(selectedRowIds) || !arrayEvery(havings, (having2)=>having2((cellId)=>groupRow[cellId]))) {
                        resultStore.delRow(queryId, groupRowId);
                    } else if (isUndefined(groupRowId)) {
                        leaf[2] = resultStore.addRow(queryId, groupRow);
                    } else {
                        resultStore.setRow(queryId, groupRowId, groupRow);
                    }
                });
            addPreStoreListener(selectJoinWhereStore, queryId, selectJoinWhereStore.addRowListener(queryId, null, (_store, _tableId, selectedRowId, getCellChange)=>{
                const oldPath = [];
                const newPath = [];
                const changedGroupedSelectedCells = mapNew();
                const rowExists = selectJoinWhereStore.hasRow(queryId, selectedRowId);
                let changedLeaf = !rowExists;
                collForEach(groupBySelectedCellIds, (selectedCellId)=>{
                    const [changed, oldCell, newCell] = getCellChange(queryId, selectedRowId, selectedCellId);
                    arrayPush(oldPath, oldCell);
                    arrayPush(newPath, newCell);
                    changedLeaf ||= changed;
                });
                mapForEach(groupedSelectedCellIds, (selectedCellId)=>{
                    const [changed, , newCell] = getCellChange(queryId, selectedRowId, selectedCellId);
                    if (changedLeaf || changed) {
                        mapSet(changedGroupedSelectedCells, selectedCellId, [
                            newCell
                        ]);
                    }
                });
                if (changedLeaf) {
                    writeGroupRow(visitTree(tree, oldPath, void 0, ([, selectedRowIds])=>{
                        collDel(selectedRowIds, selectedRowId);
                        return collIsEmpty(selectedRowIds);
                    }), changedGroupedSelectedCells, selectedRowId, 1);
                }
                if (rowExists) {
                    writeGroupRow(visitTree(tree, newPath, ()=>{
                        const groupRow = {};
                        collForEach(groupBySelectedCellIds, (selectedCellId)=>groupRow[selectedCellId] = selectJoinWhereStore.getCell(queryId, selectedRowId, selectedCellId));
                        return [
                            mapNew(),
                            setNew(),
                            void 0,
                            groupRow
                        ];
                    }, ([, selectedRowIds])=>{
                        setAdd(selectedRowIds, selectedRowId);
                    }), changedGroupedSelectedCells, selectedRowId);
                }
            }));
        }
        synchronizeTransactions(queryId, store, selectJoinWhereStore);
        const writeSelectRow = (rootRowId)=>{
            const getTableCell = (arg1, arg2)=>store.getCell(...isUndefined(arg2) ? [
                    tableId,
                    rootRowId,
                    arg1
                ] : arg1 === tableId ? [
                    tableId,
                    rootRowId,
                    arg2
                ] : [
                    mapGet(joins, arg1)?.[0],
                    mapGet(mapGet(joins, arg1)?.[4], rootRowId)?.[0],
                    arg2
                ]);
            selectJoinWhereStore.transaction(()=>arrayEvery(wheres, (where2)=>where2(getTableCell)) ? mapForEach(selects, (asCellId, tableCellGetter)=>setOrDelCell(selectJoinWhereStore, queryId, rootRowId, asCellId, tableCellGetter(getTableCell, rootRowId))) : selectJoinWhereStore.delRow(queryId, rootRowId));
        };
        const listenToTable = (rootRowId, tableId2, rowId, joinedTableIds2)=>{
            const getCell = (cellId)=>store.getCell(tableId2, rowId, cellId);
            arrayForEach(joinedTableIds2, (remoteAsTableId)=>{
                const [realJoinedTableId, , on, nextJoinedTableIds, remoteIdPair] = mapGet(joins, remoteAsTableId);
                const remoteRowId = on?.(getCell, rootRowId);
                const [previousRemoteRowId, previousRemoteListenerId] = mapGet(remoteIdPair, rootRowId) ?? [];
                if (remoteRowId != previousRemoteRowId) {
                    if (!isUndefined(previousRemoteListenerId)) {
                        delStoreListeners(queryId, previousRemoteListenerId);
                    }
                    mapSet(remoteIdPair, rootRowId, isUndefined(remoteRowId) ? null : [
                        remoteRowId,
                        ...addStoreListeners(queryId, 1, store.addRowListener(realJoinedTableId, remoteRowId, ()=>listenToTable(rootRowId, realJoinedTableId, remoteRowId, nextJoinedTableIds)))
                    ]);
                }
            });
            writeSelectRow(rootRowId);
        };
        const { 3: joinedTableIds } = mapGet(joins, null);
        selectJoinWhereStore.transaction(()=>addStoreListeners(queryId, 1, store.addRowListener(tableId, null, (_store, _tableId, rootRowId)=>{
                if (store.hasRow(tableId, rootRowId)) {
                    listenToTable(rootRowId, tableId, rootRowId, joinedTableIds);
                } else {
                    selectJoinWhereStore.delRow(queryId, rootRowId);
                    collForEach(joins, ({ 4: idsByRootRowId })=>ifNotUndefined(mapGet(idsByRootRowId, rootRowId), ([, listenerId])=>{
                            delStoreListeners(queryId, listenerId);
                            mapSet(idsByRootRowId, rootRowId);
                        }));
                }
            })));
        return queries;
    };
    const delQueryDefinition = (queryId)=>{
        resetPreStores(queryId);
        delDefinition(queryId);
        return queries;
    };
    const addQueryIdsListener = (listener)=>addQueryIdsListenerImpl(()=>listener(queries));
    const delListener = (listenerId)=>{
        delListenerImpl(listenerId);
        return queries;
    };
    const getListenerStats = ()=>{
        const { tables: _1, tableIds: _2, transaction: _3, ...stats } = resultStore.getListenerStats();
        return stats;
    };
    const queries = {
        setQueryDefinition,
        delQueryDefinition,
        getStore,
        getQueryIds,
        forEachQuery,
        hasQuery,
        getTableId,
        addQueryIdsListener,
        delListener,
        destroy,
        getListenerStats
    };
    objMap({
        [TABLE]: [
            1,
            1
        ],
        [TABLE + CELL_IDS]: [
            0,
            1
        ],
        [ROW_COUNT]: [
            0,
            1
        ],
        [ROW_IDS]: [
            0,
            1
        ],
        [SORTED_ROW_IDS]: [
            0,
            5
        ],
        [ROW]: [
            1,
            2
        ],
        [CELL_IDS]: [
            0,
            2
        ],
        [CELL]: [
            1,
            3
        ]
    }, ([hasAndForEach, argumentCount], gettable)=>{
        arrayForEach(hasAndForEach ? [
            GET,
            'has',
            'forEach'
        ] : [
            GET
        ], (prefix)=>queries[prefix + RESULT + gettable] = (...args)=>resultStore[prefix + gettable](...args));
        queries[ADD + RESULT + gettable + LISTENER] = (...args)=>resultStore[ADD + gettable + LISTENER](...slice(args, 0, argumentCount), (_store, ...listenerArgs)=>args[argumentCount](queries, ...listenerArgs), true);
    });
    return objFreeze(queries);
});
const createRelationships = getCreateFunction((store)=>{
    const remoteTableIds = mapNew();
    const remoteRowIdListeners = mapNew();
    const localRowIdsListeners = mapNew();
    const linkedRowIdsListeners = mapNew();
    const [addListener, callListeners, delListenerImpl] = getListenerFunctions(()=>relationships);
    const [getStore, getRelationshipIds, forEachRelationshipImpl, hasRelationship, getLocalTableId, getRelationship, , , setDefinitionAndListen, delDefinition, addRelationshipIdsListener, destroy] = getDefinableFunctions(store, ()=>[
            mapNew(),
            mapNew(),
            mapNew(),
            mapNew()
        ], (value)=>isUndefined(value) ? void 0 : value + EMPTY_STRING, addListener, callListeners);
    const getLinkedRowIdsCache = (relationshipId, firstRowId, skipCache)=>ifNotUndefined(getRelationship(relationshipId), ([remoteRows, , linkedRowsCache])=>{
            if (!collHas(linkedRowsCache, firstRowId)) {
                const linkedRows = setNew();
                if (getLocalTableId(relationshipId) != getRemoteTableId(relationshipId)) {
                    setAdd(linkedRows, firstRowId);
                } else {
                    let rowId = firstRowId;
                    while(!isUndefined(rowId) && !collHas(linkedRows, rowId)){
                        setAdd(linkedRows, rowId);
                        rowId = mapGet(remoteRows, rowId);
                    }
                }
                if (skipCache) {
                    return linkedRows;
                }
                mapSet(linkedRowsCache, firstRowId, linkedRows);
            }
            return mapGet(linkedRowsCache, firstRowId);
        });
    const delLinkedRowIdsCache = (relationshipId, firstRowId)=>ifNotUndefined(getRelationship(relationshipId), ([, , linkedRowsCache])=>mapSet(linkedRowsCache, firstRowId));
    const setRelationshipDefinition = (relationshipId, localTableId, remoteTableId, getRemoteRowId2)=>{
        mapSet(remoteTableIds, relationshipId, remoteTableId);
        setDefinitionAndListen(relationshipId, localTableId, (change, changedRemoteRowIds)=>{
            const changedLocalRows = setNew();
            const changedRemoteRows = setNew();
            const changedLinkedRows = setNew();
            const [localRows, remoteRows] = getRelationship(relationshipId);
            collForEach(changedRemoteRowIds, ([oldRemoteRowId, newRemoteRowId], localRowId)=>{
                if (!isUndefined(oldRemoteRowId)) {
                    setAdd(changedRemoteRows, oldRemoteRowId);
                    ifNotUndefined(mapGet(remoteRows, oldRemoteRowId), (oldRemoteRow)=>{
                        collDel(oldRemoteRow, localRowId);
                        if (collIsEmpty(oldRemoteRow)) {
                            mapSet(remoteRows, oldRemoteRowId);
                        }
                    });
                }
                if (!isUndefined(newRemoteRowId)) {
                    setAdd(changedRemoteRows, newRemoteRowId);
                    if (!collHas(remoteRows, newRemoteRowId)) {
                        mapSet(remoteRows, newRemoteRowId, setNew());
                    }
                    setAdd(mapGet(remoteRows, newRemoteRowId), localRowId);
                }
                setAdd(changedLocalRows, localRowId);
                mapSet(localRows, localRowId, newRemoteRowId);
                mapForEach(mapGet(linkedRowIdsListeners, relationshipId), (firstRowId)=>{
                    if (collHas(getLinkedRowIdsCache(relationshipId, firstRowId), localRowId)) {
                        setAdd(changedLinkedRows, firstRowId);
                    }
                });
            });
            change();
            collForEach(changedLocalRows, (localRowId)=>callListeners(remoteRowIdListeners, [
                    relationshipId,
                    localRowId
                ]));
            collForEach(changedRemoteRows, (remoteRowId)=>callListeners(localRowIdsListeners, [
                    relationshipId,
                    remoteRowId
                ]));
            collForEach(changedLinkedRows, (firstRowId)=>{
                delLinkedRowIdsCache(relationshipId, firstRowId);
                callListeners(linkedRowIdsListeners, [
                    relationshipId,
                    firstRowId
                ]);
            });
        }, getRowCellFunction(getRemoteRowId2));
        return relationships;
    };
    const forEachRelationship = (relationshipCallback)=>forEachRelationshipImpl((relationshipId)=>relationshipCallback(relationshipId, (rowCallback)=>store.forEachRow(getLocalTableId(relationshipId), rowCallback)));
    const delRelationshipDefinition = (relationshipId)=>{
        mapSet(remoteTableIds, relationshipId);
        delDefinition(relationshipId);
        return relationships;
    };
    const getRemoteTableId = (relationshipId)=>mapGet(remoteTableIds, relationshipId);
    const getRemoteRowId = (relationshipId, localRowId)=>mapGet(getRelationship(relationshipId)?.[0], localRowId);
    const getLocalRowIds = (relationshipId, remoteRowId)=>collValues(mapGet(getRelationship(relationshipId)?.[1], remoteRowId));
    const getLinkedRowIds = (relationshipId, firstRowId)=>isUndefined(getRelationship(relationshipId)) ? [
            firstRowId
        ] : collValues(getLinkedRowIdsCache(relationshipId, firstRowId, true));
    const addRemoteRowIdListener = (relationshipId, localRowId, listener)=>addListener(listener, remoteRowIdListeners, [
            relationshipId,
            localRowId
        ]);
    const addLocalRowIdsListener = (relationshipId, remoteRowId, listener)=>addListener(listener, localRowIdsListeners, [
            relationshipId,
            remoteRowId
        ]);
    const addLinkedRowIdsListener = (relationshipId, firstRowId, listener)=>{
        getLinkedRowIdsCache(relationshipId, firstRowId);
        return addListener(listener, linkedRowIdsListeners, [
            relationshipId,
            firstRowId
        ]);
    };
    const delListener = (listenerId)=>{
        delLinkedRowIdsCache(...delListenerImpl(listenerId) ?? []);
        return relationships;
    };
    const getListenerStats = ()=>({
            remoteRowId: collSize3(remoteRowIdListeners),
            localRowIds: collSize3(localRowIdsListeners),
            linkedRowIds: collSize3(linkedRowIdsListeners)
        });
    const relationships = {
        setRelationshipDefinition,
        delRelationshipDefinition,
        getStore,
        getRelationshipIds,
        forEachRelationship,
        hasRelationship,
        getLocalTableId,
        getRemoteTableId,
        getRemoteRowId,
        getLocalRowIds,
        getLinkedRowIds,
        addRelationshipIdsListener,
        addRemoteRowIdListener,
        addLocalRowIdsListener,
        addLinkedRowIdsListener,
        delListener,
        destroy,
        getListenerStats
    };
    return objFreeze(relationships);
});
const textEncoder = /* @__PURE__ */ new GLOBAL.TextEncoder();
const getHash = (value)=>{
    let hash = 2166136261;
    arrayForEach(textEncoder.encode(value), (char)=>{
        hash ^= char;
        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    });
    return hash >>> 0;
};
const stampClone = ([value, time])=>stampNew(value, time);
const stampCloneWithHash = ([value, time, hash])=>[
        value,
        time,
        hash
    ];
const stampNew = (value, time)=>time ? [
        value,
        time
    ] : [
        value
    ];
const stampNewWithHash = (value, time, hash)=>[
        value,
        time,
        hash
    ];
const getStampHash = (stamp)=>stamp[2];
const hashIdAndHash = (id, hash)=>getHash(id + ':' + hash);
const replaceTimeHash = (oldTime, newTime)=>newTime > oldTime ? (oldTime ? getHash(oldTime) : 0) ^ getHash(newTime) : 0;
const getLatestTime = (time1, time2)=>/* istanbul ignore next */ ((time1 ?? '') > (time2 ?? '') ? time1 : time2) ?? '';
const stampUpdate = (stamp, time, hash)=>{
    if (time > stamp[1]) {
        stamp[1] = time;
    }
    stamp[2] = hash >>> 0;
};
const stampNewObj = (time = EMPTY_STRING)=>stampNew(objNew(), time);
const stampNewMap = (time = EMPTY_STRING)=>[
        mapNew(),
        time,
        0
    ];
const stampMapToObjWithHash = ([map, time, hash], mapper = stampCloneWithHash)=>[
        mapToObj(map, mapper),
        time,
        hash
    ];
const stampMapToObjWithoutHash = ([map, time], mapper = stampClone)=>stampNew(mapToObj(map, mapper), time);
const stampValidate = (stamp, validateThing)=>isArray(stamp) && size(stamp) == 3 && isString(stamp[1]) && getTypeOf(stamp[2]) == NUMBER && isFiniteNumber(stamp[2]) && validateThing(stamp[0]);
const pairNew = (value)=>[
        value,
        value
    ];
const pairCollSize2 = (pair, func = collSize2)=>func(pair[0]) + func(pair[1]);
const pairNewMap = ()=>[
        mapNew(),
        mapNew()
    ];
const pairClone = (array)=>[
        ...array
    ];
const pairIsEqual = ([entry1, entry2])=>entry1 === entry2;
const jsonString = JSON.stringify;
const jsonParse = JSON.parse;
const jsonStringWithMap = (obj)=>jsonString(obj, (_key, value)=>isInstanceOf(value, Map) ? object.fromEntries([
            ...value
        ]) : value);
const idsChanged = (changedIds, id2, addedOrRemoved)=>mapSet(changedIds, id2, mapGet(changedIds, id2) == -addedOrRemoved ? void 0 : addedOrRemoved);
const createStore = ()=>{
    let hasTablesSchema;
    let hasValuesSchema;
    let hadTables = false;
    let hadValues = false;
    let transactions = 0;
    let internalListeners = [];
    const changedTableIds = mapNew();
    const changedTableCellIds = mapNew();
    const changedRowCount = mapNew();
    const changedRowIds = mapNew();
    const changedCellIds = mapNew();
    const changedCells = mapNew();
    const changedValueIds = mapNew();
    const changedValues = mapNew();
    const invalidCells = mapNew();
    const invalidValues = mapNew();
    const tablesSchemaMap = mapNew();
    const tablesSchemaRowCache = mapNew();
    const valuesSchemaMap = mapNew();
    const valuesDefaulted = mapNew();
    const valuesNonDefaulted = setNew();
    const tablePoolFunctions = mapNew();
    const tableCellIds = mapNew();
    const tablesMap = mapNew();
    const valuesMap = mapNew();
    const hasTablesListeners = pairNewMap();
    const tablesListeners = pairNewMap();
    const tableIdsListeners = pairNewMap();
    const hasTableListeners = pairNewMap();
    const tableListeners = pairNewMap();
    const tableCellIdsListeners = pairNewMap();
    const hasTableCellListeners = pairNewMap();
    const rowCountListeners = pairNewMap();
    const rowIdsListeners = pairNewMap();
    const sortedRowIdsListeners = pairNewMap();
    const hasRowListeners = pairNewMap();
    const rowListeners = pairNewMap();
    const cellIdsListeners = pairNewMap();
    const hasCellListeners = pairNewMap();
    const cellListeners = pairNewMap();
    const invalidCellListeners = pairNewMap();
    const invalidValueListeners = pairNewMap();
    const hasValuesListeners = pairNewMap();
    const valuesListeners = pairNewMap();
    const valueIdsListeners = pairNewMap();
    const hasValueListeners = pairNewMap();
    const valueListeners = pairNewMap();
    const startTransactionListeners = mapNew();
    const finishTransactionListeners = pairNewMap();
    const [addListener, callListeners, delListenerImpl, callListenerImpl] = getListenerFunctions(()=>store);
    const validateTablesSchema = (tableSchema)=>objValidate(tableSchema, (tableSchema2)=>objValidate(tableSchema2, validateCellOrValueSchema));
    const validateValuesSchema = (valuesSchema)=>objValidate(valuesSchema, validateCellOrValueSchema);
    const validateCellOrValueSchema = (schema)=>{
        if (!objValidate(schema, (_child, id2)=>arrayHas([
                TYPE,
                DEFAULT
            ], id2))) {
            return false;
        }
        const type = schema[TYPE];
        if (!isTypeStringOrBoolean(type) && type != NUMBER) {
            return false;
        }
        if (getCellOrValueType(schema[DEFAULT]) != type) {
            objDel(schema, DEFAULT);
        }
        return true;
    };
    const validateContent = isArray;
    const validateTables = (tables)=>objValidate(tables, validateTable, cellInvalid);
    const validateTable = (table, tableId)=>(!hasTablesSchema || collHas(tablesSchemaMap, tableId) || /* istanbul ignore next */ cellInvalid(tableId)) && objValidate(table, (row, rowId)=>validateRow(tableId, rowId, row), ()=>cellInvalid(tableId));
    const validateRow = (tableId, rowId, row, skipDefaults)=>objValidate(skipDefaults ? row : addDefaultsToRow(row, tableId, rowId), (cell, cellId)=>ifNotUndefined(getValidatedCell(tableId, rowId, cellId, cell), (validCell)=>{
                row[cellId] = validCell;
                return true;
            }, ()=>false), ()=>cellInvalid(tableId, rowId));
    const getValidatedCell = (tableId, rowId, cellId, cell)=>hasTablesSchema ? ifNotUndefined(mapGet(mapGet(tablesSchemaMap, tableId), cellId), (cellSchema)=>getCellOrValueType(cell) != cellSchema[TYPE] ? cellInvalid(tableId, rowId, cellId, cell, cellSchema[DEFAULT]) : cell, ()=>cellInvalid(tableId, rowId, cellId, cell)) : isUndefined(getCellOrValueType(cell)) ? cellInvalid(tableId, rowId, cellId, cell) : cell;
    const validateValues = (values, skipDefaults)=>objValidate(skipDefaults ? values : addDefaultsToValues(values), (value, valueId)=>ifNotUndefined(getValidatedValue(valueId, value), (validValue)=>{
                values[valueId] = validValue;
                return true;
            }, ()=>false), ()=>valueInvalid());
    const getValidatedValue = (valueId, value)=>hasValuesSchema ? ifNotUndefined(mapGet(valuesSchemaMap, valueId), (valueSchema)=>getCellOrValueType(value) != valueSchema[TYPE] ? valueInvalid(valueId, value, valueSchema[DEFAULT]) : value, ()=>valueInvalid(valueId, value)) : isUndefined(getCellOrValueType(value)) ? valueInvalid(valueId, value) : value;
    const addDefaultsToRow = (row, tableId, rowId)=>{
        ifNotUndefined(mapGet(tablesSchemaRowCache, tableId), ([rowDefaulted, rowNonDefaulted])=>{
            collForEach(rowDefaulted, (cell, cellId)=>{
                if (!objHas(row, cellId)) {
                    row[cellId] = cell;
                }
            });
            collForEach(rowNonDefaulted, (cellId)=>{
                if (!objHas(row, cellId)) {
                    cellInvalid(tableId, rowId, cellId);
                }
            });
        });
        return row;
    };
    const addDefaultsToValues = (values)=>{
        if (hasValuesSchema) {
            collForEach(valuesDefaulted, (value, valueId)=>{
                if (!objHas(values, valueId)) {
                    values[valueId] = value;
                }
            });
            collForEach(valuesNonDefaulted, (valueId)=>{
                if (!objHas(values, valueId)) {
                    valueInvalid(valueId);
                }
            });
        }
        return values;
    };
    const setValidTablesSchema = (tablesSchema)=>mapMatch(tablesSchemaMap, tablesSchema, (_tablesSchema, tableId, tableSchema)=>{
            const rowDefaulted = mapNew();
            const rowNonDefaulted = setNew();
            mapMatch(mapEnsure(tablesSchemaMap, tableId, mapNew), tableSchema, (tableSchemaMap, cellId, cellSchema)=>{
                mapSet(tableSchemaMap, cellId, cellSchema);
                ifNotUndefined(cellSchema[DEFAULT], (def)=>mapSet(rowDefaulted, cellId, def), ()=>setAdd(rowNonDefaulted, cellId));
            });
            mapSet(tablesSchemaRowCache, tableId, [
                rowDefaulted,
                rowNonDefaulted
            ]);
        }, (_tablesSchema, tableId)=>{
            mapSet(tablesSchemaMap, tableId);
            mapSet(tablesSchemaRowCache, tableId);
        });
    const setValidValuesSchema = (valuesSchema)=>mapMatch(valuesSchemaMap, valuesSchema, (_valuesSchema, valueId, valueSchema)=>{
            mapSet(valuesSchemaMap, valueId, valueSchema);
            ifNotUndefined(valueSchema[DEFAULT], (def)=>mapSet(valuesDefaulted, valueId, def), ()=>setAdd(valuesNonDefaulted, valueId));
        }, (_valuesSchema, valueId)=>{
            mapSet(valuesSchemaMap, valueId);
            mapSet(valuesDefaulted, valueId);
            collDel(valuesNonDefaulted, valueId);
        });
    const setOrDelTables = (tables)=>objIsEmpty(tables) ? delTables() : setTables(tables);
    const setValidContent = ([tables, values])=>{
        (objIsEmpty(tables) ? delTables : setTables)(tables);
        (objIsEmpty(values) ? delValues : setValues)(values);
    };
    const setValidTables = (tables)=>mapMatch(tablesMap, tables, (_tables, tableId, table)=>setValidTable(tableId, table), (_tables, tableId)=>delValidTable(tableId));
    const setValidTable = (tableId, table)=>mapMatch(mapEnsure(tablesMap, tableId, ()=>{
            tableIdsChanged(tableId, 1);
            mapSet(tablePoolFunctions, tableId, getPoolFunctions());
            mapSet(tableCellIds, tableId, mapNew());
            return mapNew();
        }), table, (tableMap, rowId, row)=>setValidRow(tableId, tableMap, rowId, row), (tableMap, rowId)=>delValidRow(tableId, tableMap, rowId));
    const setValidRow = (tableId, tableMap, rowId, row, forceDel)=>mapMatch(mapEnsure(tableMap, rowId, ()=>{
            rowIdsChanged(tableId, rowId, 1);
            return mapNew();
        }), row, (rowMap, cellId, cell)=>setValidCell(tableId, rowId, rowMap, cellId, cell), (rowMap, cellId)=>delValidCell(tableId, tableMap, rowId, rowMap, cellId, forceDel));
    const setValidCell = (tableId, rowId, rowMap, cellId, cell)=>{
        if (!collHas(rowMap, cellId)) {
            cellIdsChanged(tableId, rowId, cellId, 1);
        }
        const oldCell = mapGet(rowMap, cellId);
        if (cell !== oldCell) {
            cellChanged(tableId, rowId, cellId, oldCell, cell);
            mapSet(rowMap, cellId, cell);
        }
    };
    const setCellIntoDefaultRow = (tableId, tableMap, rowId, cellId, validCell)=>ifNotUndefined(mapGet(tableMap, rowId), (rowMap)=>setValidCell(tableId, rowId, rowMap, cellId, validCell), ()=>setValidRow(tableId, tableMap, rowId, addDefaultsToRow({
                [cellId]: validCell
            }, tableId, rowId)));
    const setOrDelValues = (values)=>objIsEmpty(values) ? delValues() : setValues(values);
    const setValidValues = (values)=>mapMatch(valuesMap, values, (_valuesMap, valueId, value)=>setValidValue(valueId, value), (_valuesMap, valueId)=>delValidValue(valueId));
    const setValidValue = (valueId, value)=>{
        if (!collHas(valuesMap, valueId)) {
            valueIdsChanged(valueId, 1);
        }
        const oldValue = mapGet(valuesMap, valueId);
        if (value !== oldValue) {
            valueChanged(valueId, oldValue, value);
            mapSet(valuesMap, valueId, value);
        }
    };
    const getNewRowId = (tableId, reuse)=>{
        const [getId] = mapGet(tablePoolFunctions, tableId);
        let rowId;
        do {
            rowId = getId(reuse);
        }while (collHas(mapGet(tablesMap, tableId), rowId))
        return rowId;
    };
    const getOrCreateTable = (tableId)=>mapGet(tablesMap, tableId) ?? setValidTable(tableId, {});
    const delValidTable = (tableId)=>setValidTable(tableId, {});
    const delValidRow = (tableId, tableMap, rowId)=>{
        const [, releaseId] = mapGet(tablePoolFunctions, tableId);
        releaseId(rowId);
        setValidRow(tableId, tableMap, rowId, {}, true);
    };
    const delValidCell = (tableId, table, rowId, row, cellId, forceDel)=>{
        const defaultCell = mapGet(mapGet(tablesSchemaRowCache, tableId)?.[0], cellId);
        if (!isUndefined(defaultCell) && !forceDel) {
            return setValidCell(tableId, rowId, row, cellId, defaultCell);
        }
        const delCell2 = (cellId2)=>{
            cellChanged(tableId, rowId, cellId2, mapGet(row, cellId2));
            cellIdsChanged(tableId, rowId, cellId2, -1);
            mapSet(row, cellId2);
        };
        if (isUndefined(defaultCell)) {
            delCell2(cellId);
        } else {
            mapForEach(row, delCell2);
        }
        if (collIsEmpty(row)) {
            rowIdsChanged(tableId, rowId, -1);
            if (collIsEmpty(mapSet(table, rowId))) {
                tableIdsChanged(tableId, -1);
                mapSet(tablesMap, tableId);
                mapSet(tablePoolFunctions, tableId);
                mapSet(tableCellIds, tableId);
            }
        }
    };
    const delValidValue = (valueId)=>{
        const defaultValue = mapGet(valuesDefaulted, valueId);
        if (!isUndefined(defaultValue)) {
            return setValidValue(valueId, defaultValue);
        }
        valueChanged(valueId, mapGet(valuesMap, valueId));
        valueIdsChanged(valueId, -1);
        mapSet(valuesMap, valueId);
    };
    const tableIdsChanged = (tableId, addedOrRemoved)=>idsChanged(changedTableIds, tableId, addedOrRemoved);
    const rowIdsChanged = (tableId, rowId, addedOrRemoved)=>idsChanged(mapEnsure(changedRowIds, tableId, mapNew), rowId, addedOrRemoved) && mapSet(changedRowCount, tableId, mapEnsure(changedRowCount, tableId, ()=>0) + addedOrRemoved);
    const cellIdsChanged = (tableId, rowId, cellId, addedOrRemoved)=>{
        const cellIds = mapGet(tableCellIds, tableId);
        const count = mapGet(cellIds, cellId) ?? 0;
        if (count == 0 && addedOrRemoved == 1 || count == 1 && addedOrRemoved == -1) {
            idsChanged(mapEnsure(changedTableCellIds, tableId, mapNew), cellId, addedOrRemoved);
        }
        mapSet(cellIds, cellId, count != -addedOrRemoved ? count + addedOrRemoved : null);
        idsChanged(mapEnsure(mapEnsure(changedCellIds, tableId, mapNew), rowId, mapNew), cellId, addedOrRemoved);
    };
    const cellChanged = (tableId, rowId, cellId, oldCell, newCell)=>{
        mapEnsure(mapEnsure(mapEnsure(changedCells, tableId, mapNew), rowId, mapNew), cellId, ()=>[
                oldCell,
                0
            ])[1] = newCell;
        internalListeners[3]?.(tableId, rowId, cellId, newCell);
    };
    const valueIdsChanged = (valueId, addedOrRemoved)=>idsChanged(changedValueIds, valueId, addedOrRemoved);
    const valueChanged = (valueId, oldValue, newValue)=>{
        mapEnsure(changedValues, valueId, ()=>[
                oldValue,
                0
            ])[1] = newValue;
        internalListeners[4]?.(valueId, newValue);
    };
    const cellInvalid = (tableId, rowId, cellId, invalidCell, defaultedCell)=>{
        arrayPush(mapEnsure(mapEnsure(mapEnsure(invalidCells, tableId, mapNew), rowId, mapNew), cellId, ()=>[]), invalidCell);
        return defaultedCell;
    };
    const valueInvalid = (valueId, invalidValue, defaultedValue)=>{
        arrayPush(mapEnsure(invalidValues, valueId, ()=>[]), invalidValue);
        return defaultedValue;
    };
    const getCellChange = (tableId, rowId, cellId)=>ifNotUndefined(mapGet(mapGet(mapGet(changedCells, tableId), rowId), cellId), ([oldCell, newCell])=>[
                true,
                oldCell,
                newCell
            ], ()=>[
                false,
                ...pairNew(getCell(tableId, rowId, cellId))
            ]);
    const getValueChange = (valueId)=>ifNotUndefined(mapGet(changedValues, valueId), ([oldValue, newValue])=>[
                true,
                oldValue,
                newValue
            ], ()=>[
                false,
                ...pairNew(getValue(valueId))
            ]);
    const callInvalidCellListeners = (mutator)=>!collIsEmpty(invalidCells) && !collIsEmpty(invalidCellListeners[mutator]) ? collForEach(mutator ? mapClone3(invalidCells) : invalidCells, (rows, tableId)=>collForEach(rows, (cells, rowId)=>collForEach(cells, (invalidCell, cellId)=>callListeners(invalidCellListeners[mutator], [
                        tableId,
                        rowId,
                        cellId
                    ], invalidCell)))) : 0;
    const callInvalidValueListeners = (mutator)=>!collIsEmpty(invalidValues) && !collIsEmpty(invalidValueListeners[mutator]) ? collForEach(mutator ? mapClone(invalidValues) : invalidValues, (invalidValue, valueId)=>callListeners(invalidValueListeners[mutator], [
                valueId
            ], invalidValue)) : 0;
    const callIdsAndHasListenersIfChanged = (changedIds, idListeners, hasListeners, ids)=>{
        if (!collIsEmpty(changedIds)) {
            callListeners(idListeners, ids, ()=>mapToObj(changedIds));
            mapForEach(changedIds, (changedId, changed)=>callListeners(hasListeners, [
                    ...ids ?? [],
                    changedId
                ], changed == 1));
            return 1;
        }
    };
    const callTabularListenersForChanges = (mutator)=>{
        const hasTablesNow = hasTables();
        if (hasTablesNow != hadTables) {
            callListeners(hasTablesListeners[mutator], void 0, hasTablesNow);
        }
        const emptySortedRowIdListeners = collIsEmpty(sortedRowIdsListeners[mutator]);
        const emptyIdAndHasListeners = collIsEmpty(cellIdsListeners[mutator]) && collIsEmpty(hasCellListeners[mutator]) && collIsEmpty(rowIdsListeners[mutator]) && collIsEmpty(hasRowListeners[mutator]) && collIsEmpty(tableCellIdsListeners[mutator]) && collIsEmpty(hasTableCellListeners[mutator]) && collIsEmpty(rowCountListeners[mutator]) && emptySortedRowIdListeners && collIsEmpty(tableIdsListeners[mutator]) && collIsEmpty(hasTableListeners[mutator]);
        const emptyOtherListeners = collIsEmpty(cellListeners[mutator]) && collIsEmpty(rowListeners[mutator]) && collIsEmpty(tableListeners[mutator]) && collIsEmpty(tablesListeners[mutator]);
        if (!emptyIdAndHasListeners || !emptyOtherListeners) {
            const changes = mutator ? [
                mapClone(changedTableIds),
                mapClone2(changedTableCellIds),
                mapClone(changedRowCount),
                mapClone2(changedRowIds),
                mapClone3(changedCellIds),
                mapClone3(changedCells)
            ] : [
                changedTableIds,
                changedTableCellIds,
                changedRowCount,
                changedRowIds,
                changedCellIds,
                changedCells
            ];
            if (!emptyIdAndHasListeners) {
                callIdsAndHasListenersIfChanged(changes[0], tableIdsListeners[mutator], hasTableListeners[mutator]);
                collForEach(changes[1], (changedIds, tableId)=>callIdsAndHasListenersIfChanged(changedIds, tableCellIdsListeners[mutator], hasTableCellListeners[mutator], [
                        tableId
                    ]));
                collForEach(changes[2], (changedCount, tableId)=>{
                    if (changedCount != 0) {
                        callListeners(rowCountListeners[mutator], [
                            tableId
                        ], getRowCount(tableId));
                    }
                });
                const calledSortableTableIds = setNew();
                collForEach(changes[3], (changedIds, tableId)=>{
                    if (callIdsAndHasListenersIfChanged(changedIds, rowIdsListeners[mutator], hasRowListeners[mutator], [
                        tableId
                    ]) && !emptySortedRowIdListeners) {
                        callListeners(sortedRowIdsListeners[mutator], [
                            tableId,
                            null
                        ]);
                        setAdd(calledSortableTableIds, tableId);
                    }
                });
                if (!emptySortedRowIdListeners) {
                    collForEach(changes[5], (rows, tableId)=>{
                        if (!collHas(calledSortableTableIds, tableId)) {
                            const sortableCellIds = setNew();
                            collForEach(rows, (cells)=>collForEach(cells, ([oldCell, newCell], cellId)=>newCell !== oldCell ? setAdd(sortableCellIds, cellId) : collDel(cells, cellId)));
                            collForEach(sortableCellIds, (cellId)=>callListeners(sortedRowIdsListeners[mutator], [
                                    tableId,
                                    cellId
                                ]));
                        }
                    });
                }
                collForEach(changes[4], (rowCellIds, tableId)=>collForEach(rowCellIds, (changedIds, rowId)=>callIdsAndHasListenersIfChanged(changedIds, cellIdsListeners[mutator], hasCellListeners[mutator], [
                            tableId,
                            rowId
                        ])));
            }
            if (!emptyOtherListeners) {
                let tablesChanged;
                collForEach(changes[5], (rows, tableId)=>{
                    let tableChanged;
                    collForEach(rows, (cells, rowId)=>{
                        let rowChanged;
                        collForEach(cells, ([oldCell, newCell], cellId)=>{
                            if (newCell !== oldCell) {
                                callListeners(cellListeners[mutator], [
                                    tableId,
                                    rowId,
                                    cellId
                                ], newCell, oldCell, getCellChange);
                                tablesChanged = tableChanged = rowChanged = 1;
                            }
                        });
                        if (rowChanged) {
                            callListeners(rowListeners[mutator], [
                                tableId,
                                rowId
                            ], getCellChange);
                        }
                    });
                    if (tableChanged) {
                        callListeners(tableListeners[mutator], [
                            tableId
                        ], getCellChange);
                    }
                });
                if (tablesChanged) {
                    callListeners(tablesListeners[mutator], void 0, getCellChange);
                }
            }
        }
    };
    const callValuesListenersForChanges = (mutator)=>{
        const hasValuesNow = hasValues();
        if (hasValuesNow != hadValues) {
            callListeners(hasValuesListeners[mutator], void 0, hasValuesNow);
        }
        const emptyIdAndHasListeners = collIsEmpty(valueIdsListeners[mutator]) && collIsEmpty(hasValueListeners[mutator]);
        const emptyOtherListeners = collIsEmpty(valueListeners[mutator]) && collIsEmpty(valuesListeners[mutator]);
        if (!emptyIdAndHasListeners || !emptyOtherListeners) {
            const changes = mutator ? [
                mapClone(changedValueIds),
                mapClone(changedValues)
            ] : [
                changedValueIds,
                changedValues
            ];
            if (!emptyIdAndHasListeners) {
                callIdsAndHasListenersIfChanged(changes[0], valueIdsListeners[mutator], hasValueListeners[mutator]);
            }
            if (!emptyOtherListeners) {
                let valuesChanged;
                collForEach(changes[1], ([oldValue, newValue], valueId)=>{
                    if (newValue !== oldValue) {
                        callListeners(valueListeners[mutator], [
                            valueId
                        ], newValue, oldValue, getValueChange);
                        valuesChanged = 1;
                    }
                });
                if (valuesChanged) {
                    callListeners(valuesListeners[mutator], void 0, getValueChange);
                }
            }
        }
    };
    const fluentTransaction = (actions, ...args)=>{
        transaction(()=>actions(...arrayMap(args, id)));
        return store;
    };
    const getContent = ()=>[
            getTables(),
            getValues()
        ];
    const getTables = ()=>mapToObj3(tablesMap);
    const getTableIds = ()=>mapKeys(tablesMap);
    const getTable = (tableId)=>mapToObj2(mapGet(tablesMap, id(tableId)));
    const getTableCellIds = (tableId)=>mapKeys(mapGet(tableCellIds, id(tableId)));
    const getRowCount = (tableId)=>collSize(mapGet(tablesMap, id(tableId)));
    const getRowIds = (tableId)=>mapKeys(mapGet(tablesMap, id(tableId)));
    const getSortedRowIds = (tableId, cellId, descending, offset = 0, limit)=>arrayMap(slice(arraySort(mapMap(mapGet(tablesMap, id(tableId)), (row, rowId)=>[
                isUndefined(cellId) ? rowId : mapGet(row, id(cellId)),
                rowId
            ]), ([cell1], [cell2])=>defaultSorter(cell1, cell2) * (descending ? -1 : 1)), offset, isUndefined(limit) ? limit : offset + limit), ([, rowId])=>rowId);
    const getRow = (tableId, rowId)=>mapToObj(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)));
    const getCellIds = (tableId, rowId)=>mapKeys(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)));
    const getCell = (tableId, rowId, cellId)=>mapGet(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), id(cellId));
    const getValues = ()=>mapToObj(valuesMap);
    const getValueIds = ()=>mapKeys(valuesMap);
    const getValue = (valueId)=>mapGet(valuesMap, id(valueId));
    const hasTables = ()=>!collIsEmpty(tablesMap);
    const hasTable = (tableId)=>collHas(tablesMap, id(tableId));
    const hasTableCell = (tableId, cellId)=>collHas(mapGet(tableCellIds, id(tableId)), id(cellId));
    const hasRow = (tableId, rowId)=>collHas(mapGet(tablesMap, id(tableId)), id(rowId));
    const hasCell = (tableId, rowId, cellId)=>collHas(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), id(cellId));
    const hasValues = ()=>!collIsEmpty(valuesMap);
    const hasValue = (valueId)=>collHas(valuesMap, id(valueId));
    const getTablesJson = ()=>jsonStringWithMap(tablesMap);
    const getValuesJson = ()=>jsonStringWithMap(valuesMap);
    const getJson = ()=>jsonStringWithMap([
            tablesMap,
            valuesMap
        ]);
    const getTablesSchemaJson = ()=>jsonStringWithMap(tablesSchemaMap);
    const getValuesSchemaJson = ()=>jsonStringWithMap(valuesSchemaMap);
    const getSchemaJson = ()=>jsonStringWithMap([
            tablesSchemaMap,
            valuesSchemaMap
        ]);
    const setContent = (content)=>fluentTransaction(()=>{
            const content2 = isFunction(content) ? content() : content;
            if (validateContent(content2)) {
                setValidContent(content2);
            }
        });
    const setTables = (tables)=>fluentTransaction(()=>validateTables(tables) ? setValidTables(tables) : 0);
    const setTable = (tableId, table)=>fluentTransaction((tableId2)=>validateTable(table, tableId2) ? setValidTable(tableId2, table) : 0, tableId);
    const setRow = (tableId, rowId, row)=>fluentTransaction((tableId2, rowId2)=>validateRow(tableId2, rowId2, row) ? setValidRow(tableId2, getOrCreateTable(tableId2), rowId2, row) : 0, tableId, rowId);
    const addRow = (tableId, row, reuseRowIds = true)=>transaction(()=>{
            let rowId = void 0;
            if (validateRow(tableId, rowId, row)) {
                tableId = id(tableId);
                setValidRow(tableId, getOrCreateTable(tableId), rowId = getNewRowId(tableId, reuseRowIds ? 1 : 0), row);
            }
            return rowId;
        });
    const setPartialRow = (tableId, rowId, partialRow)=>fluentTransaction((tableId2, rowId2)=>{
            if (validateRow(tableId2, rowId2, partialRow, 1)) {
                const table = getOrCreateTable(tableId2);
                objMap(partialRow, (cell, cellId)=>setCellIntoDefaultRow(tableId2, table, rowId2, cellId, cell));
            }
        }, tableId, rowId);
    const setCell = (tableId, rowId, cellId, cell)=>fluentTransaction((tableId2, rowId2, cellId2)=>ifNotUndefined(getValidatedCell(tableId2, rowId2, cellId2, isFunction(cell) ? cell(getCell(tableId2, rowId2, cellId2)) : cell), (validCell)=>setCellIntoDefaultRow(tableId2, getOrCreateTable(tableId2), rowId2, cellId2, validCell)), tableId, rowId, cellId);
    const setValues = (values)=>fluentTransaction(()=>validateValues(values) ? setValidValues(values) : 0);
    const setPartialValues = (partialValues)=>fluentTransaction(()=>validateValues(partialValues, 1) ? objMap(partialValues, (value, valueId)=>setValidValue(valueId, value)) : 0);
    const setValue = (valueId, value)=>fluentTransaction((valueId2)=>ifNotUndefined(getValidatedValue(valueId2, isFunction(value) ? value(getValue(valueId2)) : value), (validValue)=>setValidValue(valueId2, validValue)), valueId);
    const applyChanges = (changes)=>fluentTransaction(()=>{
            objMap(changes[0], (table, tableId)=>isUndefined(table) ? delTable(tableId) : objMap(table, (row, rowId)=>isUndefined(row) ? delRow(tableId, rowId) : objMap(row, (cell, cellId)=>setOrDelCell(store, tableId, rowId, cellId, cell))));
            objMap(changes[1], (value, valueId)=>setOrDelValue(store, valueId, value));
        });
    const setTablesJson = (tablesJson)=>{
        try {
            setOrDelTables(jsonParse(tablesJson));
        } catch  {}
        return store;
    };
    const setValuesJson = (valuesJson)=>{
        try {
            setOrDelValues(jsonParse(valuesJson));
        } catch  {}
        return store;
    };
    const setJson = (tablesAndValuesJson)=>fluentTransaction(()=>{
            try {
                const [tables, values] = jsonParse(tablesAndValuesJson);
                setOrDelTables(tables);
                setOrDelValues(values);
            } catch  {
                setTablesJson(tablesAndValuesJson);
            }
        });
    const setTablesSchema = (tablesSchema)=>fluentTransaction(()=>{
            if (hasTablesSchema = validateTablesSchema(tablesSchema)) {
                setValidTablesSchema(tablesSchema);
                if (!collIsEmpty(tablesMap)) {
                    const tables = getTables();
                    delTables();
                    setTables(tables);
                }
            }
        });
    const setValuesSchema = (valuesSchema)=>fluentTransaction(()=>{
            if (hasValuesSchema = validateValuesSchema(valuesSchema)) {
                const values = getValues();
                delValuesSchema();
                delValues();
                hasValuesSchema = true;
                setValidValuesSchema(valuesSchema);
                setValues(values);
            }
        });
    const setSchema = (tablesSchema, valuesSchema)=>fluentTransaction(()=>{
            setTablesSchema(tablesSchema);
            setValuesSchema(valuesSchema);
        });
    const delTables = ()=>fluentTransaction(()=>setValidTables({}));
    const delTable = (tableId)=>fluentTransaction((tableId2)=>collHas(tablesMap, tableId2) ? delValidTable(tableId2) : 0, tableId);
    const delRow = (tableId, rowId)=>fluentTransaction((tableId2, rowId2)=>ifNotUndefined(mapGet(tablesMap, tableId2), (tableMap)=>collHas(tableMap, rowId2) ? delValidRow(tableId2, tableMap, rowId2) : 0), tableId, rowId);
    const delCell = (tableId, rowId, cellId, forceDel)=>fluentTransaction((tableId2, rowId2, cellId2)=>ifNotUndefined(mapGet(tablesMap, tableId2), (tableMap)=>ifNotUndefined(mapGet(tableMap, rowId2), (rowMap)=>collHas(rowMap, cellId2) ? delValidCell(tableId2, tableMap, rowId2, rowMap, cellId2, forceDel) : 0)), tableId, rowId, cellId);
    const delValues = ()=>fluentTransaction(()=>setValidValues({}));
    const delValue = (valueId)=>fluentTransaction((valueId2)=>collHas(valuesMap, valueId2) ? delValidValue(valueId2) : 0, valueId);
    const delTablesSchema = ()=>fluentTransaction(()=>{
            setValidTablesSchema({});
            hasTablesSchema = false;
        });
    const delValuesSchema = ()=>fluentTransaction(()=>{
            setValidValuesSchema({});
            hasValuesSchema = false;
        });
    const delSchema = ()=>fluentTransaction(()=>{
            delTablesSchema();
            delValuesSchema();
        });
    const transaction = (actions, doRollback)=>{
        if (transactions != -1) {
            startTransaction();
            const result = actions();
            finishTransaction(doRollback);
            return result;
        }
    };
    const startTransaction = ()=>{
        if (transactions != -1) {
            transactions++;
        }
        if (transactions == 1) {
            internalListeners[0]?.();
            callListeners(startTransactionListeners);
        }
        return store;
    };
    const getTransactionChanges = ()=>[
            mapToObj(changedCells, (table, tableId)=>mapGet(changedTableIds, tableId) === -1 ? void 0 : mapToObj(table, (row, rowId)=>mapGet(mapGet(changedRowIds, tableId), rowId) === -1 ? void 0 : mapToObj(row, ([, newCell])=>newCell, (changedCell)=>pairIsEqual(changedCell)), collIsEmpty, objIsEmpty), collIsEmpty, objIsEmpty),
            mapToObj(changedValues, ([, newValue])=>newValue, (changedValue)=>pairIsEqual(changedValue)),
            1
        ];
    const getTransactionLog = ()=>[
            !collIsEmpty(changedCells),
            !collIsEmpty(changedValues),
            mapToObj3(changedCells, pairClone, pairIsEqual),
            mapToObj3(invalidCells),
            mapToObj(changedValues, pairClone, pairIsEqual),
            mapToObj(invalidValues),
            mapToObj(changedTableIds),
            mapToObj2(changedRowIds),
            mapToObj3(changedCellIds),
            mapToObj(changedValueIds)
        ];
    const finishTransaction = (doRollback)=>{
        if (transactions > 0) {
            transactions--;
            if (transactions == 0) {
                transactions = 1;
                callInvalidCellListeners(1);
                if (!collIsEmpty(changedCells)) {
                    callTabularListenersForChanges(1);
                }
                callInvalidValueListeners(1);
                if (!collIsEmpty(changedValues)) {
                    callValuesListenersForChanges(1);
                }
                if (doRollback?.(store)) {
                    collForEach(changedCells, (table, tableId)=>collForEach(table, (row, rowId)=>collForEach(row, ([oldCell], cellId)=>setOrDelCell(store, tableId, rowId, cellId, oldCell))));
                    collClear(changedCells);
                    collForEach(changedValues, ([oldValue], valueId)=>setOrDelValue(store, valueId, oldValue));
                    collClear(changedValues);
                }
                callListeners(finishTransactionListeners[0], void 0);
                transactions = -1;
                callInvalidCellListeners(0);
                if (!collIsEmpty(changedCells)) {
                    callTabularListenersForChanges(0);
                }
                callInvalidValueListeners(0);
                if (!collIsEmpty(changedValues)) {
                    callValuesListenersForChanges(0);
                }
                internalListeners[1]?.();
                callListeners(finishTransactionListeners[1], void 0);
                internalListeners[2]?.();
                transactions = 0;
                hadTables = hasTables();
                hadValues = hasValues();
                arrayForEach([
                    changedTableIds,
                    changedTableCellIds,
                    changedRowCount,
                    changedRowIds,
                    changedCellIds,
                    changedCells,
                    invalidCells,
                    changedValueIds,
                    changedValues,
                    invalidValues
                ], collClear);
            }
        }
        return store;
    };
    const forEachTable = (tableCallback)=>collForEach(tablesMap, (tableMap, tableId)=>tableCallback(tableId, (rowCallback)=>collForEach(tableMap, (rowMap, rowId)=>rowCallback(rowId, (cellCallback)=>mapForEach(rowMap, cellCallback)))));
    const forEachTableCell = (tableId, tableCellCallback)=>mapForEach(mapGet(tableCellIds, id(tableId)), tableCellCallback);
    const forEachRow = (tableId, rowCallback)=>collForEach(mapGet(tablesMap, id(tableId)), (rowMap, rowId)=>rowCallback(rowId, (cellCallback)=>mapForEach(rowMap, cellCallback)));
    const forEachCell = (tableId, rowId, cellCallback)=>mapForEach(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), cellCallback);
    const forEachValue = (valueCallback)=>mapForEach(valuesMap, valueCallback);
    const addSortedRowIdsListener = (tableId, cellId, descending, offset, limit, listener, mutator)=>{
        let sortedRowIds = getSortedRowIds(tableId, cellId, descending, offset, limit);
        return addListener(()=>{
            const newSortedRowIds = getSortedRowIds(tableId, cellId, descending, offset, limit);
            if (!arrayIsEqual(newSortedRowIds, sortedRowIds)) {
                sortedRowIds = newSortedRowIds;
                listener(store, tableId, cellId, descending, offset, limit, sortedRowIds);
            }
        }, sortedRowIdsListeners[mutator ? 1 : 0], [
            tableId,
            cellId
        ], [
            getTableIds
        ]);
    };
    const addStartTransactionListener = (listener)=>addListener(listener, startTransactionListeners);
    const addWillFinishTransactionListener = (listener)=>addListener(listener, finishTransactionListeners[0]);
    const addDidFinishTransactionListener = (listener)=>addListener(listener, finishTransactionListeners[1]);
    const callListener = (listenerId)=>{
        callListenerImpl(listenerId);
        return store;
    };
    const delListener = (listenerId)=>{
        delListenerImpl(listenerId);
        return store;
    };
    const getListenerStats = ()=>({
            hasTables: pairCollSize2(hasTablesListeners),
            tables: pairCollSize2(tablesListeners),
            tableIds: pairCollSize2(tableIdsListeners),
            hasTable: pairCollSize2(hasTableListeners),
            table: pairCollSize2(tableListeners),
            tableCellIds: pairCollSize2(tableCellIdsListeners),
            hasTableCell: pairCollSize2(hasTableCellListeners, collSize3),
            rowCount: pairCollSize2(rowCountListeners),
            rowIds: pairCollSize2(rowIdsListeners),
            sortedRowIds: pairCollSize2(sortedRowIdsListeners),
            hasRow: pairCollSize2(hasRowListeners, collSize3),
            row: pairCollSize2(rowListeners, collSize3),
            cellIds: pairCollSize2(cellIdsListeners, collSize3),
            hasCell: pairCollSize2(hasCellListeners, collSize4),
            cell: pairCollSize2(cellListeners, collSize4),
            invalidCell: pairCollSize2(invalidCellListeners, collSize4),
            hasValues: pairCollSize2(hasValuesListeners),
            values: pairCollSize2(valuesListeners),
            valueIds: pairCollSize2(valueIdsListeners),
            hasValue: pairCollSize2(hasValueListeners),
            value: pairCollSize2(valueListeners),
            invalidValue: pairCollSize2(invalidValueListeners),
            transaction: collSize2(startTransactionListeners) + pairCollSize2(finishTransactionListeners)
        });
    const setInternalListeners = (preStartTransaction, preFinishTransaction, postFinishTransaction, cellChanged2, valueChanged2)=>internalListeners = [
            preStartTransaction,
            preFinishTransaction,
            postFinishTransaction,
            cellChanged2,
            valueChanged2
        ];
    const store = {
        getContent,
        getTables,
        getTableIds,
        getTable,
        getTableCellIds,
        getRowCount,
        getRowIds,
        getSortedRowIds,
        getRow,
        getCellIds,
        getCell,
        getValues,
        getValueIds,
        getValue,
        hasTables,
        hasTable,
        hasTableCell,
        hasRow,
        hasCell,
        hasValues,
        hasValue,
        getTablesJson,
        getValuesJson,
        getJson,
        getTablesSchemaJson,
        getValuesSchemaJson,
        getSchemaJson,
        hasTablesSchema: ()=>hasTablesSchema,
        hasValuesSchema: ()=>hasValuesSchema,
        setContent,
        setTables,
        setTable,
        setRow,
        addRow,
        setPartialRow,
        setCell,
        setValues,
        setPartialValues,
        setValue,
        applyChanges,
        setTablesJson,
        setValuesJson,
        setJson,
        setTablesSchema,
        setValuesSchema,
        setSchema,
        delTables,
        delTable,
        delRow,
        delCell,
        delValues,
        delValue,
        delTablesSchema,
        delValuesSchema,
        delSchema,
        transaction,
        startTransaction,
        getTransactionChanges,
        getTransactionLog,
        finishTransaction,
        forEachTable,
        forEachTableCell,
        forEachRow,
        forEachCell,
        forEachValue,
        addSortedRowIdsListener,
        addStartTransactionListener,
        addWillFinishTransactionListener,
        addDidFinishTransactionListener,
        callListener,
        delListener,
        getListenerStats,
        isMergeable: ()=>false,
        // only used internally by other modules
        createStore,
        addListener,
        callListeners,
        setInternalListeners
    };
    objMap({
        [HAS + TABLES]: [
            0,
            hasTablesListeners,
            [],
            ()=>[
                    hasTables()
                ]
        ],
        [TABLES]: [
            0,
            tablesListeners
        ],
        [TABLE_IDS]: [
            0,
            tableIdsListeners
        ],
        [HAS + TABLE]: [
            1,
            hasTableListeners,
            [
                getTableIds
            ],
            (ids)=>[
                    hasTable(...ids)
                ]
        ],
        [TABLE]: [
            1,
            tableListeners,
            [
                getTableIds
            ]
        ],
        [TABLE + CELL_IDS]: [
            1,
            tableCellIdsListeners,
            [
                getTableIds
            ]
        ],
        [HAS + TABLE + CELL]: [
            2,
            hasTableCellListeners,
            [
                getTableIds,
                getTableCellIds
            ],
            (ids)=>[
                    hasTableCell(...ids)
                ]
        ],
        [ROW_COUNT]: [
            1,
            rowCountListeners,
            [
                getTableIds
            ]
        ],
        [ROW_IDS]: [
            1,
            rowIdsListeners,
            [
                getTableIds
            ]
        ],
        [HAS + ROW]: [
            2,
            hasRowListeners,
            [
                getTableIds,
                getRowIds
            ],
            (ids)=>[
                    hasRow(...ids)
                ]
        ],
        [ROW]: [
            2,
            rowListeners,
            [
                getTableIds,
                getRowIds
            ]
        ],
        [CELL_IDS]: [
            2,
            cellIdsListeners,
            [
                getTableIds,
                getRowIds
            ]
        ],
        [HAS + CELL]: [
            3,
            hasCellListeners,
            [
                getTableIds,
                getRowIds,
                getCellIds
            ],
            (ids)=>[
                    hasCell(...ids)
                ]
        ],
        [CELL]: [
            3,
            cellListeners,
            [
                getTableIds,
                getRowIds,
                getCellIds
            ],
            (ids)=>pairNew(getCell(...ids))
        ],
        InvalidCell: [
            3,
            invalidCellListeners
        ],
        [HAS + VALUES]: [
            0,
            hasValuesListeners,
            [],
            ()=>[
                    hasValues()
                ]
        ],
        [VALUES]: [
            0,
            valuesListeners
        ],
        [VALUE_IDS]: [
            0,
            valueIdsListeners
        ],
        [HAS + VALUE]: [
            1,
            hasValueListeners,
            [
                getValueIds
            ],
            (ids)=>[
                    hasValue(...ids)
                ]
        ],
        [VALUE]: [
            1,
            valueListeners,
            [
                getValueIds
            ],
            (ids)=>pairNew(getValue(ids[0]))
        ],
        InvalidValue: [
            1,
            invalidValueListeners
        ]
    }, ([argumentCount, idSetNode, pathGetters, extraArgsGetter], listenable)=>{
        store[ADD + listenable + LISTENER] = (...args)=>addListener(args[argumentCount], idSetNode[args[argumentCount + 1] ? 1 : 0], argumentCount > 0 ? slice(args, 0, argumentCount) : void 0, pathGetters, extraArgsGetter);
    });
    return objFreeze(store);
};
const SHIFT36 = 2 ** 36;
const SHIFT30 = 2 ** 30;
const SHIFT24 = 2 ** 24;
const SHIFT18 = 2 ** 18;
const SHIFT12 = 2 ** 12;
const SHIFT6 = 2 ** 6;
const encodeTimeAndCounter = (logicalTime42, counter24)=>encode(logicalTime42 / SHIFT36) + encode(logicalTime42 / SHIFT30) + encode(logicalTime42 / SHIFT24) + encode(logicalTime42 / SHIFT18) + encode(logicalTime42 / SHIFT12) + encode(logicalTime42 / SHIFT6) + encode(logicalTime42) + encode(counter24 / SHIFT18) + encode(counter24 / SHIFT12) + encode(counter24 / SHIFT6) + encode(counter24);
const decodeTimeAndCounter = (hlc16)=>[
        decode(hlc16, 0) * SHIFT36 + decode(hlc16, 1) * SHIFT30 + decode(hlc16, 2) * SHIFT24 + decode(hlc16, 3) * SHIFT18 + decode(hlc16, 4) * SHIFT12 + decode(hlc16, 5) * SHIFT6 + decode(hlc16, 6),
        decode(hlc16, 7) * SHIFT18 + decode(hlc16, 8) * SHIFT12 + decode(hlc16, 9) * SHIFT6 + decode(hlc16, 10)
    ];
const getHlcFunctions = (uniqueId)=>{
    let logicalTime = 0;
    let lastCounter = -1;
    const clientPart = ifNotUndefined(uniqueId, (uniqueId2)=>{
        const clientHash30 = getHash(uniqueId2);
        return encode(clientHash30 / SHIFT24) + encode(clientHash30 / SHIFT18) + encode(clientHash30 / SHIFT12) + encode(clientHash30 / SHIFT6) + encode(clientHash30);
    }, ()=>getUniqueId(5));
    const getHlc = ()=>{
        seenHlc();
        return encodeTimeAndCounter(logicalTime, ++lastCounter) + clientPart;
    };
    const seenHlc = (hlc)=>{
        const previousLogicalTime = logicalTime;
        const [remoteLogicalTime, remoteCounter] = isUndefined(hlc) || hlc == '' ? [
            0,
            0
        ] : decodeTimeAndCounter(hlc);
        logicalTime = mathMax(previousLogicalTime, remoteLogicalTime, GLOBAL.HLC_TIME ?? Date.now());
        lastCounter = logicalTime == previousLogicalTime ? logicalTime == remoteLogicalTime ? mathMax(lastCounter, remoteCounter) : lastCounter : logicalTime == remoteLogicalTime ? remoteCounter : -1;
    };
    return [
        getHlc,
        seenHlc
    ];
};
const LISTENER_ARGS = {
    HasTable: 1,
    Table: 1,
    TableCellIds: 1,
    HasTableCell: 2,
    RowCount: 1,
    RowIds: 1,
    SortedRowIds: 5,
    HasRow: 2,
    Row: 2,
    CellIds: 2,
    HasCell: 3,
    Cell: 3,
    HasValue: 1,
    Value: 1,
    InvalidCell: 3,
    InvalidValue: 1
};
const newContentStampMap = (time = EMPTY_STRING)=>[
        stampNewMap(time),
        stampNewMap(time)
    ];
const validateMergeableContent = (mergeableContent)=>isArray(mergeableContent) && size(mergeableContent) == 2 && stampValidate(mergeableContent[0], (tableStamps)=>objValidate(tableStamps, (tableStamp)=>stampValidate(tableStamp, (rowStamps)=>objValidate(rowStamps, (rowStamp)=>stampValidate(rowStamp, (cellStamps)=>objValidate(cellStamps, (cellStamp)=>stampValidate(cellStamp, isCellOrValueOrNullOrUndefined), void 0, 1)), void 0, 1)), void 0, 1)) && stampValidate(mergeableContent[1], (values)=>objValidate(values, (value)=>stampValidate(value, isCellOrValueOrNullOrUndefined), void 0, 1));
const createMergeableStore = (uniqueId)=>{
    let listeningToRawStoreChanges = 1;
    let contentStampMap = newContentStampMap();
    let defaultingContent = 0;
    const touchedCells = mapNew();
    const touchedValues = setNew();
    const [getHlc, seenHlc] = getHlcFunctions(uniqueId);
    const store = createStore();
    const disableListeningToRawStoreChanges = (actions)=>{
        const wasListening = listeningToRawStoreChanges;
        listeningToRawStoreChanges = 0;
        actions();
        listeningToRawStoreChanges = wasListening;
        return mergeableStore;
    };
    const mergeContentOrChanges = (contentOrChanges, isContent = 0)=>{
        const tablesChanges = {};
        const valuesChanges = {};
        const [[tablesObj, incomingTablesTime = EMPTY_STRING, incomingTablesHash = 0], values] = contentOrChanges;
        const [tablesStampMap, valuesStampMap] = contentStampMap;
        const [tableStampMaps, oldTablesTime, oldTablesHash] = tablesStampMap;
        let tablesHash = isContent ? incomingTablesHash : oldTablesHash;
        let tablesTime = incomingTablesTime;
        objForEach(tablesObj, ([rowsObj, incomingTableTime = EMPTY_STRING, incomingTableHash = 0], tableId)=>{
            const tableStampMap = mapEnsure(tableStampMaps, tableId, stampNewMap);
            const [rowStampMaps, oldTableTime, oldTableHash] = tableStampMap;
            let tableHash = isContent ? incomingTableHash : oldTableHash;
            let tableTime = incomingTableTime;
            objForEach(rowsObj, (row, rowId)=>{
                const [rowTime, oldRowHash, rowHash] = mergeCellsOrValues(row, mapEnsure(rowStampMaps, rowId, stampNewMap), objEnsure(objEnsure(tablesChanges, tableId, objNew), rowId, objNew), isContent);
                tableHash ^= isContent ? 0 : (oldRowHash ? hashIdAndHash(rowId, oldRowHash) : 0) ^ hashIdAndHash(rowId, rowHash);
                tableTime = getLatestTime(tableTime, rowTime);
            });
            tableHash ^= isContent ? 0 : replaceTimeHash(oldTableTime, incomingTableTime);
            stampUpdate(tableStampMap, incomingTableTime, tableHash);
            tablesHash ^= isContent ? 0 : (oldTableHash ? hashIdAndHash(tableId, oldTableHash) : 0) ^ hashIdAndHash(tableId, tableStampMap[2]);
            tablesTime = getLatestTime(tablesTime, tableTime);
        });
        tablesHash ^= isContent ? 0 : replaceTimeHash(oldTablesTime, incomingTablesTime);
        stampUpdate(tablesStampMap, incomingTablesTime, tablesHash);
        const [valuesTime] = mergeCellsOrValues(values, valuesStampMap, valuesChanges, isContent);
        seenHlc(getLatestTime(tablesTime, valuesTime));
        return [
            tablesChanges,
            valuesChanges,
            1
        ];
    };
    const mergeCellsOrValues = (things, thingsStampMap, thingsChanges, isContent)=>{
        const [thingsObj, incomingThingsTime = EMPTY_STRING, incomingThingsHash = 0] = things;
        const [thingStampMaps, oldThingsTime, oldThingsHash] = thingsStampMap;
        let thingsTime = incomingThingsTime;
        let thingsHash = isContent ? incomingThingsHash : oldThingsHash;
        objForEach(thingsObj, ([thing, thingTime, incomingThingHash = 0], thingId)=>{
            const thingStampMap = mapEnsure(thingStampMaps, thingId, ()=>[
                    void 0,
                    EMPTY_STRING,
                    0
                ]);
            const [, oldThingTime, oldThingHash] = thingStampMap;
            if (!oldThingTime || thingTime > oldThingTime) {
                stampUpdate(thingStampMap, thingTime, isContent ? incomingThingHash : getHash(jsonStringWithMap(thing ?? null) + ':' + thingTime));
                thingStampMap[0] = thing;
                thingsChanges[thingId] = thing;
                thingsHash ^= isContent ? 0 : hashIdAndHash(thingId, oldThingHash) ^ hashIdAndHash(thingId, thingStampMap[2]);
                thingsTime = getLatestTime(thingsTime, thingTime);
            }
        });
        thingsHash ^= isContent ? 0 : replaceTimeHash(oldThingsTime, incomingThingsTime);
        stampUpdate(thingsStampMap, incomingThingsTime, thingsHash);
        return [
            thingsTime,
            oldThingsHash,
            thingsStampMap[2]
        ];
    };
    const preStartTransaction = ()=>{};
    const preFinishTransaction = ()=>{};
    const postFinishTransaction = ()=>{
        collClear(touchedCells);
        collClear(touchedValues);
    };
    const cellChanged = (tableId, rowId, cellId, newCell)=>{
        setAdd(mapEnsure(mapEnsure(touchedCells, tableId, mapNew), rowId, setNew), cellId);
        if (listeningToRawStoreChanges) {
            mergeContentOrChanges([
                [
                    {
                        [tableId]: [
                            {
                                [rowId]: [
                                    {
                                        [cellId]: [
                                            newCell,
                                            defaultingContent ? EMPTY_STRING : getHlc()
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ],
                [
                    {}
                ],
                1
            ]);
        }
    };
    const valueChanged = (valueId, newValue)=>{
        setAdd(touchedValues, valueId);
        if (listeningToRawStoreChanges) {
            mergeContentOrChanges([
                [
                    {}
                ],
                [
                    {
                        [valueId]: [
                            newValue,
                            defaultingContent ? EMPTY_STRING : getHlc()
                        ]
                    }
                ],
                1
            ]);
        }
    };
    const getMergeableContent = ()=>[
            stampMapToObjWithHash(contentStampMap[0], (tableStampMap)=>stampMapToObjWithHash(tableStampMap, (rowStampMap)=>stampMapToObjWithHash(rowStampMap))),
            stampMapToObjWithHash(contentStampMap[1])
        ];
    const getMergeableContentHashes = ()=>[
            contentStampMap[0][2],
            contentStampMap[1][2]
        ];
    const getMergeableTableHashes = ()=>mapToObj(contentStampMap[0][0], getStampHash);
    const getMergeableTableDiff = (otherTableHashes)=>{
        const newTables = stampNewObj(contentStampMap[0][1]);
        const differingTableHashes = {};
        mapForEach(contentStampMap[0][0], (tableId, [tableStampMap, tableTime, hash])=>objHas(otherTableHashes, tableId) ? hash != otherTableHashes[tableId] ? differingTableHashes[tableId] = hash : 0 : newTables[0][tableId] = stampMapToObjWithoutHash([
                tableStampMap,
                tableTime
            ], (rowStampMap)=>stampMapToObjWithoutHash(rowStampMap)));
        return [
            newTables,
            differingTableHashes
        ];
    };
    const getMergeableRowHashes = (otherTableHashes)=>{
        const rowHashes = {};
        objForEach(otherTableHashes, (otherTableHash, tableId)=>ifNotUndefined(mapGet(contentStampMap[0][0], tableId), ([rowStampMaps, , tableHash])=>tableHash != otherTableHash ? mapForEach(rowStampMaps, (rowId, [, , rowHash])=>objEnsure(rowHashes, tableId, objNew)[rowId] = rowHash) : 0));
        return rowHashes;
    };
    const getMergeableRowDiff = (otherTableRowHashes)=>{
        const newRows = stampNewObj(contentStampMap[0][1]);
        const differingRowHashes = {};
        objForEach(otherTableRowHashes, (otherRowHashes, tableId)=>mapForEach(mapGet(contentStampMap[0][0], tableId)?.[0], (rowId, [rowStampMap, rowTime, hash])=>objHas(otherRowHashes, rowId) ? hash !== otherRowHashes[rowId] ? objEnsure(differingRowHashes, tableId, objNew)[rowId] = hash : 0 : objEnsure(newRows[0], tableId, stampNewObj)[0][rowId] = stampMapToObjWithoutHash([
                    rowStampMap,
                    rowTime
                ])));
        return [
            newRows,
            differingRowHashes
        ];
    };
    const getMergeableCellHashes = (otherTableRowHashes)=>{
        const cellHashes = {};
        objForEach(otherTableRowHashes, (otherRowHashes, tableId)=>ifNotUndefined(mapGet(contentStampMap[0][0], tableId), ([rowStampMaps])=>objForEach(otherRowHashes, (otherRowHash, rowId)=>ifNotUndefined(mapGet(rowStampMaps, rowId), ([cellStampMaps, , rowHash])=>rowHash !== otherRowHash ? mapForEach(cellStampMaps, (cellId, [, , cellHash])=>objEnsure(objEnsure(cellHashes, tableId, objNew), rowId, objNew)[cellId] = cellHash) : 0))));
        return cellHashes;
    };
    const getMergeableCellDiff = (otherTableRowCellHashes)=>{
        const [[tableStampMaps, tablesTime]] = contentStampMap;
        const tablesObj = {};
        objForEach(otherTableRowCellHashes, (otherRowCellHashes, tableId)=>objForEach(otherRowCellHashes, (otherCellHashes, rowId)=>ifNotUndefined(mapGet(tableStampMaps, tableId), ([rowStampMaps, tableTime])=>ifNotUndefined(mapGet(rowStampMaps, rowId), ([cellStampMaps, rowTime])=>mapForEach(cellStampMaps, (cellId, [cell, cellTime, hash])=>hash !== otherCellHashes[cellId] ? objEnsure(objEnsure(tablesObj, tableId, ()=>stampNewObj(tableTime))[0], rowId, ()=>stampNewObj(rowTime))[0][cellId] = [
                                cell,
                                cellTime
                            ] : 0)))));
        return stampNew(tablesObj, tablesTime);
    };
    const getMergeableValueHashes = ()=>mapToObj(contentStampMap[1][0], getStampHash);
    const getMergeableValueDiff = (otherValueHashes)=>{
        const [, [valueStampMaps, valuesTime]] = contentStampMap;
        const values = mapToObj(valueStampMaps, stampClone, ([, , hash], valueId)=>hash == otherValueHashes?.[valueId]);
        return stampNew(values, valuesTime);
    };
    const setMergeableContent = (mergeableContent)=>disableListeningToRawStoreChanges(()=>validateMergeableContent(mergeableContent) ? store.transaction(()=>{
                store.delTables().delValues();
                contentStampMap = newContentStampMap();
                store.applyChanges(mergeContentOrChanges(mergeableContent, 1));
            }) : 0);
    const setDefaultContent = (content)=>{
        store.transaction(()=>{
            defaultingContent = 1;
            store.setContent(content);
            defaultingContent = 0;
        });
        return mergeableStore;
    };
    const getTransactionMergeableChanges = (withHashes = false)=>{
        const [[tableStampMaps, tablesTime, tablesHash], [valueStampMaps, valuesTime, valuesHash]] = contentStampMap;
        const newStamp = withHashes ? stampNewWithHash : stampNew;
        const tablesObj = {};
        collForEach(touchedCells, (touchedTable, tableId)=>ifNotUndefined(mapGet(tableStampMaps, tableId), ([rowStampMaps, tableTime, tableHash])=>{
                const tableObj = {};
                collForEach(touchedTable, (touchedRow, rowId)=>ifNotUndefined(mapGet(rowStampMaps, rowId), ([cellStampMaps, rowTime, rowHash])=>{
                        const rowObj = {};
                        collForEach(touchedRow, (cellId)=>{
                            ifNotUndefined(mapGet(cellStampMaps, cellId), ([cell, time, hash])=>rowObj[cellId] = newStamp(cell, time, hash));
                        });
                        tableObj[rowId] = newStamp(rowObj, rowTime, rowHash);
                    }));
                tablesObj[tableId] = newStamp(tableObj, tableTime, tableHash);
            }));
        const valuesObj = {};
        collForEach(touchedValues, (valueId)=>ifNotUndefined(mapGet(valueStampMaps, valueId), ([value, time, hash])=>valuesObj[valueId] = newStamp(value, time, hash)));
        return [
            newStamp(tablesObj, tablesTime, tablesHash),
            newStamp(valuesObj, valuesTime, valuesHash),
            1
        ];
    };
    const applyMergeableChanges = (mergeableChanges)=>disableListeningToRawStoreChanges(()=>store.applyChanges(mergeContentOrChanges(mergeableChanges)));
    const merge = (mergeableStore2)=>{
        const mergeableChanges = getMergeableContent();
        const mergeableChanges2 = mergeableStore2.getMergeableContent();
        mergeableStore2.applyMergeableChanges(mergeableChanges);
        return applyMergeableChanges(mergeableChanges2);
    };
    const mergeableStore = {
        getMergeableContent,
        getMergeableContentHashes,
        getMergeableTableHashes,
        getMergeableTableDiff,
        getMergeableRowHashes,
        getMergeableRowDiff,
        getMergeableCellHashes,
        getMergeableCellDiff,
        getMergeableValueHashes,
        getMergeableValueDiff,
        setMergeableContent,
        setDefaultContent,
        getTransactionMergeableChanges,
        applyMergeableChanges,
        merge
    };
    store.setInternalListeners(preStartTransaction, preFinishTransaction, postFinishTransaction, cellChanged, valueChanged);
    objMap(store, (method, name)=>mergeableStore[name] = strStartsWith(name, SET) || strStartsWith(name, DEL) || strStartsWith(name, 'apply') || strEndsWith(name, TRANSACTION) || name == 'call' + LISTENER ? (...args)=>{
            method(...args);
            return mergeableStore;
        } : strStartsWith(name, ADD) && strEndsWith(name, LISTENER) ? (...args)=>{
            const listenerArg = LISTENER_ARGS[slice(name, 3, -8)] ?? 0;
            const listener = args[listenerArg];
            args[listenerArg] = (_store, ...args2)=>listener(mergeableStore, ...args2);
            return method(...args);
        } : name == 'isMergeable' ? ()=>true : method);
    return objFreeze(mergeableStore);
};
;
}}),
"[project]/node_modules/.pnpm/tinybase@5.4.8_@cloudflare+workers-types@4.20250224.0_prettier@3.5.2_react-dom@19.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/persisters/persister-browser/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLocalPersister": (()=>createLocalPersister),
    "createSessionPersister": (()=>createSessionPersister)
});
const EMPTY_STRING = '';
const UNDEFINED = '\uFFFC';
const GLOBAL = globalThis;
const WINDOW = GLOBAL.window;
const isUndefined = (thing)=>thing == void 0;
const ifNotUndefined = (value, then, otherwise)=>isUndefined(value) ? otherwise?.() : then(value);
const isArray = (thing)=>Array.isArray(thing);
const size = (arrayOrString)=>arrayOrString.length;
const test = (regex, subject)=>regex.test(subject);
const errorNew = (message)=>{
    throw new Error(message);
};
const arrayForEach = (array, cb)=>array.forEach(cb);
const arrayClear = (array, to)=>array.splice(0, to);
const arrayPush = (array, ...values)=>array.push(...values);
const arrayShift = (array)=>array.shift();
const object = Object;
const getPrototypeOf = (obj)=>object.getPrototypeOf(obj);
const isObject = (obj)=>!isUndefined(obj) && ifNotUndefined(getPrototypeOf(obj), (objPrototype)=>objPrototype == object.prototype || isUndefined(getPrototypeOf(objPrototype)), /* istanbul ignore next */ ()=>true);
const objIds = object.keys;
const objFreeze = object.freeze;
const objSize = (obj)=>size(objIds(obj));
const objIsEmpty = (obj)=>isObject(obj) && objSize(obj) == 0;
const jsonString = JSON.stringify;
const jsonParse = JSON.parse;
const jsonStringWithUndefined = (obj)=>jsonString(obj, (_key, value)=>value === void 0 ? UNDEFINED : value);
const jsonParseWithUndefined = (str)=>jsonParse(str, (_key, value)=>value === UNDEFINED ? void 0 : value);
const collSize = (coll)=>coll?.size ?? 0;
const collHas = (coll, keyOrValue)=>coll?.has(keyOrValue) ?? false;
const collIsEmpty = (coll)=>isUndefined(coll) || collSize(coll) == 0;
const collForEach = (coll, cb)=>coll?.forEach(cb);
const collDel = (coll, keyOrValue)=>coll?.delete(keyOrValue);
const mapNew = (entries)=>new Map(entries);
const mapGet = (map, key)=>map?.get(key);
const mapSet = (map, key, value)=>isUndefined(value) ? (collDel(map, key), map) : map?.set(key, value);
const mapEnsure = (map, key, getDefaultValue, hadExistingValue)=>{
    if (!collHas(map, key)) {
        mapSet(map, key, getDefaultValue());
    } else {
        hadExistingValue?.(mapGet(map, key));
    }
    return mapGet(map, key);
};
const visitTree = (node, path, ensureLeaf, pruneLeaf, p = 0)=>ifNotUndefined((ensureLeaf ? mapEnsure : mapGet)(node, path[p], p > size(path) - 2 ? ensureLeaf : mapNew), (nodeOrLeaf)=>{
        if (p > size(path) - 2) {
            if (pruneLeaf?.(nodeOrLeaf)) {
                mapSet(node, path[p]);
            }
            return nodeOrLeaf;
        }
        const leaf = visitTree(nodeOrLeaf, path, ensureLeaf, pruneLeaf, p + 1);
        if (collIsEmpty(nodeOrLeaf)) {
            mapSet(node, path[p]);
        }
        return leaf;
    });
const setNew = (entryOrEntries)=>new Set(isArray(entryOrEntries) || isUndefined(entryOrEntries) ? entryOrEntries : [
        entryOrEntries
    ]);
const setAdd = (set, value)=>set?.add(value);
const INTEGER = /^\d+$/;
const getPoolFunctions = ()=>{
    const pool = [];
    let nextId = 0;
    return [
        (reuse)=>(reuse ? arrayShift(pool) : null) ?? EMPTY_STRING + nextId++,
        (id)=>{
            if (test(INTEGER, id) && size(pool) < 1e3) {
                arrayPush(pool, id);
            }
        }
    ];
};
const getWildcardedLeaves = (deepIdSet, path = [
    EMPTY_STRING
])=>{
    const leaves = [];
    const deep = (node, p)=>p == size(path) ? arrayPush(leaves, node) : path[p] === null ? collForEach(node, (node2)=>deep(node2, p + 1)) : arrayForEach([
            path[p],
            null
        ], (id)=>deep(mapGet(node, id), p + 1));
    deep(deepIdSet, 0);
    return leaves;
};
const getListenerFunctions = (getThing)=>{
    let thing;
    const [getId, releaseId] = getPoolFunctions();
    const allListeners = mapNew();
    const addListener = (listener, idSetNode, path, pathGetters = [], extraArgsGetter = ()=>[])=>{
        thing ??= getThing();
        const id = getId(1);
        mapSet(allListeners, id, [
            listener,
            idSetNode,
            path,
            pathGetters,
            extraArgsGetter
        ]);
        setAdd(visitTree(idSetNode, path ?? [
            EMPTY_STRING
        ], setNew), id);
        return id;
    };
    const callListeners = (idSetNode, ids, ...extraArgs)=>arrayForEach(getWildcardedLeaves(idSetNode, ids), (set)=>collForEach(set, (id)=>mapGet(allListeners, id)[0](thing, ...ids ?? [], ...extraArgs)));
    const delListener = (id)=>ifNotUndefined(mapGet(allListeners, id), ([, idSetNode, idOrNulls])=>{
            visitTree(idSetNode, idOrNulls ?? [
                EMPTY_STRING
            ], void 0, (idSet)=>{
                collDel(idSet, id);
                return collIsEmpty(idSet) ? 1 : 0;
            });
            mapSet(allListeners, id);
            releaseId(id);
            return idOrNulls;
        });
    const callListener = (id)=>ifNotUndefined(mapGet(allListeners, id), ([listener, , path = [], pathGetters, extraArgsGetter])=>{
            const callWithIds = (...ids)=>{
                const index = size(ids);
                if (index == size(path)) {
                    listener(thing, ...ids, ...extraArgsGetter(ids));
                } else if (isUndefined(path[index])) {
                    arrayForEach(pathGetters[index]?.(...ids) ?? [], (id2)=>callWithIds(...ids, id2));
                } else {
                    callWithIds(...ids, path[index]);
                }
            };
            callWithIds();
        });
    return [
        addListener,
        callListeners,
        delListener,
        callListener
    ];
};
const scheduleRunning = mapNew();
const scheduleActions = mapNew();
const getStoreFunctions = (persist = 1 /* StoreOnly */ , store, isSynchronizer)=>persist != 1 /* StoreOnly */  && store.isMergeable() ? [
        1,
        store.getMergeableContent,
        ()=>store.getTransactionMergeableChanges(!isSynchronizer),
        ([[changedTables], [changedValues]])=>!objIsEmpty(changedTables) || !objIsEmpty(changedValues),
        store.setDefaultContent
    ] : persist != 2 /* MergeableStoreOnly */  ? [
        0,
        store.getContent,
        store.getTransactionChanges,
        ([changedTables, changedValues])=>!objIsEmpty(changedTables) || !objIsEmpty(changedValues),
        store.setContent
    ] : errorNew('Store type not supported by this Persister');
const createCustomPersister = (store, getPersisted, setPersisted, addPersisterListener, delPersisterListener, onIgnoredError, persist, extra = {}, isSynchronizer = 0, scheduleId = [])=>{
    let status = 0; /* Idle */ 
    let loads = 0;
    let saves = 0;
    let action;
    let autoLoadHandle;
    let autoSaveListenerId;
    mapEnsure(scheduleRunning, scheduleId, ()=>0);
    mapEnsure(scheduleActions, scheduleId, ()=>[]);
    const statusListeners = mapNew();
    const [isMergeableStore, getContent, getChanges, hasChanges, setDefaultContent] = getStoreFunctions(persist, store, isSynchronizer);
    const [addListener, callListeners, delListenerImpl] = getListenerFunctions(()=>persister);
    const setStatus = (newStatus)=>{
        if (newStatus != status) {
            status = newStatus;
            callListeners(statusListeners, void 0, status);
        }
    };
    const run = async ()=>{
        /* istanbul ignore else */ if (!mapGet(scheduleRunning, scheduleId)) {
            mapSet(scheduleRunning, scheduleId, 1);
            while(!isUndefined(action = arrayShift(mapGet(scheduleActions, scheduleId)))){
                try {
                    await action();
                } catch (error) {
                    /* istanbul ignore next */ onIgnoredError?.(error);
                }
            }
            mapSet(scheduleRunning, scheduleId, 0);
        }
    };
    const setContentOrChanges = (contentOrChanges)=>{
        (isMergeableStore && isArray(contentOrChanges?.[0]) ? contentOrChanges?.[2] === 1 ? store.applyMergeableChanges : store.setMergeableContent : contentOrChanges?.[2] === 1 ? store.applyChanges : store.setContent)(contentOrChanges);
    };
    const load = async (initialContent)=>{
        /* istanbul ignore else */ if (status != 2 /* Saving */ ) {
            setStatus(1 /* Loading */ );
            loads++;
            await schedule(async ()=>{
                try {
                    const content = await getPersisted();
                    if (isArray(content)) {
                        setContentOrChanges(content);
                    } else if (initialContent) {
                        setDefaultContent(initialContent);
                    } else {
                        errorNew(`Content is not an array: ${content}`);
                    }
                } catch (error) {
                    onIgnoredError?.(error);
                    if (initialContent) {
                        setDefaultContent(initialContent);
                    }
                }
                setStatus(0 /* Idle */ );
            });
        }
        return persister;
    };
    const startAutoLoad = async (initialContent)=>{
        stopAutoLoad();
        await load(initialContent);
        try {
            autoLoadHandle = await addPersisterListener(async (content, changes)=>{
                if (changes || content) {
                    /* istanbul ignore else */ if (status != 2 /* Saving */ ) {
                        setStatus(1 /* Loading */ );
                        loads++;
                        setContentOrChanges(changes ?? content);
                        setStatus(0 /* Idle */ );
                    }
                } else {
                    await load();
                }
            });
        } catch (error) {
            /* istanbul ignore next */ onIgnoredError?.(error);
        }
        return persister;
    };
    const stopAutoLoad = ()=>{
        if (autoLoadHandle) {
            delPersisterListener(autoLoadHandle);
            autoLoadHandle = void 0;
        }
        return persister;
    };
    const isAutoLoading = ()=>!isUndefined(autoLoadHandle);
    const save = async (changes)=>{
        /* istanbul ignore else */ if (status != 1 /* Loading */ ) {
            setStatus(2 /* Saving */ );
            saves++;
            await schedule(async ()=>{
                try {
                    await setPersisted(getContent, changes);
                } catch (error) {
                    /* istanbul ignore next */ onIgnoredError?.(error);
                }
                setStatus(0 /* Idle */ );
            });
        }
        return persister;
    };
    const startAutoSave = async ()=>{
        stopAutoSave();
        await save();
        autoSaveListenerId = store.addDidFinishTransactionListener(()=>{
            const changes = getChanges();
            if (hasChanges(changes)) {
                save(changes);
            }
        });
        return persister;
    };
    const stopAutoSave = ()=>{
        if (autoSaveListenerId) {
            store.delListener(autoSaveListenerId);
            autoSaveListenerId = void 0;
        }
        return persister;
    };
    const isAutoSaving = ()=>!isUndefined(autoSaveListenerId);
    const getStatus = ()=>status;
    const addStatusListener = (listener)=>addListener(listener, statusListeners);
    const delListener = (listenerId)=>{
        delListenerImpl(listenerId);
        return store;
    };
    const schedule = async (...actions)=>{
        arrayPush(mapGet(scheduleActions, scheduleId), ...actions);
        await run();
        return persister;
    };
    const getStore = ()=>store;
    const destroy = ()=>{
        arrayClear(mapGet(scheduleActions, scheduleId));
        return stopAutoLoad().stopAutoSave();
    };
    const getStats = ()=>({
            loads,
            saves
        });
    const persister = {
        load,
        startAutoLoad,
        stopAutoLoad,
        isAutoLoading,
        save,
        startAutoSave,
        stopAutoSave,
        isAutoSaving,
        getStatus,
        addStatusListener,
        delListener,
        schedule,
        getStore,
        destroy,
        getStats,
        ...extra
    };
    return objFreeze(persister);
};
const STORAGE = 'storage';
const createStoragePersister = (store, storageName, storage, onIgnoredError)=>{
    const getPersisted = async ()=>jsonParseWithUndefined(storage.getItem(storageName));
    const setPersisted = async (getContent)=>storage.setItem(storageName, jsonStringWithUndefined(getContent()));
    const addPersisterListener = (listener)=>{
        const storageListener = (event)=>{
            if (event.storageArea === storage && event.key === storageName) {
                try {
                    listener(jsonParse(event.newValue));
                } catch  {
                    listener();
                }
            }
        };
        WINDOW.addEventListener(STORAGE, storageListener);
        return storageListener;
    };
    const delPersisterListener = (storageListener)=>WINDOW.removeEventListener(STORAGE, storageListener);
    return createCustomPersister(store, getPersisted, setPersisted, addPersisterListener, delPersisterListener, onIgnoredError, 3, // StoreOrMergeableStore,
    {
        getStorageName: ()=>storageName
    });
};
const createLocalPersister = (store, storageName, onIgnoredError)=>createStoragePersister(store, storageName, localStorage, onIgnoredError);
const createSessionPersister = (store, storageName, onIgnoredError)=>createStoragePersister(store, storageName, sessionStorage, onIgnoredError);
;
}}),
"[project]/node_modules/.pnpm/tinybase@5.4.8_@cloudflare+workers-types@4.20250224.0_prettier@3.5.2_react-dom@19.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/ui-react/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BackwardCheckpointsView": (()=>BackwardCheckpointsView),
    "CellView": (()=>CellView),
    "CheckpointView": (()=>CheckpointView),
    "CurrentCheckpointView": (()=>CurrentCheckpointView),
    "ForwardCheckpointsView": (()=>ForwardCheckpointsView),
    "IndexView": (()=>IndexView),
    "LinkedRowsView": (()=>LinkedRowsView),
    "LocalRowsView": (()=>LocalRowsView),
    "MetricView": (()=>MetricView),
    "Provider": (()=>Provider),
    "RemoteRowView": (()=>RemoteRowView),
    "ResultCellView": (()=>ResultCellView),
    "ResultRowView": (()=>ResultRowView),
    "ResultSortedTableView": (()=>ResultSortedTableView),
    "ResultTableView": (()=>ResultTableView),
    "RowView": (()=>RowView),
    "SliceView": (()=>SliceView),
    "SortedTableView": (()=>SortedTableView),
    "TableView": (()=>TableView),
    "TablesView": (()=>TablesView),
    "ValueView": (()=>ValueView),
    "ValuesView": (()=>ValuesView),
    "useAddRowCallback": (()=>useAddRowCallback),
    "useCell": (()=>useCell),
    "useCellIds": (()=>useCellIds),
    "useCellIdsListener": (()=>useCellIdsListener),
    "useCellListener": (()=>useCellListener),
    "useCheckpoint": (()=>useCheckpoint),
    "useCheckpointIds": (()=>useCheckpointIds),
    "useCheckpointIdsListener": (()=>useCheckpointIdsListener),
    "useCheckpointListener": (()=>useCheckpointListener),
    "useCheckpoints": (()=>useCheckpoints),
    "useCheckpointsIds": (()=>useCheckpointsIds),
    "useCheckpointsOrCheckpointsById": (()=>useCheckpointsOrCheckpointsById),
    "useCreateCheckpoints": (()=>useCreateCheckpoints),
    "useCreateIndexes": (()=>useCreateIndexes),
    "useCreateMergeableStore": (()=>useCreateMergeableStore),
    "useCreateMetrics": (()=>useCreateMetrics),
    "useCreatePersister": (()=>useCreatePersister),
    "useCreateQueries": (()=>useCreateQueries),
    "useCreateRelationships": (()=>useCreateRelationships),
    "useCreateStore": (()=>useCreateStore),
    "useCreateSynchronizer": (()=>useCreateSynchronizer),
    "useDelCellCallback": (()=>useDelCellCallback),
    "useDelRowCallback": (()=>useDelRowCallback),
    "useDelTableCallback": (()=>useDelTableCallback),
    "useDelTablesCallback": (()=>useDelTablesCallback),
    "useDelValueCallback": (()=>useDelValueCallback),
    "useDelValuesCallback": (()=>useDelValuesCallback),
    "useDidFinishTransactionListener": (()=>useDidFinishTransactionListener),
    "useGoBackwardCallback": (()=>useGoBackwardCallback),
    "useGoForwardCallback": (()=>useGoForwardCallback),
    "useGoToCallback": (()=>useGoToCallback),
    "useHasCell": (()=>useHasCell),
    "useHasCellListener": (()=>useHasCellListener),
    "useHasRow": (()=>useHasRow),
    "useHasRowListener": (()=>useHasRowListener),
    "useHasTable": (()=>useHasTable),
    "useHasTableCell": (()=>useHasTableCell),
    "useHasTableCellListener": (()=>useHasTableCellListener),
    "useHasTableListener": (()=>useHasTableListener),
    "useHasTables": (()=>useHasTables),
    "useHasTablesListener": (()=>useHasTablesListener),
    "useHasValue": (()=>useHasValue),
    "useHasValueListener": (()=>useHasValueListener),
    "useHasValues": (()=>useHasValues),
    "useHasValuesListener": (()=>useHasValuesListener),
    "useIndexIds": (()=>useIndexIds),
    "useIndexes": (()=>useIndexes),
    "useIndexesIds": (()=>useIndexesIds),
    "useIndexesOrIndexesById": (()=>useIndexesOrIndexesById),
    "useLinkedRowIds": (()=>useLinkedRowIds),
    "useLinkedRowIdsListener": (()=>useLinkedRowIdsListener),
    "useLocalRowIds": (()=>useLocalRowIds),
    "useLocalRowIdsListener": (()=>useLocalRowIdsListener),
    "useMetric": (()=>useMetric),
    "useMetricIds": (()=>useMetricIds),
    "useMetricListener": (()=>useMetricListener),
    "useMetrics": (()=>useMetrics),
    "useMetricsIds": (()=>useMetricsIds),
    "useMetricsOrMetricsById": (()=>useMetricsOrMetricsById),
    "usePersister": (()=>usePersister),
    "usePersisterIds": (()=>usePersisterIds),
    "usePersisterOrPersisterById": (()=>usePersisterOrPersisterById),
    "usePersisterStatus": (()=>usePersisterStatus),
    "usePersisterStatusListener": (()=>usePersisterStatusListener),
    "useProvideCheckpoints": (()=>useProvideCheckpoints),
    "useProvideIndexes": (()=>useProvideIndexes),
    "useProvideMetrics": (()=>useProvideMetrics),
    "useProvidePersister": (()=>useProvidePersister),
    "useProvideQueries": (()=>useProvideQueries),
    "useProvideRelationships": (()=>useProvideRelationships),
    "useProvideStore": (()=>useProvideStore),
    "useProvideSynchronizer": (()=>useProvideSynchronizer),
    "useQueries": (()=>useQueries),
    "useQueriesIds": (()=>useQueriesIds),
    "useQueriesOrQueriesById": (()=>useQueriesOrQueriesById),
    "useQueryIds": (()=>useQueryIds),
    "useRedoInformation": (()=>useRedoInformation),
    "useRelationshipIds": (()=>useRelationshipIds),
    "useRelationships": (()=>useRelationships),
    "useRelationshipsIds": (()=>useRelationshipsIds),
    "useRelationshipsOrRelationshipsById": (()=>useRelationshipsOrRelationshipsById),
    "useRemoteRowId": (()=>useRemoteRowId),
    "useRemoteRowIdListener": (()=>useRemoteRowIdListener),
    "useResultCell": (()=>useResultCell),
    "useResultCellIds": (()=>useResultCellIds),
    "useResultCellIdsListener": (()=>useResultCellIdsListener),
    "useResultCellListener": (()=>useResultCellListener),
    "useResultRow": (()=>useResultRow),
    "useResultRowCount": (()=>useResultRowCount),
    "useResultRowCountListener": (()=>useResultRowCountListener),
    "useResultRowIds": (()=>useResultRowIds),
    "useResultRowIdsListener": (()=>useResultRowIdsListener),
    "useResultRowListener": (()=>useResultRowListener),
    "useResultSortedRowIds": (()=>useResultSortedRowIds),
    "useResultSortedRowIdsListener": (()=>useResultSortedRowIdsListener),
    "useResultTable": (()=>useResultTable),
    "useResultTableCellIds": (()=>useResultTableCellIds),
    "useResultTableCellIdsListener": (()=>useResultTableCellIdsListener),
    "useResultTableListener": (()=>useResultTableListener),
    "useRow": (()=>useRow),
    "useRowCount": (()=>useRowCount),
    "useRowCountListener": (()=>useRowCountListener),
    "useRowIds": (()=>useRowIds),
    "useRowIdsListener": (()=>useRowIdsListener),
    "useRowListener": (()=>useRowListener),
    "useSetCellCallback": (()=>useSetCellCallback),
    "useSetCheckpointCallback": (()=>useSetCheckpointCallback),
    "useSetPartialRowCallback": (()=>useSetPartialRowCallback),
    "useSetPartialValuesCallback": (()=>useSetPartialValuesCallback),
    "useSetRowCallback": (()=>useSetRowCallback),
    "useSetTableCallback": (()=>useSetTableCallback),
    "useSetTablesCallback": (()=>useSetTablesCallback),
    "useSetValueCallback": (()=>useSetValueCallback),
    "useSetValuesCallback": (()=>useSetValuesCallback),
    "useSliceIds": (()=>useSliceIds),
    "useSliceIdsListener": (()=>useSliceIdsListener),
    "useSliceRowIds": (()=>useSliceRowIds),
    "useSliceRowIdsListener": (()=>useSliceRowIdsListener),
    "useSortedRowIds": (()=>useSortedRowIds),
    "useSortedRowIdsListener": (()=>useSortedRowIdsListener),
    "useStartTransactionListener": (()=>useStartTransactionListener),
    "useStore": (()=>useStore),
    "useStoreIds": (()=>useStoreIds),
    "useStoreOrStoreById": (()=>useStoreOrStoreById),
    "useStores": (()=>useStores),
    "useSynchronizer": (()=>useSynchronizer),
    "useSynchronizerIds": (()=>useSynchronizerIds),
    "useSynchronizerOrSynchronizerById": (()=>useSynchronizerOrSynchronizerById),
    "useSynchronizerStatus": (()=>useSynchronizerStatus),
    "useSynchronizerStatusListener": (()=>useSynchronizerStatusListener),
    "useTable": (()=>useTable),
    "useTableCellIds": (()=>useTableCellIds),
    "useTableCellIdsListener": (()=>useTableCellIdsListener),
    "useTableIds": (()=>useTableIds),
    "useTableIdsListener": (()=>useTableIdsListener),
    "useTableListener": (()=>useTableListener),
    "useTables": (()=>useTables),
    "useTablesListener": (()=>useTablesListener),
    "useUndoInformation": (()=>useUndoInformation),
    "useValue": (()=>useValue),
    "useValueIds": (()=>useValueIds),
    "useValueIdsListener": (()=>useValueIdsListener),
    "useValueListener": (()=>useValueListener),
    "useValues": (()=>useValues),
    "useValuesListener": (()=>useValuesListener),
    "useWillFinishTransactionListener": (()=>useWillFinishTransactionListener)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$2$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.2.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
const getTypeOf = (thing)=>typeof thing;
const TINYBASE = 'tinybase';
const EMPTY_STRING = '';
const STRING = getTypeOf(EMPTY_STRING);
const FUNCTION = getTypeOf(getTypeOf);
const LISTENER = 'Listener';
const RESULT = 'Result';
const GET = 'get';
const SET = 'set';
const ADD = 'add';
const DEL = 'del';
const HAS = 'Has';
const _HAS = 'has';
const IDS = 'Ids';
const TABLE = 'Table';
const TABLES = TABLE + 's';
const TABLE_IDS = TABLE + IDS;
const ROW = 'Row';
const ROW_COUNT = ROW + 'Count';
const ROW_IDS = ROW + IDS;
const SORTED_ROW_IDS = 'Sorted' + ROW + IDS;
const CELL = 'Cell';
const CELL_IDS = CELL + IDS;
const VALUE = 'Value';
const VALUES = VALUE + 's';
const VALUE_IDS = VALUE + IDS;
const TRANSACTION = 'Transaction';
const PARTIAL = 'Partial';
const FINISH = 'Finish';
const STATUS = 'Status';
const METRIC = 'Metric';
const INDEX = 'Index';
const SLICE = 'Slice';
const RELATIONSHIP = 'Relationship';
const REMOTE_ROW_ID = 'Remote' + ROW + 'Id';
const LOCAL = 'Local';
const LINKED = 'Linked';
const QUERY = 'Query';
const CHECKPOINT = 'Checkpoint';
const GLOBAL = globalThis;
const isUndefined = (thing)=>thing == void 0;
const ifNotUndefined = (value, then, otherwise)=>isUndefined(value) ? otherwise?.() : then(value);
const isString = (thing)=>getTypeOf(thing) == STRING;
const isFunction = (thing)=>getTypeOf(thing) == FUNCTION;
const isArray = (thing)=>Array.isArray(thing);
const size = (arrayOrString)=>arrayOrString.length;
const getUndefined = ()=>void 0;
const arrayNew = (size2, cb)=>arrayMap(new Array(size2).fill(0), (_, index)=>cb(index));
const arrayEvery = (array, cb)=>array.every(cb);
const arrayIsEqual = (array1, array2)=>size(array1) === size(array2) && arrayEvery(array1, (value1, index)=>array2[index] === value1);
const arrayMap = (array, cb)=>array.map(cb);
const arrayIsEmpty = (array)=>size(array) == 0;
const arrayFilter = (array, cb)=>array.filter(cb);
const arrayWith = (array, index, value)=>array.with(index, value);
const { PureComponent, Fragment, createContext, createElement, useCallback, useContext, useEffect, useLayoutEffect, useMemo, useRef, useState, useSyncExternalStore } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$2$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
const getProps = (getProps2, ...ids)=>isUndefined(getProps2) ? {} : getProps2(...ids);
const getRelationshipsStoreTableIds = (relationships, relationshipId)=>[
        relationships,
        relationships?.getStore(),
        relationships?.getLocalTableId(relationshipId),
        relationships?.getRemoteTableId(relationshipId)
    ];
const getIndexStoreTableId = (indexes, indexId)=>[
        indexes,
        indexes?.getStore(),
        indexes?.getTableId(indexId)
    ];
const object = Object;
const getPrototypeOf = (obj)=>object.getPrototypeOf(obj);
const objEntries = object.entries;
const isObject = (obj)=>!isUndefined(obj) && ifNotUndefined(getPrototypeOf(obj), (objPrototype)=>objPrototype == object.prototype || isUndefined(getPrototypeOf(objPrototype)), /* istanbul ignore next */ ()=>true);
const objIds = object.keys;
const objGet = (obj, id)=>ifNotUndefined(obj, (obj2)=>obj2[id]);
const objHas = (obj, id)=>id in obj;
const objDel = (obj, id)=>{
    delete obj[id];
    return obj;
};
const objSize = (obj)=>size(objIds(obj));
const objIsEqual = (obj1, obj2)=>{
    const entries1 = objEntries(obj1);
    return size(entries1) === objSize(obj2) && arrayEvery(entries1, ([index, value1])=>isObject(value1) ? isObject(obj2[index]) ? objIsEqual(obj2[index], value1) : false : obj2[index] === value1);
};
const objEnsure = (obj, id, getDefaultValue)=>{
    if (!objHas(obj, id)) {
        obj[id] = getDefaultValue();
    }
    return obj[id];
};
const Context = objEnsure(GLOBAL, TINYBASE + '_uirc', ()=>createContext([]));
const useThing = (id, offset)=>{
    const contextValue = useContext(Context);
    return isUndefined(id) ? contextValue[offset * 2] : isString(id) ? objGet(contextValue[offset * 2 + 1] ?? {}, id) : id;
};
const useThings = (offset)=>({
        ...useContext(Context)[offset * 2 + 1]
    });
const useThingOrThingById = (thingOrThingId, offset)=>{
    const thing = useThing(thingOrThingId, offset);
    return isUndefined(thingOrThingId) || isString(thingOrThingId) ? thing : thingOrThingId;
};
const useProvideThing = (thingId, thing, offset)=>{
    const { 16: addExtraThingById, 17: delExtraThingById } = useContext(Context);
    useEffect({
        "useProvideThing.useEffect": ()=>{
            addExtraThingById?.(offset, thingId, thing);
            return ({
                "useProvideThing.useEffect": ()=>delExtraThingById?.(offset, thingId)
            })["useProvideThing.useEffect"];
        }
    }["useProvideThing.useEffect"], [
        addExtraThingById,
        thingId,
        thing,
        offset,
        delExtraThingById
    ]);
};
const useThingIds = (offset)=>objIds(useContext(Context)[offset * 2 + 1] ?? {});
const useStoreIds = ()=>useThingIds(0 /* Store */ );
const useStore = (id)=>useThing(id, 0 /* Store */ );
const useStores = ()=>useThings(0 /* Store */ );
const useStoreOrStoreById = (storeOrStoreId)=>useThingOrThingById(storeOrStoreId, 0 /* Store */ );
const useProvideStore = (storeId, store)=>useProvideThing(storeId, store, 0 /* Store */ );
const useMetricsIds = ()=>useThingIds(1 /* Metrics */ );
const useMetrics = (id)=>useThing(id, 1 /* Metrics */ );
const useMetricsOrMetricsById = (metricsOrMetricsId)=>useThingOrThingById(metricsOrMetricsId, 1 /* Metrics */ );
const useProvideMetrics = (metricsId, metrics)=>useProvideThing(metricsId, metrics, 1 /* Metrics */ );
const useIndexesIds = ()=>useThingIds(2 /* Indexes */ );
const useIndexes = (id)=>useThing(id, 2 /* Indexes */ );
const useIndexesOrIndexesById = (indexesOrIndexesId)=>useThingOrThingById(indexesOrIndexesId, 2 /* Indexes */ );
const useProvideIndexes = (indexesId, indexes)=>useProvideThing(indexesId, indexes, 2 /* Indexes */ );
const useRelationshipsIds = ()=>useThingIds(3 /* Relationships */ );
const useRelationships = (id)=>useThing(id, 3 /* Relationships */ );
const useRelationshipsOrRelationshipsById = (relationshipsOrRelationshipsId)=>useThingOrThingById(relationshipsOrRelationshipsId, 3 /* Relationships */ );
const useProvideRelationships = (relationshipsId, relationships)=>useProvideThing(relationshipsId, relationships, 3 /* Relationships */ );
const useQueriesIds = ()=>useThingIds(4 /* Queries */ );
const useQueries = (id)=>useThing(id, 4 /* Queries */ );
const useQueriesOrQueriesById = (queriesOrQueriesId)=>useThingOrThingById(queriesOrQueriesId, 4 /* Queries */ );
const useProvideQueries = (queriesId, queries)=>useProvideThing(queriesId, queries, 4 /* Queries */ );
const useCheckpointsIds = ()=>useThingIds(5 /* Checkpoints */ );
const useCheckpoints = (id)=>useThing(id, 5 /* Checkpoints */ );
const useCheckpointsOrCheckpointsById = (checkpointsOrCheckpointsId)=>useThingOrThingById(checkpointsOrCheckpointsId, 5 /* Checkpoints */ );
const useProvideCheckpoints = (checkpointsId, checkpoints)=>useProvideThing(checkpointsId, checkpoints, 5 /* Checkpoints */ );
const usePersisterIds = ()=>useThingIds(6 /* Persister */ );
const usePersister = (id)=>useThing(id, 6 /* Persister */ );
const usePersisterOrPersisterById = (persisterOrPersisterId)=>useThingOrThingById(persisterOrPersisterId, 6 /* Persister */ );
const useProvidePersister = (persisterId, persister)=>useProvideThing(persisterId, persister, 6 /* Persister */ );
const useSynchronizerIds = ()=>useThingIds(7 /* Synchronizer */ );
const useSynchronizer = (id)=>useThing(id, 7 /* Synchronizer */ );
const useSynchronizerOrSynchronizerById = (synchronizerOrSynchronizerId)=>useThingOrThingById(synchronizerOrSynchronizerId, 7 /* Synchronizer */ );
const useProvideSynchronizer = (persisterId, persister)=>useProvideThing(persisterId, persister, 7 /* Synchronizer */ );
const EMPTY_ARRAY = [];
const DEFAULTS = [
    {},
    [],
    [
        EMPTY_ARRAY,
        void 0,
        EMPTY_ARRAY
    ],
    void 0,
    false,
    0
];
const IS_EQUALS = [
    objIsEqual,
    arrayIsEqual,
    ([backwardIds1, currentId1, forwardIds1], [backwardIds2, currentId2, forwardIds2])=>currentId1 === currentId2 && arrayIsEqual(backwardIds1, backwardIds2) && arrayIsEqual(forwardIds1, forwardIds2)
];
const isEqual = (thing1, thing2)=>thing1 === thing2;
const useCreate = (store, create, createDeps = EMPTY_ARRAY)=>{
    const [, rerender] = useState();
    const [thing, setThing] = useState();
    useEffect({
        "useCreate.useEffect": ()=>{
            const newThing = store ? create(store) : void 0;
            setThing(newThing);
            rerender([]);
            return newThing?.destroy;
        }
    }["useCreate.useEffect"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        store,
        ...createDeps
    ]);
    return thing;
};
const addAndDelListener = (thing, listenable, ...args)=>{
    const listenerId = thing?.[ADD + listenable + LISTENER]?.(...args);
    return ()=>thing?.delListener(listenerId);
};
const useListenable = (listenable, thing, returnType, args = EMPTY_ARRAY)=>{
    const lastResult = useRef(DEFAULTS[returnType]);
    const getResult = useCallback({
        "useListenable.useCallback[getResult]": ()=>{
            const nextResult = thing?.[(returnType == 4 /* Boolean */  ? _HAS : GET) + listenable]?.(...args) ?? DEFAULTS[returnType];
            return !(IS_EQUALS[returnType] ?? isEqual)(nextResult, lastResult.current) ? lastResult.current = nextResult : lastResult.current;
        }
    }["useListenable.useCallback[getResult]"], /* eslint-disable-next-line react-hooks/exhaustive-deps */ [
        thing,
        returnType,
        listenable,
        ...args
    ]);
    const subscribe = useCallback({
        "useListenable.useCallback[subscribe]": (listener)=>addAndDelListener(thing, (returnType == 4 /* Boolean */  ? HAS : EMPTY_STRING) + listenable, ...args, listener)
    }["useListenable.useCallback[subscribe]"], /* eslint-disable-next-line react-hooks/exhaustive-deps */ [
        thing,
        returnType,
        listenable,
        ...args
    ]);
    return useSyncExternalStore(subscribe, getResult, getResult);
};
const useListener = (listenable, thing, listener, listenerDeps = EMPTY_ARRAY, preArgs = EMPTY_ARRAY, ...postArgs)=>useLayoutEffect({
        "useListener.useLayoutEffect": ()=>addAndDelListener(thing, listenable, ...preArgs, listener, ...postArgs)
    }["useListener.useLayoutEffect"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        thing,
        listenable,
        ...preArgs,
        ...listenerDeps,
        ...postArgs
    ]);
const useSetCallback = (storeOrStoreId, settable, get, getDeps = EMPTY_ARRAY, then = getUndefined, thenDeps = EMPTY_ARRAY, ...args)=>{
    const store = useStoreOrStoreById(storeOrStoreId);
    return useCallback({
        "useSetCallback.useCallback": (parameter)=>ifNotUndefined(store, {
                "useSetCallback.useCallback": (store2)=>ifNotUndefined(get(parameter, store2), {
                        "useSetCallback.useCallback": (thing)=>then(store2[SET + settable](...argsOrGetArgs(args, store2, parameter), thing), thing)
                    }["useSetCallback.useCallback"])
            }["useSetCallback.useCallback"])
    }["useSetCallback.useCallback"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        store,
        settable,
        ...getDeps,
        ...thenDeps,
        ...nonFunctionDeps(args)
    ]);
};
const argsOrGetArgs = (args, store, parameter)=>arrayMap(args, (arg)=>isFunction(arg) ? arg(parameter, store) : arg);
const nonFunctionDeps = (args)=>arrayFilter(args, (arg)=>!isFunction(arg));
const useDel = (storeOrStoreId, deletable, then = getUndefined, thenDeps = EMPTY_ARRAY, ...args)=>{
    const store = useStoreOrStoreById(storeOrStoreId);
    return useCallback({
        "useDel.useCallback": (parameter)=>then(store?.[DEL + deletable](...argsOrGetArgs(args, store, parameter)))
    }["useDel.useCallback"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        store,
        deletable,
        ...thenDeps,
        ...nonFunctionDeps(args)
    ]);
};
const useCheckpointAction = (checkpointsOrCheckpointsId, action, arg)=>{
    const checkpoints = useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId);
    return useCallback({
        "useCheckpointAction.useCallback": ()=>checkpoints?.[action](arg)
    }["useCheckpointAction.useCallback"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        checkpoints,
        action,
        arg
    ]);
};
const useCreateStore = (create, createDeps = EMPTY_ARRAY)=>useMemo(create, createDeps);
const useCreateMergeableStore = (create, createDeps = EMPTY_ARRAY)=>useMemo(create, createDeps);
const useHasTables = (storeOrStoreId)=>useListenable(TABLES, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */ , []);
const useTables = (storeOrStoreId)=>useListenable(TABLES, useStoreOrStoreById(storeOrStoreId), 0 /* Object */ );
const useTableIds = (storeOrStoreId)=>useListenable(TABLE_IDS, useStoreOrStoreById(storeOrStoreId), 1 /* Array */ );
const useHasTable = (tableId, storeOrStoreId)=>useListenable(TABLE, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */ , [
        tableId
    ]);
const useTable = (tableId, storeOrStoreId)=>useListenable(TABLE, useStoreOrStoreById(storeOrStoreId), 0 /* Object */ , [
        tableId
    ]);
const useTableCellIds = (tableId, storeOrStoreId)=>useListenable(TABLE + CELL_IDS, useStoreOrStoreById(storeOrStoreId), 1 /* Array */ , [
        tableId
    ]);
const useHasTableCell = (tableId, cellId, storeOrStoreId)=>useListenable(TABLE + CELL, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */ , [
        tableId,
        cellId
    ]);
const useRowCount = (tableId, storeOrStoreId)=>useListenable(ROW_COUNT, useStoreOrStoreById(storeOrStoreId), 5 /* Number */ , [
        tableId
    ]);
const useRowIds = (tableId, storeOrStoreId)=>useListenable(ROW_IDS, useStoreOrStoreById(storeOrStoreId), 1 /* Array */ , [
        tableId
    ]);
const useSortedRowIds = (tableId, cellId, descending, offset = 0, limit, storeOrStoreId)=>useListenable(SORTED_ROW_IDS, useStoreOrStoreById(storeOrStoreId), 1 /* Array */ , [
        tableId,
        cellId,
        descending,
        offset,
        limit
    ]);
const useHasRow = (tableId, rowId, storeOrStoreId)=>useListenable(ROW, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */ , [
        tableId,
        rowId
    ]);
const useRow = (tableId, rowId, storeOrStoreId)=>useListenable(ROW, useStoreOrStoreById(storeOrStoreId), 0 /* Object */ , [
        tableId,
        rowId
    ]);
const useCellIds = (tableId, rowId, storeOrStoreId)=>useListenable(CELL_IDS, useStoreOrStoreById(storeOrStoreId), 1 /* Array */ , [
        tableId,
        rowId
    ]);
const useHasCell = (tableId, rowId, cellId, storeOrStoreId)=>useListenable(CELL, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */ , [
        tableId,
        rowId,
        cellId
    ]);
const useCell = (tableId, rowId, cellId, storeOrStoreId)=>useListenable(CELL, useStoreOrStoreById(storeOrStoreId), 3 /* CellOrValue */ , [
        tableId,
        rowId,
        cellId
    ]);
const useHasValues = (storeOrStoreId)=>useListenable(VALUES, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */ , []);
const useValues = (storeOrStoreId)=>useListenable(VALUES, useStoreOrStoreById(storeOrStoreId), 0 /* Object */ );
const useValueIds = (storeOrStoreId)=>useListenable(VALUE_IDS, useStoreOrStoreById(storeOrStoreId), 1 /* Array */ );
const useHasValue = (valueId, storeOrStoreId)=>useListenable(VALUE, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */ , [
        valueId
    ]);
const useValue = (valueId, storeOrStoreId)=>useListenable(VALUE, useStoreOrStoreById(storeOrStoreId), 3 /* CellOrValue */ , [
        valueId
    ]);
const useSetTablesCallback = (getTables, getTablesDeps, storeOrStoreId, then, thenDeps)=>useSetCallback(storeOrStoreId, TABLES, getTables, getTablesDeps, then, thenDeps);
const useSetTableCallback = (tableId, getTable, getTableDeps, storeOrStoreId, then, thenDeps)=>useSetCallback(storeOrStoreId, TABLE, getTable, getTableDeps, then, thenDeps, tableId);
const useSetRowCallback = (tableId, rowId, getRow, getRowDeps, storeOrStoreId, then, thenDeps)=>useSetCallback(storeOrStoreId, ROW, getRow, getRowDeps, then, thenDeps, tableId, rowId);
const useAddRowCallback = (tableId, getRow, getRowDeps = EMPTY_ARRAY, storeOrStoreId, then = getUndefined, thenDeps = EMPTY_ARRAY, reuseRowIds = true)=>{
    const store = useStoreOrStoreById(storeOrStoreId);
    return useCallback({
        "useAddRowCallback.useCallback": (parameter)=>ifNotUndefined(store, {
                "useAddRowCallback.useCallback": (store2)=>ifNotUndefined(getRow(parameter, store2), {
                        "useAddRowCallback.useCallback": (row)=>then(store2.addRow(isFunction(tableId) ? tableId(parameter, store2) : tableId, row, reuseRowIds), store2, row)
                    }["useAddRowCallback.useCallback"])
            }["useAddRowCallback.useCallback"])
    }["useAddRowCallback.useCallback"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        store,
        tableId,
        ...getRowDeps,
        ...thenDeps,
        reuseRowIds
    ]);
};
const useSetPartialRowCallback = (tableId, rowId, getPartialRow, getPartialRowDeps, storeOrStoreId, then, thenDeps)=>useSetCallback(storeOrStoreId, PARTIAL + ROW, getPartialRow, getPartialRowDeps, then, thenDeps, tableId, rowId);
const useSetCellCallback = (tableId, rowId, cellId, getCell, getCellDeps, storeOrStoreId, then, thenDeps)=>useSetCallback(storeOrStoreId, CELL, getCell, getCellDeps, then, thenDeps, tableId, rowId, cellId);
const useSetValuesCallback = (getValues, getValuesDeps, storeOrStoreId, then, thenDeps)=>useSetCallback(storeOrStoreId, VALUES, getValues, getValuesDeps, then, thenDeps);
const useSetPartialValuesCallback = (getPartialValues, getPartialValuesDeps, storeOrStoreId, then, thenDeps)=>useSetCallback(storeOrStoreId, PARTIAL + VALUES, getPartialValues, getPartialValuesDeps, then, thenDeps);
const useSetValueCallback = (valueId, getValue, getValueDeps, storeOrStoreId, then, thenDeps)=>useSetCallback(storeOrStoreId, VALUE, getValue, getValueDeps, then, thenDeps, valueId);
const useDelTablesCallback = (storeOrStoreId, then, thenDeps)=>useDel(storeOrStoreId, TABLES, then, thenDeps);
const useDelTableCallback = (tableId, storeOrStoreId, then, thenDeps)=>useDel(storeOrStoreId, TABLE, then, thenDeps, tableId);
const useDelRowCallback = (tableId, rowId, storeOrStoreId, then, thenDeps)=>useDel(storeOrStoreId, ROW, then, thenDeps, tableId, rowId);
const useDelCellCallback = (tableId, rowId, cellId, forceDel, storeOrStoreId, then, thenDeps)=>useDel(storeOrStoreId, CELL, then, thenDeps, tableId, rowId, cellId, forceDel);
const useDelValuesCallback = (storeOrStoreId, then, thenDeps)=>useDel(storeOrStoreId, VALUES, then, thenDeps);
const useDelValueCallback = (valueId, storeOrStoreId, then, thenDeps)=>useDel(storeOrStoreId, VALUE, then, thenDeps, valueId);
const useHasTablesListener = (listener, listenerDeps, mutator, storeOrStoreId)=>useListener(HAS + TABLES, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [], mutator);
const useTablesListener = (listener, listenerDeps, mutator, storeOrStoreId)=>useListener(TABLES, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, EMPTY_ARRAY, mutator);
const useTableIdsListener = (listener, listenerDeps, mutator, storeOrStoreId)=>useListener(TABLE_IDS, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, EMPTY_ARRAY, mutator);
const useHasTableListener = (tableId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(HAS + TABLE, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId
    ], mutator);
const useTableListener = (tableId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(TABLE, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId
    ], mutator);
const useTableCellIdsListener = (tableId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(TABLE + CELL_IDS, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId
    ], mutator);
const useHasTableCellListener = (tableId, cellId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(HAS + TABLE + CELL, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId,
        cellId
    ], mutator);
const useRowCountListener = (tableId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(ROW_COUNT, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId
    ], mutator);
const useRowIdsListener = (tableId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(ROW_IDS, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId
    ], mutator);
const useSortedRowIdsListener = (tableId, cellId, descending, offset, limit, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(SORTED_ROW_IDS, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId,
        cellId,
        descending,
        offset,
        limit
    ], mutator);
const useHasRowListener = (tableId, rowId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(HAS + ROW, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId,
        rowId
    ], mutator);
const useRowListener = (tableId, rowId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(ROW, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId,
        rowId
    ], mutator);
const useCellIdsListener = (tableId, rowId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(CELL_IDS, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId,
        rowId
    ], mutator);
const useHasCellListener = (tableId, rowId, cellId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(HAS + CELL, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId,
        rowId,
        cellId
    ], mutator);
const useCellListener = (tableId, rowId, cellId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(CELL, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        tableId,
        rowId,
        cellId
    ], mutator);
const useHasValuesListener = (listener, listenerDeps, mutator, storeOrStoreId)=>useListener(HAS + VALUES, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [], mutator);
const useValuesListener = (listener, listenerDeps, mutator, storeOrStoreId)=>useListener(VALUES, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, EMPTY_ARRAY, mutator);
const useValueIdsListener = (listener, listenerDeps, mutator, storeOrStoreId)=>useListener(VALUE_IDS, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, EMPTY_ARRAY, mutator);
const useHasValueListener = (valueId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(HAS + VALUE, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        valueId
    ], mutator);
const useValueListener = (valueId, listener, listenerDeps, mutator, storeOrStoreId)=>useListener(VALUE, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps, [
        valueId
    ], mutator);
const useStartTransactionListener = (listener, listenerDeps, storeOrStoreId)=>useListener('Start' + TRANSACTION, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps);
const useWillFinishTransactionListener = (listener, listenerDeps, storeOrStoreId)=>useListener('Will' + FINISH + TRANSACTION, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps);
const useDidFinishTransactionListener = (listener, listenerDeps, storeOrStoreId)=>useListener('Did' + FINISH + TRANSACTION, useStoreOrStoreById(storeOrStoreId), listener, listenerDeps);
const useCreateMetrics = (store, create, createDeps)=>useCreate(store, create, createDeps);
const useMetricIds = (metricsOrMetricsId)=>useListenable(METRIC + IDS, useMetricsOrMetricsById(metricsOrMetricsId), 1 /* Array */ );
const useMetric = (metricId, metricsOrMetricsId)=>useListenable(METRIC, useMetricsOrMetricsById(metricsOrMetricsId), 3 /* CellOrValue */ , [
        metricId
    ]);
const useMetricListener = (metricId, listener, listenerDeps, metricsOrMetricsId)=>useListener(METRIC, useMetricsOrMetricsById(metricsOrMetricsId), listener, listenerDeps, [
        metricId
    ]);
const useCreateIndexes = (store, create, createDeps)=>useCreate(store, create, createDeps);
const useSliceIds = (indexId, indexesOrIndexesId)=>useListenable(SLICE + IDS, useIndexesOrIndexesById(indexesOrIndexesId), 1 /* Array */ , [
        indexId
    ]);
const useIndexIds = (indexesOrIndexesId)=>useListenable(INDEX + IDS, useIndexesOrIndexesById(indexesOrIndexesId), 1 /* Array */ );
const useSliceRowIds = (indexId, sliceId, indexesOrIndexesId)=>useListenable(SLICE + ROW_IDS, useIndexesOrIndexesById(indexesOrIndexesId), 1 /* Array */ , [
        indexId,
        sliceId
    ]);
const useSliceIdsListener = (indexId, listener, listenerDeps, indexesOrIndexesId)=>useListener(SLICE + IDS, useIndexesOrIndexesById(indexesOrIndexesId), listener, listenerDeps, [
        indexId
    ]);
const useSliceRowIdsListener = (indexId, sliceId, listener, listenerDeps, indexesOrIndexesId)=>useListener(SLICE + ROW_IDS, useIndexesOrIndexesById(indexesOrIndexesId), listener, listenerDeps, [
        indexId,
        sliceId
    ]);
const useCreateRelationships = (store, create, createDeps)=>useCreate(store, create, createDeps);
const useRelationshipIds = (relationshipsOrRelationshipsId)=>useListenable(RELATIONSHIP + IDS, useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId), 1 /* Array */ );
const useRemoteRowId = (relationshipId, localRowId, relationshipsOrRelationshipsId)=>useListenable(REMOTE_ROW_ID, useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId), 3 /* CellOrValue */ , [
        relationshipId,
        localRowId
    ]);
const useLocalRowIds = (relationshipId, remoteRowId, relationshipsOrRelationshipsId)=>useListenable(LOCAL + ROW_IDS, useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId), 1 /* Array */ , [
        relationshipId,
        remoteRowId
    ]);
const useLinkedRowIds = (relationshipId, firstRowId, relationshipsOrRelationshipsId)=>useListenable(LINKED + ROW_IDS, useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId), 1 /* Array */ , [
        relationshipId,
        firstRowId
    ]);
const useRemoteRowIdListener = (relationshipId, localRowId, listener, listenerDeps, relationshipsOrRelationshipsId)=>useListener(REMOTE_ROW_ID, useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId), listener, listenerDeps, [
        relationshipId,
        localRowId
    ]);
const useLocalRowIdsListener = (relationshipId, remoteRowId, listener, listenerDeps, relationshipsOrRelationshipsId)=>useListener(LOCAL + ROW_IDS, useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId), listener, listenerDeps, [
        relationshipId,
        remoteRowId
    ]);
const useLinkedRowIdsListener = (relationshipId, firstRowId, listener, listenerDeps, relationshipsOrRelationshipsId)=>useListener(LINKED + ROW_IDS, useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId), listener, listenerDeps, [
        relationshipId,
        firstRowId
    ]);
const useCreateQueries = (store, create, createDeps)=>useCreate(store, create, createDeps);
const useQueryIds = (queriesOrQueriesId)=>useListenable(QUERY + IDS, useQueriesOrQueriesById(queriesOrQueriesId), 1 /* Array */ );
const useResultTable = (queryId, queriesOrQueriesId)=>useListenable(RESULT + TABLE, useQueriesOrQueriesById(queriesOrQueriesId), 0 /* Object */ , [
        queryId
    ]);
const useResultTableCellIds = (queryId, queriesOrQueriesId)=>useListenable(RESULT + TABLE + CELL_IDS, useQueriesOrQueriesById(queriesOrQueriesId), 1 /* Array */ , [
        queryId
    ]);
const useResultRowCount = (queryId, queriesOrQueriesId)=>useListenable(RESULT + ROW_COUNT, useQueriesOrQueriesById(queriesOrQueriesId), 5 /* Number */ , [
        queryId
    ]);
const useResultRowIds = (queryId, queriesOrQueriesId)=>useListenable(RESULT + ROW_IDS, useQueriesOrQueriesById(queriesOrQueriesId), 1 /* Array */ , [
        queryId
    ]);
const useResultSortedRowIds = (queryId, cellId, descending, offset = 0, limit, queriesOrQueriesId)=>useListenable(RESULT + SORTED_ROW_IDS, useQueriesOrQueriesById(queriesOrQueriesId), 1 /* Array */ , [
        queryId,
        cellId,
        descending,
        offset,
        limit
    ]);
const useResultRow = (queryId, rowId, queriesOrQueriesId)=>useListenable(RESULT + ROW, useQueriesOrQueriesById(queriesOrQueriesId), 0 /* Object */ , [
        queryId,
        rowId
    ]);
const useResultCellIds = (queryId, rowId, queriesOrQueriesId)=>useListenable(RESULT + CELL_IDS, useQueriesOrQueriesById(queriesOrQueriesId), 1 /* Array */ , [
        queryId,
        rowId
    ]);
const useResultCell = (queryId, rowId, cellId, queriesOrQueriesId)=>useListenable(RESULT + CELL, useQueriesOrQueriesById(queriesOrQueriesId), 3 /* CellOrValue */ , [
        queryId,
        rowId,
        cellId
    ]);
const useResultTableListener = (queryId, listener, listenerDeps, queriesOrQueriesId)=>useListener(RESULT + TABLE, useQueriesOrQueriesById(queriesOrQueriesId), listener, listenerDeps, [
        queryId
    ]);
const useResultTableCellIdsListener = (queryId, listener, listenerDeps, queriesOrQueriesId)=>useListener(RESULT + TABLE + CELL_IDS, useQueriesOrQueriesById(queriesOrQueriesId), listener, listenerDeps, [
        queryId
    ]);
const useResultRowCountListener = (queryId, listener, listenerDeps, queriesOrQueriesId)=>useListener(RESULT + ROW_COUNT, useQueriesOrQueriesById(queriesOrQueriesId), listener, listenerDeps, [
        queryId
    ]);
const useResultRowIdsListener = (queryId, listener, listenerDeps, queriesOrQueriesId)=>useListener(RESULT + ROW_IDS, useQueriesOrQueriesById(queriesOrQueriesId), listener, listenerDeps, [
        queryId
    ]);
const useResultSortedRowIdsListener = (queryId, cellId, descending, offset, limit, listener, listenerDeps, queriesOrQueriesId)=>useListener(RESULT + SORTED_ROW_IDS, useQueriesOrQueriesById(queriesOrQueriesId), listener, listenerDeps, [
        queryId,
        cellId,
        descending,
        offset,
        limit
    ]);
const useResultRowListener = (queryId, rowId, listener, listenerDeps, queriesOrQueriesId)=>useListener(RESULT + ROW, useQueriesOrQueriesById(queriesOrQueriesId), listener, listenerDeps, [
        queryId,
        rowId
    ]);
const useResultCellIdsListener = (queryId, rowId, listener, listenerDeps, queriesOrQueriesId)=>useListener(RESULT + CELL_IDS, useQueriesOrQueriesById(queriesOrQueriesId), listener, listenerDeps, [
        queryId,
        rowId
    ]);
const useResultCellListener = (queryId, rowId, cellId, listener, listenerDeps, queriesOrQueriesId)=>useListener(RESULT + CELL, useQueriesOrQueriesById(queriesOrQueriesId), listener, listenerDeps, [
        queryId,
        rowId,
        cellId
    ]);
const useCreateCheckpoints = (store, create, createDeps)=>useCreate(store, create, createDeps);
const useCheckpointIds = (checkpointsOrCheckpointsId)=>useListenable(CHECKPOINT + IDS, useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId), 2 /* Checkpoints */ );
const useCheckpoint = (checkpointId, checkpointsOrCheckpointsId)=>useListenable(CHECKPOINT, useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId), 3 /* CellOrValue */ , [
        checkpointId
    ]);
const useSetCheckpointCallback = (getCheckpoint = getUndefined, getCheckpointDeps = EMPTY_ARRAY, checkpointsOrCheckpointsId, then = getUndefined, thenDeps = EMPTY_ARRAY)=>{
    const checkpoints = useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId);
    return useCallback({
        "useSetCheckpointCallback.useCallback": (parameter)=>ifNotUndefined(checkpoints, {
                "useSetCheckpointCallback.useCallback": (checkpoints2)=>{
                    const label = getCheckpoint(parameter);
                    then(checkpoints2.addCheckpoint(label), checkpoints2, label);
                }
            }["useSetCheckpointCallback.useCallback"])
    }["useSetCheckpointCallback.useCallback"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        checkpoints,
        ...getCheckpointDeps,
        ...thenDeps
    ]);
};
const useGoBackwardCallback = (checkpointsOrCheckpointsId)=>useCheckpointAction(checkpointsOrCheckpointsId, 'goBackward');
const useGoForwardCallback = (checkpointsOrCheckpointsId)=>useCheckpointAction(checkpointsOrCheckpointsId, 'goForward');
const useGoToCallback = (getCheckpointId, getCheckpointIdDeps = EMPTY_ARRAY, checkpointsOrCheckpointsId, then = getUndefined, thenDeps = EMPTY_ARRAY)=>{
    const checkpoints = useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId);
    return useCallback({
        "useGoToCallback.useCallback": (parameter)=>ifNotUndefined(checkpoints, {
                "useGoToCallback.useCallback": (checkpoints2)=>ifNotUndefined(getCheckpointId(parameter), {
                        "useGoToCallback.useCallback": (checkpointId)=>then(checkpoints2.goTo(checkpointId), checkpointId)
                    }["useGoToCallback.useCallback"])
            }["useGoToCallback.useCallback"])
    }["useGoToCallback.useCallback"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        checkpoints,
        ...getCheckpointIdDeps,
        ...thenDeps
    ]);
};
const useUndoInformation = (checkpointsOrCheckpointsId)=>{
    const checkpoints = useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId);
    const [backwardIds, currentId] = useCheckpointIds(checkpoints);
    return [
        !arrayIsEmpty(backwardIds),
        useGoBackwardCallback(checkpoints),
        currentId,
        ifNotUndefined(currentId, (id)=>checkpoints?.getCheckpoint(id)) ?? EMPTY_STRING
    ];
};
const useRedoInformation = (checkpointsOrCheckpointsId)=>{
    const checkpoints = useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId);
    const [, , [forwardId]] = useCheckpointIds(checkpoints);
    return [
        !isUndefined(forwardId),
        useGoForwardCallback(checkpoints),
        forwardId,
        ifNotUndefined(forwardId, (id)=>checkpoints?.getCheckpoint(id)) ?? EMPTY_STRING
    ];
};
const useCheckpointIdsListener = (listener, listenerDeps, checkpointsOrCheckpointsId)=>useListener(CHECKPOINT + IDS, useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId), listener, listenerDeps);
const useCheckpointListener = (checkpointId, listener, listenerDeps, checkpointsOrCheckpointsId)=>useListener(CHECKPOINT, useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId), listener, listenerDeps, [
        checkpointId
    ]);
const useCreatePersister = (store, create, createDeps = EMPTY_ARRAY, then, thenDeps = EMPTY_ARRAY, destroy, destroyDeps = EMPTY_ARRAY)=>{
    const [, rerender] = useState();
    const [persister, setPersister] = useState();
    useEffect({
        "useCreatePersister.useEffect": ()=>{
            ({
                "useCreatePersister.useEffect": async ()=>{
                    const persister2 = store ? await create(store) : void 0;
                    setPersister(persister2);
                    if (persister2 && then) {
                        ({
                            "useCreatePersister.useEffect": async ()=>{
                                await then(persister2);
                                rerender([]);
                            }
                        })["useCreatePersister.useEffect"]();
                    }
                }
            })["useCreatePersister.useEffect"]();
        }
    }["useCreatePersister.useEffect"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        store,
        ...createDeps,
        ...thenDeps
    ]);
    useEffect({
        "useCreatePersister.useEffect": ()=>({
                "useCreatePersister.useEffect": ()=>{
                    if (persister) {
                        persister.destroy();
                        destroy?.(persister);
                    }
                }
            })["useCreatePersister.useEffect"]
    }["useCreatePersister.useEffect"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        persister,
        ...destroyDeps
    ]);
    return persister;
};
const usePersisterStatus = (persisterOrPersisterId)=>useListenable(STATUS, usePersisterOrPersisterById(persisterOrPersisterId), 5 /* Number */ , []);
const usePersisterStatusListener = (listener, listenerDeps, persisterOrPersisterId)=>useListener(STATUS, usePersisterOrPersisterById(persisterOrPersisterId), listener, listenerDeps, []);
const useCreateSynchronizer = (store, create, createDeps = EMPTY_ARRAY, destroy, destroyDeps = EMPTY_ARRAY)=>{
    const [synchronizer, setSynchronizer] = useState();
    useEffect({
        "useCreateSynchronizer.useEffect": ()=>{
            ({
                "useCreateSynchronizer.useEffect": async ()=>{
                    const synchronizer2 = store ? await create(store) : void 0;
                    setSynchronizer(synchronizer2);
                }
            })["useCreateSynchronizer.useEffect"]();
        }
    }["useCreateSynchronizer.useEffect"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        store,
        ...createDeps
    ]);
    useEffect({
        "useCreateSynchronizer.useEffect": ()=>({
                "useCreateSynchronizer.useEffect": ()=>{
                    if (synchronizer) {
                        synchronizer.destroy();
                        destroy?.(synchronizer);
                    }
                }
            })["useCreateSynchronizer.useEffect"]
    }["useCreateSynchronizer.useEffect"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        synchronizer,
        ...destroyDeps
    ]);
    return synchronizer;
};
const useSynchronizerStatus = (synchronizerOrSynchronizerId)=>useListenable(STATUS, useSynchronizerOrSynchronizerById(synchronizerOrSynchronizerId), 5 /* Number */ , []);
const useSynchronizerStatusListener = (listener, listenerDeps, synchronizerOrSynchronizerId)=>useListener(STATUS, useSynchronizerOrSynchronizerById(synchronizerOrSynchronizerId), listener, listenerDeps, []);
const mergeParentThings = (offset, parentValue, defaultThing, thingsById, extraThingsById)=>[
        defaultThing ?? parentValue[offset * 2],
        {
            ...parentValue[offset * 2 + 1],
            ...thingsById,
            ...extraThingsById[offset]
        }
    ];
const tableView = ({ tableId, store, rowComponent: Row = RowView, getRowComponentProps, customCellIds, separator, debugIds }, rowIds)=>wrap(arrayMap(rowIds, (rowId)=>/* @__PURE__ */ createElement(Row, {
            ...getProps(getRowComponentProps, rowId),
            key: rowId,
            tableId,
            rowId,
            customCellIds,
            store,
            debugIds
        })), separator, debugIds, tableId);
const resultTableView = ({ queryId, queries, resultRowComponent: ResultRow = ResultRowView, getResultRowComponentProps, separator, debugIds }, rowIds)=>wrap(arrayMap(rowIds, (rowId)=>/* @__PURE__ */ createElement(ResultRow, {
            ...getProps(getResultRowComponentProps, rowId),
            key: rowId,
            queryId,
            rowId,
            queries,
            debugIds
        })), separator, debugIds, queryId);
const useComponentPerRow = ({ relationshipId, relationships, rowComponent: Row = RowView, getRowComponentProps, separator, debugIds }, getRowIdsHook, rowId)=>{
    const [resolvedRelationships, store, localTableId] = getRelationshipsStoreTableIds(useRelationshipsOrRelationshipsById(relationships), relationshipId);
    const rowIds = getRowIdsHook(relationshipId, rowId, resolvedRelationships);
    return wrap(arrayMap(rowIds, (rowId2)=>/* @__PURE__ */ createElement(Row, {
            ...getProps(getRowComponentProps, rowId2),
            key: rowId2,
            tableId: localTableId,
            rowId: rowId2,
            store,
            debugIds
        })), separator, debugIds, rowId);
};
const getUseCheckpointView = (getCheckpoints)=>({ checkpoints, checkpointComponent: Checkpoint = CheckpointView, getCheckpointComponentProps, separator, debugIds })=>{
        const resolvedCheckpoints = useCheckpointsOrCheckpointsById(checkpoints);
        return wrap(arrayMap(getCheckpoints(useCheckpointIds(resolvedCheckpoints)), (checkpointId)=>/* @__PURE__ */ createElement(Checkpoint, {
                ...getProps(getCheckpointComponentProps, checkpointId),
                key: checkpointId,
                checkpoints: resolvedCheckpoints,
                checkpointId,
                debugIds
            })), separator);
    };
const Provider = ({ store, storesById, metrics, metricsById, indexes, indexesById, relationships, relationshipsById, queries, queriesById, checkpoints, checkpointsById, persister, persistersById, synchronizer, synchronizersById, children })=>{
    const parentValue = useContext(Context);
    const [extraThingsById, setExtraThingsById] = useState({
        "Provider.useState": ()=>arrayNew(8, {
                "Provider.useState": ()=>({})
            }["Provider.useState"])
    }["Provider.useState"]);
    const addExtraThingById = useCallback({
        "Provider.useCallback[addExtraThingById]": (thingOffset, id, thing)=>setExtraThingsById({
                "Provider.useCallback[addExtraThingById]": (extraThingsById2)=>objGet(extraThingsById2[thingOffset], id) == thing ? extraThingsById2 : arrayWith(extraThingsById2, thingOffset, {
                        ...extraThingsById2[thingOffset],
                        [id]: thing
                    })
            }["Provider.useCallback[addExtraThingById]"])
    }["Provider.useCallback[addExtraThingById]"], []);
    const delExtraThingById = useCallback({
        "Provider.useCallback[delExtraThingById]": (thingOffset, id)=>setExtraThingsById({
                "Provider.useCallback[delExtraThingById]": (extraThingsById2)=>!objHas(extraThingsById2[thingOffset], id) ? extraThingsById2 : arrayWith(extraThingsById2, thingOffset, objDel(extraThingsById2[thingOffset], id))
            }["Provider.useCallback[delExtraThingById]"])
    }["Provider.useCallback[delExtraThingById]"], []);
    return /* @__PURE__ */ createElement(Context.Provider, {
        value: useMemo({
            "Provider.useMemo": ()=>[
                    ...mergeParentThings(0 /* Store */ , parentValue, store, storesById, extraThingsById),
                    ...mergeParentThings(1 /* Metrics */ , parentValue, metrics, metricsById, extraThingsById),
                    ...mergeParentThings(2 /* Indexes */ , parentValue, indexes, indexesById, extraThingsById),
                    ...mergeParentThings(3 /* Relationships */ , parentValue, relationships, relationshipsById, extraThingsById),
                    ...mergeParentThings(4 /* Queries */ , parentValue, queries, queriesById, extraThingsById),
                    ...mergeParentThings(5 /* Checkpoints */ , parentValue, checkpoints, checkpointsById, extraThingsById),
                    ...mergeParentThings(6 /* Persister */ , parentValue, persister, persistersById, extraThingsById),
                    ...mergeParentThings(7 /* Synchronizer */ , parentValue, synchronizer, synchronizersById, extraThingsById),
                    addExtraThingById,
                    delExtraThingById
                ]
        }["Provider.useMemo"], [
            extraThingsById,
            store,
            storesById,
            metrics,
            metricsById,
            indexes,
            indexesById,
            relationships,
            relationshipsById,
            queries,
            queriesById,
            checkpoints,
            checkpointsById,
            persister,
            persistersById,
            synchronizer,
            synchronizersById,
            parentValue,
            addExtraThingById,
            delExtraThingById
        ])
    }, children);
};
const wrap = (children, separator, encloseWithId, id)=>{
    const separated = isUndefined(separator) || !isArray(children) ? children : arrayMap(children, (child, c)=>c > 0 ? [
            separator,
            child
        ] : child);
    return encloseWithId ? [
        id,
        ':{',
        separated,
        '}'
    ] : separated;
};
const useCustomOrDefaultCellIds = (customCellIds, tableId, rowId, store)=>{
    const defaultCellIds = useCellIds(tableId, rowId, store);
    return customCellIds ?? defaultCellIds;
};
const CellView = ({ tableId, rowId, cellId, store, debugIds })=>wrap(EMPTY_STRING + (useCell(tableId, rowId, cellId, store) ?? EMPTY_STRING), void 0, debugIds, cellId);
const RowView = ({ tableId, rowId, store, cellComponent: Cell = CellView, getCellComponentProps, customCellIds, separator, debugIds })=>wrap(arrayMap(useCustomOrDefaultCellIds(customCellIds, tableId, rowId, store), (cellId)=>/* @__PURE__ */ createElement(Cell, {
            ...getProps(getCellComponentProps, cellId),
            key: cellId,
            tableId,
            rowId,
            cellId,
            store,
            debugIds
        })), separator, debugIds, rowId);
const TableView = (props)=>tableView(props, useRowIds(props.tableId, props.store));
const SortedTableView = ({ cellId, descending, offset, limit, ...props })=>tableView(props, useSortedRowIds(props.tableId, cellId, descending, offset, limit, props.store));
const TablesView = ({ store, tableComponent: Table = TableView, getTableComponentProps, separator, debugIds })=>wrap(arrayMap(useTableIds(store), (tableId)=>/* @__PURE__ */ createElement(Table, {
            ...getProps(getTableComponentProps, tableId),
            key: tableId,
            tableId,
            store,
            debugIds
        })), separator);
const ValueView = ({ valueId, store, debugIds })=>wrap(EMPTY_STRING + (useValue(valueId, store) ?? EMPTY_STRING), void 0, debugIds, valueId);
const ValuesView = ({ store, valueComponent: Value = ValueView, getValueComponentProps, separator, debugIds })=>wrap(arrayMap(useValueIds(store), (valueId)=>/* @__PURE__ */ createElement(Value, {
            ...getProps(getValueComponentProps, valueId),
            key: valueId,
            valueId,
            store,
            debugIds
        })), separator);
const MetricView = ({ metricId, metrics, debugIds })=>wrap(useMetric(metricId, metrics) ?? EMPTY_STRING, void 0, debugIds, metricId);
const SliceView = ({ indexId, sliceId, indexes, rowComponent: Row = RowView, getRowComponentProps, separator, debugIds })=>{
    const [resolvedIndexes, store, tableId] = getIndexStoreTableId(useIndexesOrIndexesById(indexes), indexId);
    const rowIds = useSliceRowIds(indexId, sliceId, resolvedIndexes);
    return wrap(arrayMap(rowIds, (rowId)=>/* @__PURE__ */ createElement(Row, {
            ...getProps(getRowComponentProps, rowId),
            key: rowId,
            tableId,
            rowId,
            store,
            debugIds
        })), separator, debugIds, sliceId);
};
const IndexView = ({ indexId, indexes, sliceComponent: Slice = SliceView, getSliceComponentProps, separator, debugIds })=>wrap(arrayMap(useSliceIds(indexId, indexes), (sliceId)=>/* @__PURE__ */ createElement(Slice, {
            ...getProps(getSliceComponentProps, sliceId),
            key: sliceId,
            indexId,
            sliceId,
            indexes,
            debugIds
        })), separator, debugIds, indexId);
const RemoteRowView = ({ relationshipId, localRowId, relationships, rowComponent: Row = RowView, getRowComponentProps, debugIds })=>{
    const [resolvedRelationships, store, , remoteTableId] = getRelationshipsStoreTableIds(useRelationshipsOrRelationshipsById(relationships), relationshipId);
    const rowId = useRemoteRowId(relationshipId, localRowId, resolvedRelationships);
    return wrap(isUndefined(remoteTableId) || isUndefined(rowId) ? null : /* @__PURE__ */ createElement(Row, {
        ...getProps(getRowComponentProps, rowId),
        key: rowId,
        tableId: remoteTableId,
        rowId,
        store,
        debugIds
    }), void 0, debugIds, localRowId);
};
const LocalRowsView = (props)=>useComponentPerRow(props, useLocalRowIds, props.remoteRowId);
const LinkedRowsView = (props)=>useComponentPerRow(props, useLinkedRowIds, props.firstRowId);
const ResultCellView = ({ queryId, rowId, cellId, queries, debugIds })=>wrap(EMPTY_STRING + (useResultCell(queryId, rowId, cellId, queries) ?? EMPTY_STRING), void 0, debugIds, cellId);
const ResultRowView = ({ queryId, rowId, queries, resultCellComponent: ResultCell = ResultCellView, getResultCellComponentProps, separator, debugIds })=>wrap(arrayMap(useResultCellIds(queryId, rowId, queries), (cellId)=>/* @__PURE__ */ createElement(ResultCell, {
            ...getProps(getResultCellComponentProps, cellId),
            key: cellId,
            queryId,
            rowId,
            cellId,
            queries,
            debugIds
        })), separator, debugIds, rowId);
const ResultTableView = (props)=>resultTableView(props, useResultRowIds(props.queryId, props.queries));
const ResultSortedTableView = ({ cellId, descending, offset, limit, ...props })=>resultTableView(props, useResultSortedRowIds(props.queryId, cellId, descending, offset, limit, props.queries));
const CheckpointView = ({ checkpoints, checkpointId, debugIds })=>wrap(useCheckpoint(checkpointId, checkpoints) ?? EMPTY_STRING, void 0, debugIds, checkpointId);
const BackwardCheckpointsView = getUseCheckpointView((checkpointIds)=>checkpointIds[0]);
const CurrentCheckpointView = getUseCheckpointView((checkpointIds)=>isUndefined(checkpointIds[1]) ? [] : [
        checkpointIds[1]
    ]);
const ForwardCheckpointsView = getUseCheckpointView((checkpointIds)=>checkpointIds[2]);
;
}}),
"[project]/node_modules/.pnpm/next@15.2.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/navigation.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.2.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/.pnpm/tinybase@5.4.8_@cloudflare+workers-types@4.20250224.0_prettier@3.5.2_react-dom@19.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/synchronizers/synchronizer-ws-client/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createWsSynchronizer": (()=>createWsSynchronizer)
});
const EMPTY_STRING = '';
const UTF8 = 'utf8';
const OPEN = 'open';
const MESSAGE = 'message';
const ERROR = 'error';
const UNDEFINED = '\uFFFC';
const strSplit = (str, separator = EMPTY_STRING, limit)=>str.split(separator, limit);
const promise = Promise;
const GLOBAL = globalThis;
const THOUSAND = 1e3;
const startTimeout = (callback, sec = 0)=>setTimeout(callback, sec * THOUSAND);
const math = Math;
const mathFloor = math.floor;
const isUndefined = (thing)=>thing == void 0;
const ifNotUndefined = (value, then, otherwise)=>isUndefined(value) ? otherwise?.() : then(value);
const isArray = (thing)=>Array.isArray(thing);
const slice = (arrayOrString, start, end)=>arrayOrString.slice(start, end);
const size = (arrayOrString)=>arrayOrString.length;
const test = (regex, subject)=>regex.test(subject);
const promiseNew = (resolver)=>new promise(resolver);
const errorNew = (message)=>{
    throw new Error(message);
};
const arrayForEach = (array, cb)=>array.forEach(cb);
const arrayMap = (array, cb)=>array.map(cb);
const arrayReduce = (array, cb, initial)=>array.reduce(cb, initial);
const arrayClear = (array, to)=>array.splice(0, to);
const arrayPush = (array, ...values)=>array.push(...values);
const arrayShift = (array)=>array.shift();
const object = Object;
const getPrototypeOf = (obj)=>object.getPrototypeOf(obj);
const objEntries = object.entries;
const isObject = (obj)=>!isUndefined(obj) && ifNotUndefined(getPrototypeOf(obj), (objPrototype)=>objPrototype == object.prototype || isUndefined(getPrototypeOf(objPrototype)), /* istanbul ignore next */ ()=>true);
const objIds = object.keys;
const objFreeze = object.freeze;
const objNew = (entries = [])=>object.fromEntries(entries);
const objHas = (obj, id)=>id in obj;
const objForEach = (obj, cb)=>arrayForEach(objEntries(obj), ([id, value])=>cb(value, id));
const objSize = (obj)=>size(objIds(obj));
const objIsEmpty = (obj)=>isObject(obj) && objSize(obj) == 0;
const objEnsure = (obj, id, getDefaultValue)=>{
    if (!objHas(obj, id)) {
        obj[id] = getDefaultValue();
    }
    return obj[id];
};
const jsonString = JSON.stringify;
const jsonParse = JSON.parse;
const jsonStringWithUndefined = (obj)=>jsonString(obj, (_key, value)=>value === void 0 ? UNDEFINED : value);
const jsonParseWithUndefined = (str)=>jsonParse(str, (_key, value)=>value === UNDEFINED ? void 0 : value);
const MESSAGE_SEPARATOR = '\n';
const ifPayloadValid = (payload, then)=>{
    const splitAt = payload.indexOf(MESSAGE_SEPARATOR);
    if (splitAt !== -1) {
        then(slice(payload, 0, splitAt), slice(payload, splitAt + 1));
    }
};
const receivePayload = (payload, receive)=>ifPayloadValid(payload, (fromClientId, remainder)=>receive(fromClientId, ...jsonParseWithUndefined(remainder)));
const createPayload = (toClientId, ...args)=>createRawPayload(toClientId ?? EMPTY_STRING, jsonStringWithUndefined(args));
const createRawPayload = (clientId, remainder)=>clientId + MESSAGE_SEPARATOR + remainder;
const collSize = (coll)=>coll?.size ?? 0;
const collHas = (coll, keyOrValue)=>coll?.has(keyOrValue) ?? false;
const collIsEmpty = (coll)=>isUndefined(coll) || collSize(coll) == 0;
const collForEach = (coll, cb)=>coll?.forEach(cb);
const collDel = (coll, keyOrValue)=>coll?.delete(keyOrValue);
const mapNew = (entries)=>new Map(entries);
const mapGet = (map, key)=>map?.get(key);
const mapSet = (map, key, value)=>isUndefined(value) ? (collDel(map, key), map) : map?.set(key, value);
const mapEnsure = (map, key, getDefaultValue, hadExistingValue)=>{
    if (!collHas(map, key)) {
        mapSet(map, key, getDefaultValue());
    } else {
        hadExistingValue?.(mapGet(map, key));
    }
    return mapGet(map, key);
};
const visitTree = (node, path, ensureLeaf, pruneLeaf, p = 0)=>ifNotUndefined((ensureLeaf ? mapEnsure : mapGet)(node, path[p], p > size(path) - 2 ? ensureLeaf : mapNew), (nodeOrLeaf)=>{
        if (p > size(path) - 2) {
            if (pruneLeaf?.(nodeOrLeaf)) {
                mapSet(node, path[p]);
            }
            return nodeOrLeaf;
        }
        const leaf = visitTree(nodeOrLeaf, path, ensureLeaf, pruneLeaf, p + 1);
        if (collIsEmpty(nodeOrLeaf)) {
            mapSet(node, path[p]);
        }
        return leaf;
    });
const stampNew = (value, time)=>time ? [
        value,
        time
    ] : [
        value
    ];
const getLatestTime = (time1, time2)=>/* istanbul ignore next */ ((time1 ?? '') > (time2 ?? '') ? time1 : time2) ?? '';
const stampNewObj = (time = EMPTY_STRING)=>stampNew(objNew(), time);
const setNew = (entryOrEntries)=>new Set(isArray(entryOrEntries) || isUndefined(entryOrEntries) ? entryOrEntries : [
        entryOrEntries
    ]);
const setAdd = (set, value)=>set?.add(value);
const INTEGER = /^\d+$/;
const getPoolFunctions = ()=>{
    const pool = [];
    let nextId = 0;
    return [
        (reuse)=>(reuse ? arrayShift(pool) : null) ?? EMPTY_STRING + nextId++,
        (id)=>{
            if (test(INTEGER, id) && size(pool) < 1e3) {
                arrayPush(pool, id);
            }
        }
    ];
};
const getWildcardedLeaves = (deepIdSet, path = [
    EMPTY_STRING
])=>{
    const leaves = [];
    const deep = (node, p)=>p == size(path) ? arrayPush(leaves, node) : path[p] === null ? collForEach(node, (node2)=>deep(node2, p + 1)) : arrayForEach([
            path[p],
            null
        ], (id)=>deep(mapGet(node, id), p + 1));
    deep(deepIdSet, 0);
    return leaves;
};
const getListenerFunctions = (getThing)=>{
    let thing;
    const [getId, releaseId] = getPoolFunctions();
    const allListeners = mapNew();
    const addListener = (listener, idSetNode, path, pathGetters = [], extraArgsGetter = ()=>[])=>{
        thing ??= getThing();
        const id = getId(1);
        mapSet(allListeners, id, [
            listener,
            idSetNode,
            path,
            pathGetters,
            extraArgsGetter
        ]);
        setAdd(visitTree(idSetNode, path ?? [
            EMPTY_STRING
        ], setNew), id);
        return id;
    };
    const callListeners = (idSetNode, ids, ...extraArgs)=>arrayForEach(getWildcardedLeaves(idSetNode, ids), (set)=>collForEach(set, (id)=>mapGet(allListeners, id)[0](thing, ...ids ?? [], ...extraArgs)));
    const delListener = (id)=>ifNotUndefined(mapGet(allListeners, id), ([, idSetNode, idOrNulls])=>{
            visitTree(idSetNode, idOrNulls ?? [
                EMPTY_STRING
            ], void 0, (idSet)=>{
                collDel(idSet, id);
                return collIsEmpty(idSet) ? 1 : 0;
            });
            mapSet(allListeners, id);
            releaseId(id);
            return idOrNulls;
        });
    const callListener = (id)=>ifNotUndefined(mapGet(allListeners, id), ([listener, , path = [], pathGetters, extraArgsGetter])=>{
            const callWithIds = (...ids)=>{
                const index = size(ids);
                if (index == size(path)) {
                    listener(thing, ...ids, ...extraArgsGetter(ids));
                } else if (isUndefined(path[index])) {
                    arrayForEach(pathGetters[index]?.(...ids) ?? [], (id2)=>callWithIds(...ids, id2));
                } else {
                    callWithIds(...ids, path[index]);
                }
            };
            callWithIds();
        });
    return [
        addListener,
        callListeners,
        delListener,
        callListener
    ];
};
const scheduleRunning = mapNew();
const scheduleActions = mapNew();
const getStoreFunctions = (persist = 1 /* StoreOnly */ , store, isSynchronizer)=>persist != 1 /* StoreOnly */  && store.isMergeable() ? [
        1,
        store.getMergeableContent,
        ()=>store.getTransactionMergeableChanges(!isSynchronizer),
        ([[changedTables], [changedValues]])=>!objIsEmpty(changedTables) || !objIsEmpty(changedValues),
        store.setDefaultContent
    ] : persist != 2 /* MergeableStoreOnly */  ? [
        0,
        store.getContent,
        store.getTransactionChanges,
        ([changedTables, changedValues])=>!objIsEmpty(changedTables) || !objIsEmpty(changedValues),
        store.setContent
    ] : errorNew('Store type not supported by this Persister');
const createCustomPersister = (store, getPersisted, setPersisted, addPersisterListener, delPersisterListener, onIgnoredError, persist, extra = {}, isSynchronizer = 0, scheduleId = [])=>{
    let status = 0; /* Idle */ 
    let loads = 0;
    let saves = 0;
    let action;
    let autoLoadHandle;
    let autoSaveListenerId;
    mapEnsure(scheduleRunning, scheduleId, ()=>0);
    mapEnsure(scheduleActions, scheduleId, ()=>[]);
    const statusListeners = mapNew();
    const [isMergeableStore, getContent, getChanges, hasChanges, setDefaultContent] = getStoreFunctions(persist, store, isSynchronizer);
    const [addListener, callListeners, delListenerImpl] = getListenerFunctions(()=>persister);
    const setStatus = (newStatus)=>{
        if (newStatus != status) {
            status = newStatus;
            callListeners(statusListeners, void 0, status);
        }
    };
    const run = async ()=>{
        /* istanbul ignore else */ if (!mapGet(scheduleRunning, scheduleId)) {
            mapSet(scheduleRunning, scheduleId, 1);
            while(!isUndefined(action = arrayShift(mapGet(scheduleActions, scheduleId)))){
                try {
                    await action();
                } catch (error) {
                    /* istanbul ignore next */ onIgnoredError?.(error);
                }
            }
            mapSet(scheduleRunning, scheduleId, 0);
        }
    };
    const setContentOrChanges = (contentOrChanges)=>{
        (isMergeableStore && isArray(contentOrChanges?.[0]) ? contentOrChanges?.[2] === 1 ? store.applyMergeableChanges : store.setMergeableContent : contentOrChanges?.[2] === 1 ? store.applyChanges : store.setContent)(contentOrChanges);
    };
    const load = async (initialContent)=>{
        /* istanbul ignore else */ if (status != 2 /* Saving */ ) {
            setStatus(1 /* Loading */ );
            loads++;
            await schedule(async ()=>{
                try {
                    const content = await getPersisted();
                    if (isArray(content)) {
                        setContentOrChanges(content);
                    } else if (initialContent) {
                        setDefaultContent(initialContent);
                    } else {
                        errorNew(`Content is not an array: ${content}`);
                    }
                } catch (error) {
                    onIgnoredError?.(error);
                    if (initialContent) {
                        setDefaultContent(initialContent);
                    }
                }
                setStatus(0 /* Idle */ );
            });
        }
        return persister;
    };
    const startAutoLoad = async (initialContent)=>{
        stopAutoLoad();
        await load(initialContent);
        try {
            autoLoadHandle = await addPersisterListener(async (content, changes)=>{
                if (changes || content) {
                    /* istanbul ignore else */ if (status != 2 /* Saving */ ) {
                        setStatus(1 /* Loading */ );
                        loads++;
                        setContentOrChanges(changes ?? content);
                        setStatus(0 /* Idle */ );
                    }
                } else {
                    await load();
                }
            });
        } catch (error) {
            /* istanbul ignore next */ onIgnoredError?.(error);
        }
        return persister;
    };
    const stopAutoLoad = ()=>{
        if (autoLoadHandle) {
            delPersisterListener(autoLoadHandle);
            autoLoadHandle = void 0;
        }
        return persister;
    };
    const isAutoLoading = ()=>!isUndefined(autoLoadHandle);
    const save = async (changes)=>{
        /* istanbul ignore else */ if (status != 1 /* Loading */ ) {
            setStatus(2 /* Saving */ );
            saves++;
            await schedule(async ()=>{
                try {
                    await setPersisted(getContent, changes);
                } catch (error) {
                    /* istanbul ignore next */ onIgnoredError?.(error);
                }
                setStatus(0 /* Idle */ );
            });
        }
        return persister;
    };
    const startAutoSave = async ()=>{
        stopAutoSave();
        await save();
        autoSaveListenerId = store.addDidFinishTransactionListener(()=>{
            const changes = getChanges();
            if (hasChanges(changes)) {
                save(changes);
            }
        });
        return persister;
    };
    const stopAutoSave = ()=>{
        if (autoSaveListenerId) {
            store.delListener(autoSaveListenerId);
            autoSaveListenerId = void 0;
        }
        return persister;
    };
    const isAutoSaving = ()=>!isUndefined(autoSaveListenerId);
    const getStatus = ()=>status;
    const addStatusListener = (listener)=>addListener(listener, statusListeners);
    const delListener = (listenerId)=>{
        delListenerImpl(listenerId);
        return store;
    };
    const schedule = async (...actions)=>{
        arrayPush(mapGet(scheduleActions, scheduleId), ...actions);
        await run();
        return persister;
    };
    const getStore = ()=>store;
    const destroy = ()=>{
        arrayClear(mapGet(scheduleActions, scheduleId));
        return stopAutoLoad().stopAutoSave();
    };
    const getStats = ()=>({
            loads,
            saves
        });
    const persister = {
        load,
        startAutoLoad,
        stopAutoLoad,
        isAutoLoading,
        save,
        startAutoSave,
        stopAutoSave,
        isAutoSaving,
        getStatus,
        addStatusListener,
        delListener,
        schedule,
        getStore,
        destroy,
        getStats,
        ...extra
    };
    return objFreeze(persister);
};
const MASK6 = 63;
const ENCODE = /* @__PURE__ */ strSplit('-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz');
const encode = (num)=>ENCODE[num & MASK6];
const getRandomValues = GLOBAL.crypto ? (array)=>GLOBAL.crypto.getRandomValues(array) : /* istanbul ignore next */ (array)=>arrayMap(array, ()=>mathFloor(math.random() * 256));
const getUniqueId = (length = 16)=>arrayReduce(getRandomValues(new Uint8Array(length)), (uniqueId, number)=>uniqueId + encode(number), '');
const createCustomSynchronizer = (store, send, registerReceive, destroyImpl, requestTimeoutSeconds, onSend, onReceive, onIgnoredError, extra = {})=>{
    let syncing = 0;
    let persisterListener;
    let sends = 0;
    let receives = 0;
    const pendingRequests = mapNew();
    const getTransactionId = ()=>getUniqueId(11);
    const sendImpl = (toClientId, requestId, message, body)=>{
        sends++;
        onSend?.(toClientId, requestId, message, body);
        send(toClientId, requestId, message, body);
    };
    const request = async (toClientId, message, body, transactionId)=>promiseNew((resolve, reject)=>{
            const requestId = transactionId + '.' + getUniqueId(4);
            const timeout = startTimeout(()=>{
                collDel(pendingRequests, requestId);
                reject(`No response from ${toClientId ?? 'anyone'} to ${requestId}, ` + message);
            }, requestTimeoutSeconds);
            mapSet(pendingRequests, requestId, [
                toClientId,
                (response, fromClientId)=>{
                    clearTimeout(timeout);
                    collDel(pendingRequests, requestId);
                    resolve([
                        response,
                        fromClientId,
                        transactionId
                    ]);
                }
            ]);
            sendImpl(toClientId, requestId, message, body);
        });
    const mergeTablesStamps = (tablesStamp, [tableStamps2, tablesTime2])=>{
        objForEach(tableStamps2, ([rowStamps2, tableTime2], tableId)=>{
            const tableStamp = objEnsure(tablesStamp[0], tableId, stampNewObj);
            objForEach(rowStamps2, ([cellStamps2, rowTime2], rowId)=>{
                const rowStamp = objEnsure(tableStamp[0], rowId, stampNewObj);
                objForEach(cellStamps2, ([cell2, cellTime2], cellId)=>rowStamp[0][cellId] = stampNew(cell2, cellTime2));
                rowStamp[1] = getLatestTime(rowStamp[1], rowTime2);
            });
            tableStamp[1] = getLatestTime(tableStamp[1], tableTime2);
        });
        tablesStamp[1] = getLatestTime(tablesStamp[1], tablesTime2);
    };
    const getChangesFromOtherStore = async (otherClientId = null, otherContentHashes, transactionId = getTransactionId())=>{
        try {
            if (isUndefined(otherContentHashes)) {
                [otherContentHashes, otherClientId, transactionId] = await request(null, 1 /* GetContentHashes */ , EMPTY_STRING, transactionId);
            }
            const [otherTablesHash, otherValuesHash] = otherContentHashes;
            const [tablesHash, valuesHash] = store.getMergeableContentHashes();
            let tablesChanges = stampNewObj();
            if (tablesHash != otherTablesHash) {
                const [newTables, differentTableHashes] = (await request(otherClientId, 4 /* GetTableDiff */ , store.getMergeableTableHashes(), transactionId))[0];
                tablesChanges = newTables;
                if (!objIsEmpty(differentTableHashes)) {
                    const [newRows, differentRowHashes] = (await request(otherClientId, 5 /* GetRowDiff */ , store.getMergeableRowHashes(differentTableHashes), transactionId))[0];
                    mergeTablesStamps(tablesChanges, newRows);
                    if (!objIsEmpty(differentRowHashes)) {
                        const newCells = (await request(otherClientId, 6 /* GetCellDiff */ , store.getMergeableCellHashes(differentRowHashes), transactionId))[0];
                        mergeTablesStamps(tablesChanges, newCells);
                    }
                }
            }
            return [
                tablesChanges,
                valuesHash == otherValuesHash ? stampNewObj() : (await request(otherClientId, 7 /* GetValueDiff */ , store.getMergeableValueHashes(), transactionId))[0],
                1
            ];
        } catch (error) {
            onIgnoredError?.(error);
        }
    };
    const getPersisted = async ()=>{
        const changes = await getChangesFromOtherStore();
        return changes && (!objIsEmpty(changes[0][0]) || !objIsEmpty(changes[1][0])) ? changes : void 0;
    };
    const setPersisted = async (_getContent, changes)=>changes ? sendImpl(null, getTransactionId(), 3 /* ContentDiff */ , changes) : sendImpl(null, getTransactionId(), 2 /* ContentHashes */ , store.getMergeableContentHashes());
    const addPersisterListener = (listener)=>persisterListener = listener;
    const delPersisterListener = ()=>persisterListener = void 0;
    const startSync = async (initialContent)=>{
        syncing = 1;
        return await (await persister.startAutoLoad(initialContent)).startAutoSave();
    };
    const stopSync = ()=>{
        syncing = 0;
        return persister.stopAutoLoad().stopAutoSave();
    };
    const destroy = ()=>{
        destroyImpl();
        return persister.stopSync();
    };
    const getSynchronizerStats = ()=>({
            sends,
            receives
        });
    const persister = createCustomPersister(store, getPersisted, setPersisted, addPersisterListener, delPersisterListener, onIgnoredError, 2, // MergeableStoreOnly
    {
        startSync,
        stopSync,
        destroy,
        getSynchronizerStats,
        ...extra
    }, 1);
    registerReceive((fromClientId, transactionOrRequestId, message, body)=>{
        const isAutoLoading = syncing || persister.isAutoLoading();
        receives++;
        onReceive?.(fromClientId, transactionOrRequestId, message, body);
        if (message == 0 /* Response */ ) {
            ifNotUndefined(mapGet(pendingRequests, transactionOrRequestId), ([toClientId, handleResponse])=>isUndefined(toClientId) || toClientId == fromClientId ? handleResponse(body, fromClientId) : /* istanbul ignore next */ 0);
        } else if (message == 2 /* ContentHashes */  && isAutoLoading) {
            getChangesFromOtherStore(fromClientId, body, transactionOrRequestId ?? void 0).then((changes)=>{
                persisterListener?.(void 0, changes);
            }).catch(onIgnoredError);
        } else if (message == 3 /* ContentDiff */  && isAutoLoading) {
            persisterListener?.(void 0, body);
        } else {
            ifNotUndefined(message == 1 /* GetContentHashes */  && (syncing || persister.isAutoSaving()) ? store.getMergeableContentHashes() : message == 4 /* GetTableDiff */  ? store.getMergeableTableDiff(body) : message == 5 /* GetRowDiff */  ? store.getMergeableRowDiff(body) : message == 6 /* GetCellDiff */  ? store.getMergeableCellDiff(body) : message == 7 /* GetValueDiff */  ? store.getMergeableValueDiff(body) : void 0, (response)=>{
                sendImpl(fromClientId, transactionOrRequestId, 0 /* Response */ , response);
            });
        }
    });
    return persister;
};
const createWsSynchronizer = async (store, webSocket, requestTimeoutSeconds = 1, onSend, onReceive, onIgnoredError)=>{
    const addEventListener = (event, handler)=>{
        webSocket.addEventListener(event, handler);
        return ()=>webSocket.removeEventListener(event, handler);
    };
    const registerReceive = (receive)=>addEventListener(MESSAGE, ({ data })=>receivePayload(data.toString(UTF8), receive));
    const send = (toClientId, ...args)=>webSocket.send(createPayload(toClientId, ...args));
    const destroy = ()=>{
        webSocket.close();
    };
    const synchronizer = createCustomSynchronizer(store, send, registerReceive, destroy, requestTimeoutSeconds, onSend, onReceive, onIgnoredError, {
        getWebSocket: ()=>webSocket
    });
    return promiseNew((resolve)=>{
        if (webSocket.readyState != webSocket.OPEN) {
            const onAttempt = (error)=>{
                if (error) {
                    onIgnoredError?.(error);
                }
                removeOpenListener();
                removeErrorListener();
                resolve(synchronizer);
            };
            const removeOpenListener = addEventListener(OPEN, ()=>onAttempt());
            const removeErrorListener = addEventListener(ERROR, onAttempt);
        } else {
            resolve(synchronizer);
        }
    });
};
;
}}),
"[project]/node_modules/.pnpm/tinybase@5.4.8_@cloudflare+workers-types@4.20250224.0_prettier@3.5.2_react-dom@19.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/ui-react-inspector/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Inspector": (()=>Inspector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$2$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.2.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/tinybase@5.4.8_@cloudflare+workers-types@4.20250224.0_prettier@3.5.2_react-dom@19.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/ui-react/index.js [app-client] (ecmascript)");
;
;
const getTypeOf = (thing)=>typeof thing;
const EMPTY_STRING = '';
const STRING = getTypeOf(EMPTY_STRING);
const BOOLEAN = getTypeOf(true);
const NUMBER = getTypeOf(0);
const FUNCTION = getTypeOf(getTypeOf);
const TYPE = 'type';
const DEFAULT = 'default';
const LISTENER = 'Listener';
const ADD = 'add';
const HAS = 'Has';
const IDS = 'Ids';
const TABLE = 'Table';
const TABLES = TABLE + 's';
const TABLE_IDS = TABLE + IDS;
const ROW = 'Row';
const ROW_COUNT = ROW + 'Count';
const ROW_IDS = ROW + IDS;
const CELL = 'Cell';
const CELL_IDS = CELL + IDS;
const VALUE = 'Value';
const VALUES = VALUE + 's';
const VALUE_IDS = VALUE + IDS;
const CURRENT_TARGET = 'currentTarget';
const _VALUE = 'value';
const UNDEFINED = '\uFFFC';
const id = (key)=>EMPTY_STRING + key;
const strSplit = (str, separator = EMPTY_STRING, limit)=>str.split(separator, limit);
const GLOBAL = globalThis;
const WINDOW = GLOBAL.window;
const math = Math;
const mathMin = math.min;
const mathFloor = math.floor;
const isFiniteNumber = isFinite;
const isInstanceOf = (thing, cls)=>thing instanceof cls;
const isUndefined = (thing)=>thing == void 0;
const ifNotUndefined = (value, then, otherwise)=>isUndefined(value) ? otherwise?.() : then(value);
const isTypeStringOrBoolean = (type)=>type == STRING || type == BOOLEAN;
const isString = (thing)=>getTypeOf(thing) == STRING;
const isFunction = (thing)=>getTypeOf(thing) == FUNCTION;
const isArray = (thing)=>Array.isArray(thing);
const slice = (arrayOrString, start, end)=>arrayOrString.slice(start, end);
const size = (arrayOrString)=>arrayOrString.length;
const test = (regex, subject)=>regex.test(subject);
const errorNew = (message)=>{
    throw new Error(message);
};
const { PureComponent, Fragment, createContext, createElement, useCallback, useContext, useEffect, useLayoutEffect, useMemo, useRef, useState, useSyncExternalStore } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$2$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
const getProps = (getProps2, ...ids)=>isUndefined(getProps2) ? {} : getProps2(...ids);
const getRelationshipsStoreTableIds = (relationships, relationshipId)=>[
        relationships,
        relationships?.getStore(),
        relationships?.getLocalTableId(relationshipId),
        relationships?.getRemoteTableId(relationshipId)
    ];
const getIndexStoreTableId = (indexes, indexId)=>[
        indexes,
        indexes?.getStore(),
        indexes?.getTableId(indexId)
    ];
const arrayHas = (array, value)=>array.includes(value);
const arrayEvery = (array, cb)=>array.every(cb);
const arrayIsEqual = (array1, array2)=>size(array1) === size(array2) && arrayEvery(array1, (value1, index)=>array2[index] === value1);
const arraySort = (array, sorter)=>array.sort(sorter);
const arrayForEach = (array, cb)=>array.forEach(cb);
const arrayJoin = (array, sep = EMPTY_STRING)=>array.join(sep);
const arrayMap = (array, cb)=>array.map(cb);
const arrayIsEmpty = (array)=>size(array) == 0;
const arrayReduce = (array, cb, initial)=>array.reduce(cb, initial);
const arrayClear = (array, to)=>array.splice(0, to);
const arrayPush = (array, ...values)=>array.push(...values);
const arrayShift = (array)=>array.shift();
const object = Object;
const getPrototypeOf = (obj)=>object.getPrototypeOf(obj);
const objEntries = object.entries;
const objFrozen = object.isFrozen;
const isObject = (obj)=>!isUndefined(obj) && ifNotUndefined(getPrototypeOf(obj), (objPrototype)=>objPrototype == object.prototype || isUndefined(getPrototypeOf(objPrototype)), /* istanbul ignore next */ ()=>true);
const objIds = object.keys;
const objFreeze = object.freeze;
const objNew = (entries = [])=>object.fromEntries(entries);
const objHas = (obj, id)=>id in obj;
const objDel = (obj, id)=>{
    delete obj[id];
    return obj;
};
const objForEach = (obj, cb)=>arrayForEach(objEntries(obj), ([id, value])=>cb(value, id));
const objToArray = (obj, cb)=>arrayMap(objEntries(obj), ([id, value])=>cb(value, id));
const objMap = (obj, cb)=>objNew(objToArray(obj, (value, id)=>[
            id,
            cb(value, id)
        ]));
const objSize = (obj)=>size(objIds(obj));
const objIsEmpty = (obj)=>isObject(obj) && objSize(obj) == 0;
const objValidate = (obj, validateChild, onInvalidObj, emptyIsValid = 0)=>{
    if (isUndefined(obj) || !isObject(obj) || !emptyIsValid && objIsEmpty(obj) || objFrozen(obj)) {
        onInvalidObj?.();
        return false;
    }
    objForEach(obj, (child, id)=>{
        if (!validateChild(child, id)) {
            objDel(obj, id);
        }
    });
    return emptyIsValid ? true : !objIsEmpty(obj);
};
const jsonString = JSON.stringify;
const jsonParse = JSON.parse;
const jsonStringWithMap = (obj)=>jsonString(obj, (_key, value)=>isInstanceOf(value, Map) ? object.fromEntries([
            ...value
        ]) : value);
const jsonStringWithUndefined = (obj)=>jsonString(obj, (_key, value)=>value === void 0 ? UNDEFINED : value);
const jsonParseWithUndefined = (str)=>jsonParse(str, (_key, value)=>value === UNDEFINED ? void 0 : value);
const UNIQUE_ID = 'tinybaseInspector';
const TITLE = 'TinyBase Inspector';
const POSITIONS = [
    'left',
    'top',
    'bottom',
    'right',
    'full'
];
const STATE_TABLE = 'state';
const SORT_CELL = 'sort';
const OPEN_CELL = 'open';
const POSITION_VALUE = 'position';
const OPEN_VALUE = OPEN_CELL;
const EDITABLE_CELL = 'editable';
const getUniqueId = (...args)=>jsonStringWithMap(args);
const sortedIdsMap = (ids, callback)=>arrayMap(arraySort([
        ...ids
    ]), callback);
const useEditable = (uniqueId, s)=>[
        !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCell"])(STATE_TABLE, uniqueId, EDITABLE_CELL, s),
        useCallback({
            "useEditable.useCallback": (event)=>{
                s.setCell(STATE_TABLE, uniqueId, EDITABLE_CELL, {
                    "useEditable.useCallback": (editable)=>!editable
                }["useEditable.useCallback"]);
                event.preventDefault();
            }
        }["useEditable.useCallback"], [
            s,
            uniqueId
        ])
    ];
var img = "data:image/svg+xml,%3csvg viewBox='0 0 680 680' xmlns='http://www.w3.org/2000/svg' style='width:680px%3bheight:680px'%3e %3cpath stroke='white' stroke-width='80' fill='none' d='M340 617a84 241 90 11.01 0zM131 475a94 254 70 10428-124 114 286 70 01-428 124zm0-140a94 254 70 10428-124 114 286 70 01-428 124zm-12-127a94 254 70 00306 38 90 260 90 01-306-38zm221 3a74 241 90 11.01 0z' /%3e %3cpath fill='%23d81b60' d='M131 475a94 254 70 10428-124 114 286 70 01-428 124zm0-140a94 254 70 10428-124 114 286 70 01-428 124z' /%3e %3cpath d='M249 619a94 240 90 00308-128 114 289 70 01-308 128zM119 208a94 254 70 00306 38 90 260 90 01-306-38zm221 3a74 241 90 11.01 0z' /%3e%3c/svg%3e";
const PENCIL = 'M20 80l5-15l40-40l10 10l-40 40l-15 5m5-15l10 10';
const PRE_CSS = 'content:url("';
const POST_CSS = '")';
const PRE = PRE_CSS + `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' stroke-width='4' stroke='white' fill='none'>`;
const POST = `</svg>` + POST_CSS;
const LOGO_SVG = PRE_CSS + img + POST_CSS;
const POSITIONS_SVG = arrayMap([
    [
        20,
        20,
        20,
        60
    ],
    [
        20,
        20,
        60,
        20
    ],
    [
        20,
        60,
        60,
        20
    ],
    [
        60,
        20,
        20,
        60
    ],
    [
        30,
        30,
        40,
        40
    ]
], ([x, y, w, h])=>PRE + `<rect x='20' y='20' width='60' height='60' fill='grey'/><rect x='${x}' y='${y}' width='${w}' height='${h}' fill='white'/>` + POST);
const CLOSE_SVG = PRE + `<path d='M20 20l60 60M20 80l60-60' />` + POST;
const EDIT_SVG = PRE + `<path d='${PENCIL}' />` + POST;
const DONE_SVG = PRE + `<path d='${PENCIL}M20 20l60 60' />` + POST;
const SCROLLBAR = '*::-webkit-scrollbar';
const APP_STYLESHEET = arrayJoin(objToArray({
    '': 'all:initial;font-family:sans-serif;font-size:0.75rem;position:fixed;z-index:999999',
    '*': 'all:revert',
    '*::before': 'all:revert',
    '*::after': 'all:revert',
    [SCROLLBAR]: 'width:0.5rem;height:0.5rem;',
    [SCROLLBAR + '-track']: 'background:#111',
    [SCROLLBAR + '-thumb']: 'background:#999;border:1px solid #111',
    [SCROLLBAR + '-thumb:hover']: 'background:#fff',
    [SCROLLBAR + '-corner']: 'background:#111',
    img: 'width:1rem;height:1rem;background:#111;border:0;vertical-align:text-bottom',
    // Nub
    '>img': 'padding:0.25rem;bottom:0;right:0;position:fixed;' + LOGO_SVG,
    ...objNew(arrayMap([
        'bottom:0;left:0',
        'top:0;right:0'
    ], (css, p)=>[
            `>img[data-position='${p}']`,
            css
        ])),
    // Panel
    main: 'display:flex;flex-direction:column;background:#111d;color:#fff;position:fixed;',
    ...objNew(arrayMap([
        'bottom:0;left:0;width:35vw;height:100vh',
        'top:0;right:0;width:100vw;height:30vh',
        'bottom:0;left:0;width:100vw;height:30vh',
        'top:0;right:0;width:35vw;height:100vh',
        'top:0;right:0;width:100vw;height:100vh'
    ], (css, p)=>[
            `main[data-position='${p}']`,
            css
        ])),
    // Header
    header: 'display:flex;padding:0.25rem;background:#000;align-items:center',
    'header>img:nth-of-type(1)': LOGO_SVG,
    'header>img:nth-of-type(6)': CLOSE_SVG,
    ...objNew(arrayMap(POSITIONS_SVG, (SVG, p)=>[
            `header>img[data-id='${p}']`,
            SVG
        ])),
    'header>span': 'flex:1;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin-left:0.25rem',
    // Body
    article: 'padding:0.25rem 0.25rem 0.25rem 0.5rem;overflow:auto;flex:1',
    details: 'margin-left:0.75rem;width:fit-content;',
    'details img': 'display:none',
    'details[open]>summary img': 'display:unset;background:none;margin-left:0.25rem',
    'details[open]>summary img.edit': EDIT_SVG,
    'details[open]>summary img.done': DONE_SVG,
    summary: 'margin-left:-0.75rem;line-height:1.25rem;user-select:none;width:fit-content',
    // tables
    table: 'border-collapse:collapse;table-layout:fixed;margin-bottom:0.5rem',
    'table input': 'background:#111;color:unset;padding:0 0.25rem;border:0;font-size:unset;vertical-align:top;margin:0',
    'table input[type="number"]': 'width:4rem',
    'table tbody button': 'font-size:0;background:#fff;border-radius:50%;margin:0 0.125rem 0 0;width:0.85rem;color:#111',
    'table button:first-letter': 'font-size:0.75rem',
    thead: 'background:#222',
    'th:nth-of-type(1)': 'min-width:2rem;',
    'th.sorted': 'background:#000',
    'table caption': 'text-align:left;white-space:nowrap;line-height:1.25rem',
    button: 'width:1.5rem;border:none;background:none;color:#fff;padding:0',
    'button[disabled]': 'color:#777',
    'button.next': 'margin-right:0.5rem',
    [`th,#${UNIQUE_ID} td`]: 'overflow:hidden;text-overflow:ellipsis;padding:0.25rem 0.5rem;max-width:12rem;white-space:nowrap;border-width:1px 0;border-style:solid;border-color:#777;text-align:left',
    'span.warn': 'margin:0.25rem;color:#d81b60'
}, (style, selector)=>style ? `#${UNIQUE_ID} ${selector}{${style}}` : ''));
const Nub = ({ s })=>{
    const position = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useValue"])(POSITION_VALUE, s) ?? 1;
    const handleOpen = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetValueCallback"])(OPEN_VALUE, {
        "Nub.useSetValueCallback[handleOpen]": ()=>true
    }["Nub.useSetValueCallback[handleOpen]"], [], s);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useValue"])(OPEN_VALUE, s) ? null : /* @__PURE__ */ createElement('img', {
        onClick: handleOpen,
        title: TITLE,
        'data-position': position
    });
};
const Details = ({ uniqueId, summary, editable, handleEditable, children, s })=>{
    const open = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCell"])(STATE_TABLE, uniqueId, OPEN_CELL, s);
    const handleToggle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetCellCallback"])(STATE_TABLE, uniqueId, OPEN_CELL, {
        "Details.useSetCellCallback[handleToggle]": (event)=>event[CURRENT_TARGET].open
    }["Details.useSetCellCallback[handleToggle]"], [], s);
    return /* @__PURE__ */ createElement('details', {
        open,
        onToggle: handleToggle
    }, /* @__PURE__ */ createElement('summary', null, summary, handleEditable ? /* @__PURE__ */ createElement('img', {
        onClick: handleEditable,
        className: editable ? 'done' : 'edit'
    }) : null), children);
};
const getCellOrValueType = (cellOrValue)=>{
    const type = getTypeOf(cellOrValue);
    return isTypeStringOrBoolean(type) || type == NUMBER && isFiniteNumber(cellOrValue) ? type : void 0;
};
const setOrDelCell = (store, tableId, rowId, cellId, cell)=>isUndefined(cell) ? store.delCell(tableId, rowId, cellId, true) : store.setCell(tableId, rowId, cellId, cell);
const setOrDelValue = (store, valueId, value)=>isUndefined(value) ? store.delValue(valueId) : store.setValue(valueId, value);
const getTypeCase = (type, stringCase, numberCase, booleanCase)=>type == STRING ? stringCase : type == NUMBER ? numberCase : booleanCase;
const DOT = '.';
const EDITABLE = 'editable';
const LEFT_ARROW = '\u2190';
const UP_ARROW = '\u2191';
const RIGHT_ARROW = '\u2192';
const DOWN_ARROW = '\u2193';
const useDottedCellIds = (tableId, store)=>arrayMap((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useTableCellIds"])(tableId, store), (cellId)=>tableId + DOT + cellId);
const useCallbackOrUndefined = (callback, deps, test)=>{
    const returnCallback = useCallback(callback, deps);
    return test ? returnCallback : void 0;
};
const useParams = (...args)=>useMemo({
        "useParams.useMemo": ()=>args
    }["useParams.useMemo"], // eslint-disable-next-line react-hooks/exhaustive-deps
    args);
const useStoreCellComponentProps = (store, tableId)=>useMemo({
        "useStoreCellComponentProps.useMemo": ()=>({
                store,
                tableId
            })
    }["useStoreCellComponentProps.useMemo"], [
        store,
        tableId
    ]);
const useQueriesCellComponentProps = (queries, queryId)=>useMemo({
        "useQueriesCellComponentProps.useMemo": ()=>({
                queries,
                queryId
            })
    }["useQueriesCellComponentProps.useMemo"], [
        queries,
        queryId
    ]);
const useSortingAndPagination = (cellId, descending = false, sortOnClick, offset = 0, limit, total, paginator, onChange)=>{
    const [[currentCellId, currentDescending, currentOffset], setState] = useState([
        cellId,
        descending,
        offset
    ]);
    const setStateAndChange = useCallback({
        "useSortingAndPagination.useCallback[setStateAndChange]": (sortAndOffset)=>{
            setState(sortAndOffset);
            onChange?.(sortAndOffset);
        }
    }["useSortingAndPagination.useCallback[setStateAndChange]"], [
        onChange
    ]);
    const handleSort = useCallbackOrUndefined({
        "useSortingAndPagination.useCallbackOrUndefined[handleSort]": (cellId2)=>setStateAndChange([
                cellId2,
                cellId2 == currentCellId ? !currentDescending : false,
                currentOffset
            ])
    }["useSortingAndPagination.useCallbackOrUndefined[handleSort]"], [
        setStateAndChange,
        currentCellId,
        currentDescending,
        currentOffset
    ], sortOnClick);
    const handleChangeOffset = useCallback({
        "useSortingAndPagination.useCallback[handleChangeOffset]": (offset2)=>setStateAndChange([
                currentCellId,
                currentDescending,
                offset2
            ])
    }["useSortingAndPagination.useCallback[handleChangeOffset]"], [
        setStateAndChange,
        currentCellId,
        currentDescending
    ]);
    const PaginatorComponent = paginator === true ? SortedTablePaginator : paginator;
    return [
        [
            currentCellId,
            currentDescending,
            currentOffset
        ],
        handleSort,
        useMemo({
            "useSortingAndPagination.useMemo": ()=>paginator === false ? null : /* @__PURE__ */ createElement(PaginatorComponent, {
                    offset: currentOffset,
                    limit,
                    total,
                    onChange: handleChangeOffset
                })
        }["useSortingAndPagination.useMemo"], [
            paginator,
            PaginatorComponent,
            currentOffset,
            limit,
            total,
            handleChangeOffset
        ])
    ];
};
const useCells = (defaultCellIds, customCells, defaultCellComponent)=>useMemo({
        "useCells.useMemo": ()=>{
            const cellIds = customCells ?? defaultCellIds;
            return objMap(isArray(cellIds) ? objNew(arrayMap(cellIds, {
                "useCells.useMemo": (cellId)=>[
                        cellId,
                        cellId
                    ]
            }["useCells.useMemo"])) : cellIds, {
                "useCells.useMemo": (labelOrCustomCell, cellId)=>({
                        ...{
                            label: cellId,
                            component: defaultCellComponent
                        },
                        ...isString(labelOrCustomCell) ? {
                            label: labelOrCustomCell
                        } : labelOrCustomCell
                    })
            }["useCells.useMemo"]);
        }
    }["useCells.useMemo"], [
        customCells,
        defaultCellComponent,
        defaultCellIds
    ]);
const HtmlTable = ({ className, headerRow, idColumn, params: [cells, cellComponentProps, rowIds, sortAndOffset, handleSort, paginatorComponent] })=>/* @__PURE__ */ createElement('table', {
        className
    }, paginatorComponent ? /* @__PURE__ */ createElement('caption', null, paginatorComponent) : null, headerRow === false ? null : /* @__PURE__ */ createElement('thead', null, /* @__PURE__ */ createElement('tr', null, idColumn === false ? null : /* @__PURE__ */ createElement(HtmlHeaderCell, {
        sort: sortAndOffset ?? [],
        label: 'Id',
        onClick: handleSort
    }), objToArray(cells, ({ label }, cellId)=>/* @__PURE__ */ createElement(HtmlHeaderCell, {
            key: cellId,
            cellId,
            label,
            sort: sortAndOffset ?? [],
            onClick: handleSort
        })))), /* @__PURE__ */ createElement('tbody', null, arrayMap(rowIds, (rowId)=>/* @__PURE__ */ createElement('tr', {
            key: rowId
        }, idColumn === false ? null : /* @__PURE__ */ createElement('th', null, rowId), objToArray(cells, ({ component: CellView2, getComponentProps }, cellId)=>/* @__PURE__ */ createElement('td', {
                key: cellId
            }, /* @__PURE__ */ createElement(CellView2, {
                ...getProps(getComponentProps, rowId, cellId),
                ...cellComponentProps,
                rowId,
                cellId
            })))))));
const HtmlHeaderCell = ({ cellId, sort: [sortCellId, sortDescending], label = cellId ?? EMPTY_STRING, onClick })=>/* @__PURE__ */ createElement('th', {
        onClick: useCallbackOrUndefined({
            "HtmlHeaderCell.useCallbackOrUndefined": ()=>onClick?.(cellId)
        }["HtmlHeaderCell.useCallbackOrUndefined"], [
            onClick,
            cellId
        ], onClick),
        className: isUndefined(sortDescending) || sortCellId != cellId ? void 0 : `sorted ${sortDescending ? 'de' : 'a'}scending`
    }, isUndefined(sortDescending) || sortCellId != cellId ? null : (sortDescending ? DOWN_ARROW : UP_ARROW) + ' ', label);
const RelationshipInHtmlRow = ({ localRowId, params: [idColumn, cells, localTableId, remoteTableId, relationshipId, relationships, store] })=>{
    const remoteRowId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRemoteRowId"])(relationshipId, localRowId, relationships);
    return /* @__PURE__ */ createElement('tr', null, idColumn === false ? null : /* @__PURE__ */ createElement(Fragment, null, /* @__PURE__ */ createElement('th', null, localRowId), /* @__PURE__ */ createElement('th', null, remoteRowId)), objToArray(cells, ({ component: CellView2, getComponentProps }, compoundCellId)=>{
        const [tableId, cellId] = strSplit(compoundCellId, DOT, 2);
        const rowId = tableId === localTableId ? localRowId : tableId === remoteTableId ? remoteRowId : null;
        return isUndefined(rowId) ? null : /* @__PURE__ */ createElement('td', {
            key: compoundCellId
        }, /* @__PURE__ */ createElement(CellView2, {
            ...getProps(getComponentProps, rowId, cellId),
            store,
            tableId,
            rowId,
            cellId
        }));
    }));
};
const EditableThing = ({ thing, onThingChange, className, hasSchema, showType = true })=>{
    const [thingType, setThingType] = useState();
    const [currentThing, setCurrentThing] = useState();
    const [stringThing, setStringThing] = useState();
    const [numberThing, setNumberThing] = useState();
    const [booleanThing, setBooleanThing] = useState();
    if (currentThing !== thing) {
        setThingType(getCellOrValueType(thing));
        setCurrentThing(thing);
        setStringThing(String(thing));
        setNumberThing(Number(thing) || 0);
        setBooleanThing(Boolean(thing));
    }
    const handleThingChange = useCallback({
        "EditableThing.useCallback[handleThingChange]": (thing2, setTypedThing)=>{
            setTypedThing(thing2);
            setCurrentThing(thing2);
            onThingChange(thing2);
        }
    }["EditableThing.useCallback[handleThingChange]"], [
        onThingChange
    ]);
    const handleTypeChange = useCallback({
        "EditableThing.useCallback[handleTypeChange]": ()=>{
            if (!hasSchema?.()) {
                const nextType = getTypeCase(thingType, NUMBER, BOOLEAN, STRING);
                const thing2 = getTypeCase(nextType, stringThing, numberThing, booleanThing);
                setThingType(nextType);
                setCurrentThing(thing2);
                onThingChange(thing2);
            }
        }
    }["EditableThing.useCallback[handleTypeChange]"], [
        hasSchema,
        onThingChange,
        stringThing,
        numberThing,
        booleanThing,
        thingType
    ]);
    return /* @__PURE__ */ createElement('div', {
        className
    }, showType ? /* @__PURE__ */ createElement('button', {
        className: thingType,
        onClick: handleTypeChange
    }, thingType) : null, getTypeCase(thingType, /* @__PURE__ */ createElement('input', {
        key: thingType,
        value: stringThing,
        onChange: useCallback({
            "EditableThing.useCallback": (event)=>handleThingChange(String(event[CURRENT_TARGET][_VALUE]), setStringThing)
        }["EditableThing.useCallback"], [
            handleThingChange
        ])
    }), /* @__PURE__ */ createElement('input', {
        key: thingType,
        type: 'number',
        value: numberThing,
        onChange: useCallback({
            "EditableThing.useCallback": (event)=>handleThingChange(Number(event[CURRENT_TARGET][_VALUE] || 0), setNumberThing)
        }["EditableThing.useCallback"], [
            handleThingChange
        ])
    }), /* @__PURE__ */ createElement('input', {
        key: thingType,
        type: 'checkbox',
        checked: booleanThing,
        onChange: useCallback({
            "EditableThing.useCallback": (event)=>handleThingChange(Boolean(event[CURRENT_TARGET].checked), setBooleanThing)
        }["EditableThing.useCallback"], [
            handleThingChange
        ])
    })));
};
const SortedTableInHtmlTable = ({ tableId, cellId, descending, offset, limit, store, editable, sortOnClick, paginator = false, onChange, customCells, ...props })=>{
    const [sortAndOffset, handleSort, paginatorComponent] = useSortingAndPagination(cellId, descending, sortOnClick, offset, limit, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRowCount"])(tableId, store), paginator, onChange);
    return /* @__PURE__ */ createElement(HtmlTable, {
        ...props,
        params: useParams(useCells((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useTableCellIds"])(tableId, store), customCells, editable ? EditableCellView : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"]), useStoreCellComponentProps(store, tableId), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSortedRowIds"])(tableId, ...sortAndOffset, limit, store), sortAndOffset, handleSort, paginatorComponent)
    });
};
const ValuesInHtmlTable = ({ store, editable = false, valueComponent: Value = editable ? EditableValueView : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ValueView"], getValueComponentProps, className, headerRow, idColumn })=>/* @__PURE__ */ createElement('table', {
        className
    }, headerRow === false ? null : /* @__PURE__ */ createElement('thead', null, /* @__PURE__ */ createElement('tr', null, idColumn === false ? null : /* @__PURE__ */ createElement('th', null, 'Id'), /* @__PURE__ */ createElement('th', null, VALUE))), /* @__PURE__ */ createElement('tbody', null, arrayMap((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useValueIds"])(store), (valueId)=>/* @__PURE__ */ createElement('tr', {
            key: valueId
        }, idColumn === false ? null : /* @__PURE__ */ createElement('th', null, valueId), /* @__PURE__ */ createElement('td', null, /* @__PURE__ */ createElement(Value, {
            ...getProps(getValueComponentProps, valueId),
            valueId,
            store
        }))))));
const SliceInHtmlTable = ({ indexId, sliceId, indexes, editable, customCells, ...props })=>{
    const [resolvedIndexes, store, tableId] = getIndexStoreTableId((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useIndexesOrIndexesById"])(indexes), indexId);
    return /* @__PURE__ */ createElement(HtmlTable, {
        ...props,
        params: useParams(useCells((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useTableCellIds"])(tableId, store), customCells, editable ? EditableCellView : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"]), useStoreCellComponentProps(store, tableId), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSliceRowIds"])(indexId, sliceId, resolvedIndexes))
    });
};
const RelationshipInHtmlTable = ({ relationshipId, relationships, editable, customCells, className, headerRow, idColumn = true })=>{
    const [resolvedRelationships, store, localTableId, remoteTableId] = getRelationshipsStoreTableIds((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRelationshipsOrRelationshipsById"])(relationships), relationshipId);
    const cells = useCells([
        ...useDottedCellIds(localTableId, store),
        ...useDottedCellIds(remoteTableId, store)
    ], customCells, editable ? EditableCellView : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"]);
    const params = useParams(idColumn, cells, localTableId, remoteTableId, relationshipId, resolvedRelationships, store);
    return /* @__PURE__ */ createElement('table', {
        className
    }, headerRow === false ? null : /* @__PURE__ */ createElement('thead', null, /* @__PURE__ */ createElement('tr', null, idColumn === false ? null : /* @__PURE__ */ createElement(Fragment, null, /* @__PURE__ */ createElement('th', null, localTableId, '.Id'), /* @__PURE__ */ createElement('th', null, remoteTableId, '.Id')), objToArray(cells, ({ label }, cellId)=>/* @__PURE__ */ createElement('th', {
            key: cellId
        }, label)))), /* @__PURE__ */ createElement('tbody', null, arrayMap((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRowIds"])(localTableId, store), (localRowId)=>/* @__PURE__ */ createElement(RelationshipInHtmlRow, {
            key: localRowId,
            localRowId,
            params
        }))));
};
const ResultSortedTableInHtmlTable = ({ queryId, cellId, descending, offset, limit, queries, sortOnClick, paginator = false, customCells, onChange, ...props })=>{
    const [sortAndOffset, handleSort, paginatorComponent] = useSortingAndPagination(cellId, descending, sortOnClick, offset, limit, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useResultRowCount"])(queryId, queries), paginator, onChange);
    return /* @__PURE__ */ createElement(HtmlTable, {
        ...props,
        params: useParams(useCells((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useResultTableCellIds"])(queryId, queries), customCells, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResultCellView"]), useQueriesCellComponentProps(queries, queryId), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useResultSortedRowIds"])(queryId, ...sortAndOffset, limit, queries), sortAndOffset, handleSort, paginatorComponent)
    });
};
const EditableCellView = ({ tableId, rowId, cellId, store, className, showType })=>/* @__PURE__ */ createElement(EditableThing, {
        thing: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCell"])(tableId, rowId, cellId, store),
        onThingChange: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetCellCallback"])(tableId, rowId, cellId, {
            "EditableCellView.useSetCellCallback": (cell)=>cell
        }["EditableCellView.useSetCellCallback"], [], store),
        className: className ?? EDITABLE + CELL,
        showType,
        hasSchema: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useStoreOrStoreById"])(store)?.hasTablesSchema
    });
const EditableValueView = ({ valueId, store, className, showType })=>/* @__PURE__ */ createElement(EditableThing, {
        thing: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useValue"])(valueId, store),
        onThingChange: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetValueCallback"])(valueId, {
            "EditableValueView.useSetValueCallback": (value)=>value
        }["EditableValueView.useSetValueCallback"], [], store),
        className: className ?? EDITABLE + VALUE,
        showType,
        hasSchema: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useStoreOrStoreById"])(store)?.hasValuesSchema
    });
const SortedTablePaginator = ({ onChange, total, offset = 0, limit = total, singular = 'row', plural = singular + 's' })=>{
    if (offset > total || offset < 0) {
        offset = 0;
        onChange(0);
    }
    const handlePrevClick = useCallbackOrUndefined({
        "SortedTablePaginator.useCallbackOrUndefined[handlePrevClick]": ()=>onChange(offset - limit)
    }["SortedTablePaginator.useCallbackOrUndefined[handlePrevClick]"], [
        onChange,
        offset,
        limit
    ], offset > 0);
    const handleNextClick = useCallbackOrUndefined({
        "SortedTablePaginator.useCallbackOrUndefined[handleNextClick]": ()=>onChange(offset + limit)
    }["SortedTablePaginator.useCallbackOrUndefined[handleNextClick]"], [
        onChange,
        offset,
        limit
    ], offset + limit < total);
    return /* @__PURE__ */ createElement(Fragment, null, total > limit && /* @__PURE__ */ createElement(Fragment, null, /* @__PURE__ */ createElement('button', {
        className: 'previous',
        disabled: offset == 0,
        onClick: handlePrevClick
    }, LEFT_ARROW), /* @__PURE__ */ createElement('button', {
        className: 'next',
        disabled: offset + limit >= total,
        onClick: handleNextClick
    }, RIGHT_ARROW), offset + 1, ' to ', mathMin(total, offset + limit), ' of '), total, ' ', total != 1 ? plural : singular);
};
const IndexView = ({ indexes, indexesId, indexId, s })=>/* @__PURE__ */ createElement(Details, {
        uniqueId: getUniqueId('i', indexesId, indexId),
        summary: 'Index: ' + indexId,
        s
    }, arrayMap((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSliceIds"])(indexId, indexes), (sliceId)=>/* @__PURE__ */ createElement(SliceView, {
            indexes,
            indexesId,
            indexId,
            sliceId,
            s,
            key: sliceId
        })));
const SliceView = ({ indexes, indexesId, indexId, sliceId, s })=>{
    const uniqueId = getUniqueId('i', indexesId, indexId, sliceId);
    const [editable, handleEditable] = useEditable(uniqueId, s);
    return /* @__PURE__ */ createElement(Details, {
        uniqueId,
        summary: 'Slice: ' + sliceId,
        editable,
        handleEditable,
        s
    }, /* @__PURE__ */ createElement(SliceInHtmlTable, {
        sliceId,
        indexId,
        indexes,
        editable
    }));
};
const IndexesView = ({ indexesId, s })=>{
    const indexes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useIndexes"])(indexesId);
    const indexIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useIndexIds"])(indexes);
    return isUndefined(indexes) ? null : /* @__PURE__ */ createElement(Details, {
        uniqueId: getUniqueId('i', indexesId),
        summary: 'Indexes: ' + (indexesId ?? DEFAULT),
        s
    }, arrayIsEmpty(indexIds) ? 'No indexes defined' : sortedIdsMap(indexIds, (indexId)=>/* @__PURE__ */ createElement(IndexView, {
            indexes,
            indexesId,
            indexId,
            s,
            key: indexId
        })));
};
const MetricRow = ({ metrics, metricId })=>/* @__PURE__ */ createElement('tr', null, /* @__PURE__ */ createElement('th', null, metricId), /* @__PURE__ */ createElement('td', null, metrics?.getTableId(metricId)), /* @__PURE__ */ createElement('td', null, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMetric"])(metricId, metrics)));
const MetricsView = ({ metricsId, s })=>{
    const metrics = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMetrics"])(metricsId);
    const metricIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMetricIds"])(metrics);
    return isUndefined(metrics) ? null : /* @__PURE__ */ createElement(Details, {
        uniqueId: getUniqueId('m', metricsId),
        summary: 'Metrics: ' + (metricsId ?? DEFAULT),
        s
    }, arrayIsEmpty(metricIds) ? 'No metrics defined' : /* @__PURE__ */ createElement('table', null, /* @__PURE__ */ createElement('thead', null, /* @__PURE__ */ createElement('th', null, 'Metric Id'), /* @__PURE__ */ createElement('th', null, 'Table Id'), /* @__PURE__ */ createElement('th', null, 'Metric')), /* @__PURE__ */ createElement('tbody', null, arrayMap(metricIds, (metricId)=>/* @__PURE__ */ createElement(MetricRow, {
            metrics,
            metricId,
            key: metricId
        })))));
};
const QueryView = ({ queries, queriesId, queryId, s })=>{
    const uniqueId = getUniqueId('q', queriesId, queryId);
    const [cellId, descending, offset] = jsonParse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCell"])(STATE_TABLE, uniqueId, SORT_CELL, s) ?? '[]');
    const handleChange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetCellCallback"])(STATE_TABLE, uniqueId, SORT_CELL, jsonStringWithMap, [], s);
    return /* @__PURE__ */ createElement(Details, {
        uniqueId,
        summary: 'Query: ' + queryId,
        s
    }, /* @__PURE__ */ createElement(ResultSortedTableInHtmlTable, {
        queryId,
        queries,
        cellId,
        descending,
        offset,
        limit: 10,
        paginator: true,
        sortOnClick: true,
        onChange: handleChange
    }));
};
const QueriesView = ({ queriesId, s })=>{
    const queries = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueries"])(queriesId);
    const queryIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryIds"])(queries);
    return isUndefined(queries) ? null : /* @__PURE__ */ createElement(Details, {
        uniqueId: getUniqueId('q', queriesId),
        summary: 'Queries: ' + (queriesId ?? DEFAULT),
        s
    }, arrayIsEmpty(queryIds) ? 'No queries defined' : sortedIdsMap(queryIds, (queryId)=>/* @__PURE__ */ createElement(QueryView, {
            queries,
            queriesId,
            queryId,
            s,
            key: queryId
        })));
};
const RelationshipView = ({ relationships, relationshipsId, relationshipId, s })=>{
    const uniqueId = getUniqueId('r', relationshipsId, relationshipId);
    const [editable, handleEditable] = useEditable(uniqueId, s);
    return /* @__PURE__ */ createElement(Details, {
        uniqueId,
        summary: 'Relationship: ' + relationshipId,
        editable,
        handleEditable,
        s
    }, /* @__PURE__ */ createElement(RelationshipInHtmlTable, {
        relationshipId,
        relationships,
        editable
    }));
};
const RelationshipsView = ({ relationshipsId, s })=>{
    const relationships = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRelationships"])(relationshipsId);
    const relationshipIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRelationshipIds"])(relationships);
    return isUndefined(relationships) ? null : /* @__PURE__ */ createElement(Details, {
        uniqueId: getUniqueId('r', relationshipsId),
        summary: 'Relationships: ' + (relationshipsId ?? DEFAULT),
        s
    }, arrayIsEmpty(relationshipIds) ? 'No relationships defined' : sortedIdsMap(relationshipIds, (relationshipId)=>/* @__PURE__ */ createElement(RelationshipView, {
            relationships,
            relationshipsId,
            relationshipId,
            s,
            key: relationshipId
        })));
};
const TableView = ({ tableId, store, storeId, s })=>{
    const uniqueId = getUniqueId('t', storeId, tableId);
    const [cellId, descending, offset] = jsonParse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCell"])(STATE_TABLE, uniqueId, SORT_CELL, s) ?? '[]');
    const handleChange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetCellCallback"])(STATE_TABLE, uniqueId, SORT_CELL, jsonStringWithMap, [], s);
    const [editable, handleEditable] = useEditable(uniqueId, s);
    return /* @__PURE__ */ createElement(Details, {
        uniqueId,
        summary: TABLE + ': ' + tableId,
        editable,
        handleEditable,
        s
    }, /* @__PURE__ */ createElement(SortedTableInHtmlTable, {
        tableId,
        store,
        cellId,
        descending,
        offset,
        limit: 10,
        paginator: true,
        sortOnClick: true,
        onChange: handleChange,
        editable
    }));
};
const ValuesView = ({ store, storeId, s })=>{
    const uniqueId = getUniqueId('v', storeId);
    const [editable, handleEditable] = useEditable(uniqueId, s);
    return arrayIsEmpty((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useValueIds"])(store)) ? null : /* @__PURE__ */ createElement(Details, {
        uniqueId,
        summary: VALUES,
        editable,
        handleEditable,
        s
    }, /* @__PURE__ */ createElement(ValuesInHtmlTable, {
        store,
        editable
    }));
};
const StoreView = ({ storeId, s })=>{
    const store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useStore"])(storeId);
    const tableIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useTableIds"])(store);
    return isUndefined(store) ? null : /* @__PURE__ */ createElement(Details, {
        uniqueId: getUniqueId('s', storeId),
        summary: (store.isMergeable() ? 'Mergeable' : '') + 'Store: ' + (storeId ?? DEFAULT),
        s
    }, /* @__PURE__ */ createElement(ValuesView, {
        storeId,
        store,
        s
    }), sortedIdsMap(tableIds, (tableId)=>/* @__PURE__ */ createElement(TableView, {
            store,
            storeId,
            tableId,
            s,
            key: tableId
        })));
};
const Body = ({ s })=>{
    const articleRef = useRef(null);
    const idleCallbackRef = useRef(0);
    const [scrolled, setScrolled] = useState(false);
    const { scrollLeft, scrollTop } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useValues"])(s);
    useLayoutEffect({
        "Body.useLayoutEffect": ()=>{
            const article = articleRef.current;
            if (article && !scrolled) {
                const observer = new MutationObserver({
                    "Body.useLayoutEffect": ()=>{
                        if (article.scrollWidth >= mathFloor(scrollLeft) + article.clientWidth && article.scrollHeight >= mathFloor(scrollTop) + article.clientHeight) {
                            article.scrollTo(scrollLeft, scrollTop);
                        }
                    }
                }["Body.useLayoutEffect"]);
                observer.observe(article, {
                    childList: true,
                    subtree: true
                });
                return ({
                    "Body.useLayoutEffect": ()=>observer.disconnect()
                })["Body.useLayoutEffect"];
            }
        }
    }["Body.useLayoutEffect"], [
        scrolled,
        scrollLeft,
        scrollTop
    ]);
    const handleScroll = useCallback({
        "Body.useCallback[handleScroll]": (event)=>{
            const { scrollLeft: scrollLeft2, scrollTop: scrollTop2 } = event[CURRENT_TARGET];
            cancelIdleCallback(idleCallbackRef.current);
            idleCallbackRef.current = requestIdleCallback({
                "Body.useCallback[handleScroll]": ()=>{
                    setScrolled(true);
                    s.setPartialValues({
                        scrollLeft: scrollLeft2,
                        scrollTop: scrollTop2
                    });
                }
            }["Body.useCallback[handleScroll]"]);
        }
    }["Body.useCallback[handleScroll]"], [
        s
    ]);
    const store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useStore"])();
    const storeIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useStoreIds"])();
    const metrics = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMetrics"])();
    const metricsIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMetricsIds"])();
    const indexes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useIndexes"])();
    const indexesIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useIndexesIds"])();
    const relationships = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRelationships"])();
    const relationshipsIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRelationshipsIds"])();
    const queries = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueries"])();
    const queriesIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueriesIds"])();
    return isUndefined(store) && arrayIsEmpty(storeIds) && isUndefined(metrics) && arrayIsEmpty(metricsIds) && isUndefined(indexes) && arrayIsEmpty(indexesIds) && isUndefined(relationships) && arrayIsEmpty(relationshipsIds) && isUndefined(queries) && arrayIsEmpty(queriesIds) ? /* @__PURE__ */ createElement('span', {
        className: 'warn'
    }, 'There are no Stores or other objects to inspect. Make sure you placed the Inspector inside a Provider component.') : /* @__PURE__ */ createElement('article', {
        ref: articleRef,
        onScroll: handleScroll
    }, /* @__PURE__ */ createElement(StoreView, {
        s
    }), arrayMap(storeIds, (storeId)=>/* @__PURE__ */ createElement(StoreView, {
            storeId,
            s,
            key: storeId
        })), /* @__PURE__ */ createElement(MetricsView, {
        s
    }), arrayMap(metricsIds, (metricsId)=>/* @__PURE__ */ createElement(MetricsView, {
            metricsId,
            s,
            key: metricsId
        })), /* @__PURE__ */ createElement(IndexesView, {
        s
    }), arrayMap(indexesIds, (indexesId)=>/* @__PURE__ */ createElement(IndexesView, {
            indexesId,
            s,
            key: indexesId
        })), /* @__PURE__ */ createElement(RelationshipsView, {
        s
    }), arrayMap(relationshipsIds, (relationshipsId)=>/* @__PURE__ */ createElement(RelationshipsView, {
            relationshipsId,
            s,
            key: relationshipsId
        })), /* @__PURE__ */ createElement(QueriesView, {
        s
    }), arrayMap(queriesIds, (queriesId)=>/* @__PURE__ */ createElement(QueriesView, {
            queriesId,
            s,
            key: queriesId
        })));
};
class ErrorBoundary extends PureComponent {
    constructor(props){
        super(props);
        this.state = {
            e: 0
        };
    }
    static getDerivedStateFromError() {
        return {
            e: 1
        };
    }
    // eslint-disable-next-line react/no-arrow-function-lifecycle
    componentDidCatch = (error, info)=>// eslint-disable-next-line no-console
        console.error(error, info.componentStack);
    render() {
        return this.state.e ? /* @__PURE__ */ createElement('span', {
            className: 'warn'
        }, 'Inspector error: please see console for details.') : this.props.children;
    }
}
const Header = ({ s })=>{
    const position = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useValue"])(POSITION_VALUE, s) ?? 1;
    const handleClose = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetValueCallback"])(OPEN_VALUE, {
        "Header.useSetValueCallback[handleClose]": ()=>false
    }["Header.useSetValueCallback[handleClose]"], [], s);
    const handleDock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetValueCallback"])(POSITION_VALUE, {
        "Header.useSetValueCallback[handleDock]": (event)=>Number(event[CURRENT_TARGET].dataset.id)
    }["Header.useSetValueCallback[handleDock]"], [], s);
    return /* @__PURE__ */ createElement('header', null, /* @__PURE__ */ createElement('img', {
        title: TITLE
    }), /* @__PURE__ */ createElement('span', null, TITLE), arrayMap(POSITIONS, (name, p)=>p == position ? null : /* @__PURE__ */ createElement('img', {
            onClick: handleDock,
            'data-id': p,
            title: 'Dock to ' + name,
            key: p
        })), /* @__PURE__ */ createElement('img', {
        onClick: handleClose,
        title: 'Close'
    }));
};
const Panel = ({ s })=>{
    const position = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useValue"])(POSITION_VALUE, s) ?? 1;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useValue"])(OPEN_VALUE, s) ? /* @__PURE__ */ createElement('main', {
        'data-position': position
    }, /* @__PURE__ */ createElement(Header, {
        s
    }), /* @__PURE__ */ createElement(ErrorBoundary, null, /* @__PURE__ */ createElement(Body, {
        s
    }))) : null;
};
const collSizeN = (collSizer)=>(coll)=>arrayReduce(collValues(coll), (total, coll2)=>total + collSizer(coll2), 0);
const collSize = (coll)=>coll?.size ?? 0;
const collSize2 = collSizeN(collSize);
const collSize3 = collSizeN(collSize2);
const collSize4 = collSizeN(collSize3);
const collHas = (coll, keyOrValue)=>coll?.has(keyOrValue) ?? false;
const collIsEmpty = (coll)=>isUndefined(coll) || collSize(coll) == 0;
const collValues = (coll)=>[
        ...coll?.values() ?? []
    ];
const collClear = (coll)=>coll.clear();
const collForEach = (coll, cb)=>coll?.forEach(cb);
const collDel = (coll, keyOrValue)=>coll?.delete(keyOrValue);
const mapNew = (entries)=>new Map(entries);
const mapKeys = (map)=>[
        ...map?.keys() ?? []
    ];
const mapGet = (map, key)=>map?.get(key);
const mapForEach = (map, cb)=>collForEach(map, (value, key)=>cb(key, value));
const mapMap = (coll, cb)=>arrayMap([
        ...coll?.entries() ?? []
    ], ([key, value])=>cb(value, key));
const mapSet = (map, key, value)=>isUndefined(value) ? (collDel(map, key), map) : map?.set(key, value);
const mapEnsure = (map, key, getDefaultValue, hadExistingValue)=>{
    if (!collHas(map, key)) {
        mapSet(map, key, getDefaultValue());
    } else {
        hadExistingValue?.(mapGet(map, key));
    }
    return mapGet(map, key);
};
const mapMatch = (map, obj, set, del = mapSet)=>{
    objMap(obj, (value, id)=>set(map, id, value));
    mapForEach(map, (id)=>objHas(obj, id) ? 0 : del(map, id));
    return map;
};
const mapToObj = (map, valueMapper, excludeMapValue, excludeObjValue)=>{
    const obj = {};
    collForEach(map, (mapValue, id)=>{
        if (!excludeMapValue?.(mapValue, id)) {
            const objValue = valueMapper ? valueMapper(mapValue, id) : mapValue;
            if (!excludeObjValue?.(objValue)) {
                obj[id] = objValue;
            }
        }
    });
    return obj;
};
const mapToObj2 = (map, valueMapper, excludeMapValue)=>mapToObj(map, (childMap)=>mapToObj(childMap, valueMapper, excludeMapValue), collIsEmpty, objIsEmpty);
const mapToObj3 = (map, valueMapper, excludeMapValue)=>mapToObj(map, (childMap)=>mapToObj2(childMap, valueMapper, excludeMapValue), collIsEmpty, objIsEmpty);
const mapClone = (map, mapValue)=>{
    const map2 = mapNew();
    collForEach(map, (value, key)=>map2.set(key, mapValue?.(value) ?? value));
    return map2;
};
const mapClone2 = (map)=>mapClone(map, mapClone);
const mapClone3 = (map)=>mapClone(map, mapClone2);
const visitTree = (node, path, ensureLeaf, pruneLeaf, p = 0)=>ifNotUndefined((ensureLeaf ? mapEnsure : mapGet)(node, path[p], p > size(path) - 2 ? ensureLeaf : mapNew), (nodeOrLeaf)=>{
        if (p > size(path) - 2) {
            if (pruneLeaf?.(nodeOrLeaf)) {
                mapSet(node, path[p]);
            }
            return nodeOrLeaf;
        }
        const leaf = visitTree(nodeOrLeaf, path, ensureLeaf, pruneLeaf, p + 1);
        if (collIsEmpty(nodeOrLeaf)) {
            mapSet(node, path[p]);
        }
        return leaf;
    });
const setNew = (entryOrEntries)=>new Set(isArray(entryOrEntries) || isUndefined(entryOrEntries) ? entryOrEntries : [
        entryOrEntries
    ]);
const setAdd = (set, value)=>set?.add(value);
const INTEGER = /^\d+$/;
const getPoolFunctions = ()=>{
    const pool = [];
    let nextId = 0;
    return [
        (reuse)=>(reuse ? arrayShift(pool) : null) ?? EMPTY_STRING + nextId++,
        (id)=>{
            if (test(INTEGER, id) && size(pool) < 1e3) {
                arrayPush(pool, id);
            }
        }
    ];
};
const getWildcardedLeaves = (deepIdSet, path = [
    EMPTY_STRING
])=>{
    const leaves = [];
    const deep = (node, p)=>p == size(path) ? arrayPush(leaves, node) : path[p] === null ? collForEach(node, (node2)=>deep(node2, p + 1)) : arrayForEach([
            path[p],
            null
        ], (id)=>deep(mapGet(node, id), p + 1));
    deep(deepIdSet, 0);
    return leaves;
};
const getListenerFunctions = (getThing)=>{
    let thing;
    const [getId, releaseId] = getPoolFunctions();
    const allListeners = mapNew();
    const addListener = (listener, idSetNode, path, pathGetters = [], extraArgsGetter = ()=>[])=>{
        thing ??= getThing();
        const id = getId(1);
        mapSet(allListeners, id, [
            listener,
            idSetNode,
            path,
            pathGetters,
            extraArgsGetter
        ]);
        setAdd(visitTree(idSetNode, path ?? [
            EMPTY_STRING
        ], setNew), id);
        return id;
    };
    const callListeners = (idSetNode, ids, ...extraArgs)=>arrayForEach(getWildcardedLeaves(idSetNode, ids), (set)=>collForEach(set, (id)=>mapGet(allListeners, id)[0](thing, ...ids ?? [], ...extraArgs)));
    const delListener = (id)=>ifNotUndefined(mapGet(allListeners, id), ([, idSetNode, idOrNulls])=>{
            visitTree(idSetNode, idOrNulls ?? [
                EMPTY_STRING
            ], void 0, (idSet)=>{
                collDel(idSet, id);
                return collIsEmpty(idSet) ? 1 : 0;
            });
            mapSet(allListeners, id);
            releaseId(id);
            return idOrNulls;
        });
    const callListener = (id)=>ifNotUndefined(mapGet(allListeners, id), ([listener, , path = [], pathGetters, extraArgsGetter])=>{
            const callWithIds = (...ids)=>{
                const index = size(ids);
                if (index == size(path)) {
                    listener(thing, ...ids, ...extraArgsGetter(ids));
                } else if (isUndefined(path[index])) {
                    arrayForEach(pathGetters[index]?.(...ids) ?? [], (id2)=>callWithIds(...ids, id2));
                } else {
                    callWithIds(...ids, path[index]);
                }
            };
            callWithIds();
        });
    return [
        addListener,
        callListeners,
        delListener,
        callListener
    ];
};
const scheduleRunning = mapNew();
const scheduleActions = mapNew();
const getStoreFunctions = (persist = 1 /* StoreOnly */ , store, isSynchronizer)=>persist != 1 /* StoreOnly */  && store.isMergeable() ? [
        1,
        store.getMergeableContent,
        ()=>store.getTransactionMergeableChanges(!isSynchronizer),
        ([[changedTables], [changedValues]])=>!objIsEmpty(changedTables) || !objIsEmpty(changedValues),
        store.setDefaultContent
    ] : persist != 2 /* MergeableStoreOnly */  ? [
        0,
        store.getContent,
        store.getTransactionChanges,
        ([changedTables, changedValues])=>!objIsEmpty(changedTables) || !objIsEmpty(changedValues),
        store.setContent
    ] : errorNew('Store type not supported by this Persister');
const createCustomPersister = (store, getPersisted, setPersisted, addPersisterListener, delPersisterListener, onIgnoredError, persist, extra = {}, isSynchronizer = 0, scheduleId = [])=>{
    let status = 0; /* Idle */ 
    let loads = 0;
    let saves = 0;
    let action;
    let autoLoadHandle;
    let autoSaveListenerId;
    mapEnsure(scheduleRunning, scheduleId, ()=>0);
    mapEnsure(scheduleActions, scheduleId, ()=>[]);
    const statusListeners = mapNew();
    const [isMergeableStore, getContent, getChanges, hasChanges, setDefaultContent] = getStoreFunctions(persist, store, isSynchronizer);
    const [addListener, callListeners, delListenerImpl] = getListenerFunctions(()=>persister);
    const setStatus = (newStatus)=>{
        if (newStatus != status) {
            status = newStatus;
            callListeners(statusListeners, void 0, status);
        }
    };
    const run = async ()=>{
        /* istanbul ignore else */ if (!mapGet(scheduleRunning, scheduleId)) {
            mapSet(scheduleRunning, scheduleId, 1);
            while(!isUndefined(action = arrayShift(mapGet(scheduleActions, scheduleId)))){
                try {
                    await action();
                } catch (error) {}
            }
            mapSet(scheduleRunning, scheduleId, 0);
        }
    };
    const setContentOrChanges = (contentOrChanges)=>{
        (isMergeableStore && isArray(contentOrChanges?.[0]) ? contentOrChanges?.[2] === 1 ? store.applyMergeableChanges : store.setMergeableContent : contentOrChanges?.[2] === 1 ? store.applyChanges : store.setContent)(contentOrChanges);
    };
    const load = async (initialContent)=>{
        /* istanbul ignore else */ if (status != 2 /* Saving */ ) {
            setStatus(1 /* Loading */ );
            loads++;
            await schedule(async ()=>{
                try {
                    const content = await getPersisted();
                    if (isArray(content)) {
                        setContentOrChanges(content);
                    } else if (initialContent) {
                        setDefaultContent(initialContent);
                    } else {
                        errorNew(`Content is not an array: ${content}`);
                    }
                } catch (error) {
                    if (initialContent) {
                        setDefaultContent(initialContent);
                    }
                }
                setStatus(0 /* Idle */ );
            });
        }
        return persister;
    };
    const startAutoLoad = async (initialContent)=>{
        stopAutoLoad();
        await load(initialContent);
        try {
            autoLoadHandle = await addPersisterListener(async (content, changes)=>{
                if (changes || content) {
                    /* istanbul ignore else */ if (status != 2 /* Saving */ ) {
                        setStatus(1 /* Loading */ );
                        loads++;
                        setContentOrChanges(changes ?? content);
                        setStatus(0 /* Idle */ );
                    }
                } else {
                    await load();
                }
            });
        } catch (error) {}
        return persister;
    };
    const stopAutoLoad = ()=>{
        if (autoLoadHandle) {
            delPersisterListener(autoLoadHandle);
            autoLoadHandle = void 0;
        }
        return persister;
    };
    const isAutoLoading = ()=>!isUndefined(autoLoadHandle);
    const save = async (changes)=>{
        /* istanbul ignore else */ if (status != 1 /* Loading */ ) {
            setStatus(2 /* Saving */ );
            saves++;
            await schedule(async ()=>{
                try {
                    await setPersisted(getContent, changes);
                } catch (error) {}
                setStatus(0 /* Idle */ );
            });
        }
        return persister;
    };
    const startAutoSave = async ()=>{
        stopAutoSave();
        await save();
        autoSaveListenerId = store.addDidFinishTransactionListener(()=>{
            const changes = getChanges();
            if (hasChanges(changes)) {
                save(changes);
            }
        });
        return persister;
    };
    const stopAutoSave = ()=>{
        if (autoSaveListenerId) {
            store.delListener(autoSaveListenerId);
            autoSaveListenerId = void 0;
        }
        return persister;
    };
    const isAutoSaving = ()=>!isUndefined(autoSaveListenerId);
    const getStatus = ()=>status;
    const addStatusListener = (listener)=>addListener(listener, statusListeners);
    const delListener = (listenerId)=>{
        delListenerImpl(listenerId);
        return store;
    };
    const schedule = async (...actions)=>{
        arrayPush(mapGet(scheduleActions, scheduleId), ...actions);
        await run();
        return persister;
    };
    const getStore = ()=>store;
    const destroy = ()=>{
        arrayClear(mapGet(scheduleActions, scheduleId));
        return stopAutoLoad().stopAutoSave();
    };
    const getStats = ()=>({
            loads,
            saves
        });
    const persister = {
        load,
        startAutoLoad,
        stopAutoLoad,
        isAutoLoading,
        save,
        startAutoSave,
        stopAutoSave,
        isAutoSaving,
        getStatus,
        addStatusListener,
        delListener,
        schedule,
        getStore,
        destroy,
        getStats,
        ...extra
    };
    return objFreeze(persister);
};
const STORAGE = 'storage';
const createStoragePersister = (store, storageName, storage, onIgnoredError)=>{
    const getPersisted = async ()=>jsonParseWithUndefined(storage.getItem(storageName));
    const setPersisted = async (getContent)=>storage.setItem(storageName, jsonStringWithUndefined(getContent()));
    const addPersisterListener = (listener)=>{
        const storageListener = (event)=>{
            if (event.storageArea === storage && event.key === storageName) {
                try {
                    listener(jsonParse(event.newValue));
                } catch  {
                    listener();
                }
            }
        };
        WINDOW.addEventListener(STORAGE, storageListener);
        return storageListener;
    };
    const delPersisterListener = (storageListener)=>WINDOW.removeEventListener(STORAGE, storageListener);
    return createCustomPersister(store, getPersisted, setPersisted, addPersisterListener, delPersisterListener, onIgnoredError, 3, // StoreOrMergeableStore,
    {
        getStorageName: ()=>storageName
    });
};
const createSessionPersister = (store, storageName, onIgnoredError)=>createStoragePersister(store, storageName, sessionStorage, onIgnoredError);
const pairNew = (value)=>[
        value,
        value
    ];
const pairCollSize2 = (pair, func = collSize2)=>func(pair[0]) + func(pair[1]);
const pairNewMap = ()=>[
        mapNew(),
        mapNew()
    ];
const pairClone = (array)=>[
        ...array
    ];
const pairIsEqual = ([entry1, entry2])=>entry1 === entry2;
const defaultSorter = (sortKey1, sortKey2)=>(sortKey1 ?? 0) < (sortKey2 ?? 0) ? -1 : 1;
const idsChanged = (changedIds, id2, addedOrRemoved)=>mapSet(changedIds, id2, mapGet(changedIds, id2) == -addedOrRemoved ? void 0 : addedOrRemoved);
const createStore = ()=>{
    let hasTablesSchema;
    let hasValuesSchema;
    let hadTables = false;
    let hadValues = false;
    let transactions = 0;
    let internalListeners = [];
    const changedTableIds = mapNew();
    const changedTableCellIds = mapNew();
    const changedRowCount = mapNew();
    const changedRowIds = mapNew();
    const changedCellIds = mapNew();
    const changedCells = mapNew();
    const changedValueIds = mapNew();
    const changedValues = mapNew();
    const invalidCells = mapNew();
    const invalidValues = mapNew();
    const tablesSchemaMap = mapNew();
    const tablesSchemaRowCache = mapNew();
    const valuesSchemaMap = mapNew();
    const valuesDefaulted = mapNew();
    const valuesNonDefaulted = setNew();
    const tablePoolFunctions = mapNew();
    const tableCellIds = mapNew();
    const tablesMap = mapNew();
    const valuesMap = mapNew();
    const hasTablesListeners = pairNewMap();
    const tablesListeners = pairNewMap();
    const tableIdsListeners = pairNewMap();
    const hasTableListeners = pairNewMap();
    const tableListeners = pairNewMap();
    const tableCellIdsListeners = pairNewMap();
    const hasTableCellListeners = pairNewMap();
    const rowCountListeners = pairNewMap();
    const rowIdsListeners = pairNewMap();
    const sortedRowIdsListeners = pairNewMap();
    const hasRowListeners = pairNewMap();
    const rowListeners = pairNewMap();
    const cellIdsListeners = pairNewMap();
    const hasCellListeners = pairNewMap();
    const cellListeners = pairNewMap();
    const invalidCellListeners = pairNewMap();
    const invalidValueListeners = pairNewMap();
    const hasValuesListeners = pairNewMap();
    const valuesListeners = pairNewMap();
    const valueIdsListeners = pairNewMap();
    const hasValueListeners = pairNewMap();
    const valueListeners = pairNewMap();
    const startTransactionListeners = mapNew();
    const finishTransactionListeners = pairNewMap();
    const [addListener, callListeners, delListenerImpl, callListenerImpl] = getListenerFunctions(()=>store);
    const validateTablesSchema = (tableSchema)=>objValidate(tableSchema, (tableSchema2)=>objValidate(tableSchema2, validateCellOrValueSchema));
    const validateValuesSchema = (valuesSchema)=>objValidate(valuesSchema, validateCellOrValueSchema);
    const validateCellOrValueSchema = (schema)=>{
        if (!objValidate(schema, (_child, id2)=>arrayHas([
                TYPE,
                DEFAULT
            ], id2))) {
            return false;
        }
        const type = schema[TYPE];
        if (!isTypeStringOrBoolean(type) && type != NUMBER) {
            return false;
        }
        if (getCellOrValueType(schema[DEFAULT]) != type) {
            objDel(schema, DEFAULT);
        }
        return true;
    };
    const validateContent = isArray;
    const validateTables = (tables)=>objValidate(tables, validateTable, cellInvalid);
    const validateTable = (table, tableId)=>(!hasTablesSchema || collHas(tablesSchemaMap, tableId) || /* istanbul ignore next */ cellInvalid(tableId)) && objValidate(table, (row, rowId)=>validateRow(tableId, rowId, row), ()=>cellInvalid(tableId));
    const validateRow = (tableId, rowId, row, skipDefaults)=>objValidate(skipDefaults ? row : addDefaultsToRow(row, tableId, rowId), (cell, cellId)=>ifNotUndefined(getValidatedCell(tableId, rowId, cellId, cell), (validCell)=>{
                row[cellId] = validCell;
                return true;
            }, ()=>false), ()=>cellInvalid(tableId, rowId));
    const getValidatedCell = (tableId, rowId, cellId, cell)=>hasTablesSchema ? ifNotUndefined(mapGet(mapGet(tablesSchemaMap, tableId), cellId), (cellSchema)=>getCellOrValueType(cell) != cellSchema[TYPE] ? cellInvalid(tableId, rowId, cellId, cell, cellSchema[DEFAULT]) : cell, ()=>cellInvalid(tableId, rowId, cellId, cell)) : isUndefined(getCellOrValueType(cell)) ? cellInvalid(tableId, rowId, cellId, cell) : cell;
    const validateValues = (values, skipDefaults)=>objValidate(skipDefaults ? values : addDefaultsToValues(values), (value, valueId)=>ifNotUndefined(getValidatedValue(valueId, value), (validValue)=>{
                values[valueId] = validValue;
                return true;
            }, ()=>false), ()=>valueInvalid());
    const getValidatedValue = (valueId, value)=>hasValuesSchema ? ifNotUndefined(mapGet(valuesSchemaMap, valueId), (valueSchema)=>getCellOrValueType(value) != valueSchema[TYPE] ? valueInvalid(valueId, value, valueSchema[DEFAULT]) : value, ()=>valueInvalid(valueId, value)) : isUndefined(getCellOrValueType(value)) ? valueInvalid(valueId, value) : value;
    const addDefaultsToRow = (row, tableId, rowId)=>{
        ifNotUndefined(mapGet(tablesSchemaRowCache, tableId), ([rowDefaulted, rowNonDefaulted])=>{
            collForEach(rowDefaulted, (cell, cellId)=>{
                if (!objHas(row, cellId)) {
                    row[cellId] = cell;
                }
            });
            collForEach(rowNonDefaulted, (cellId)=>{
                if (!objHas(row, cellId)) {
                    cellInvalid(tableId, rowId, cellId);
                }
            });
        });
        return row;
    };
    const addDefaultsToValues = (values)=>{
        if (hasValuesSchema) {
            collForEach(valuesDefaulted, (value, valueId)=>{
                if (!objHas(values, valueId)) {
                    values[valueId] = value;
                }
            });
            collForEach(valuesNonDefaulted, (valueId)=>{
                if (!objHas(values, valueId)) {
                    valueInvalid(valueId);
                }
            });
        }
        return values;
    };
    const setValidTablesSchema = (tablesSchema)=>mapMatch(tablesSchemaMap, tablesSchema, (_tablesSchema, tableId, tableSchema)=>{
            const rowDefaulted = mapNew();
            const rowNonDefaulted = setNew();
            mapMatch(mapEnsure(tablesSchemaMap, tableId, mapNew), tableSchema, (tableSchemaMap, cellId, cellSchema)=>{
                mapSet(tableSchemaMap, cellId, cellSchema);
                ifNotUndefined(cellSchema[DEFAULT], (def)=>mapSet(rowDefaulted, cellId, def), ()=>setAdd(rowNonDefaulted, cellId));
            });
            mapSet(tablesSchemaRowCache, tableId, [
                rowDefaulted,
                rowNonDefaulted
            ]);
        }, (_tablesSchema, tableId)=>{
            mapSet(tablesSchemaMap, tableId);
            mapSet(tablesSchemaRowCache, tableId);
        });
    const setValidValuesSchema = (valuesSchema)=>mapMatch(valuesSchemaMap, valuesSchema, (_valuesSchema, valueId, valueSchema)=>{
            mapSet(valuesSchemaMap, valueId, valueSchema);
            ifNotUndefined(valueSchema[DEFAULT], (def)=>mapSet(valuesDefaulted, valueId, def), ()=>setAdd(valuesNonDefaulted, valueId));
        }, (_valuesSchema, valueId)=>{
            mapSet(valuesSchemaMap, valueId);
            mapSet(valuesDefaulted, valueId);
            collDel(valuesNonDefaulted, valueId);
        });
    const setOrDelTables = (tables)=>objIsEmpty(tables) ? delTables() : setTables(tables);
    const setValidContent = ([tables, values])=>{
        (objIsEmpty(tables) ? delTables : setTables)(tables);
        (objIsEmpty(values) ? delValues : setValues)(values);
    };
    const setValidTables = (tables)=>mapMatch(tablesMap, tables, (_tables, tableId, table)=>setValidTable(tableId, table), (_tables, tableId)=>delValidTable(tableId));
    const setValidTable = (tableId, table)=>mapMatch(mapEnsure(tablesMap, tableId, ()=>{
            tableIdsChanged(tableId, 1);
            mapSet(tablePoolFunctions, tableId, getPoolFunctions());
            mapSet(tableCellIds, tableId, mapNew());
            return mapNew();
        }), table, (tableMap, rowId, row)=>setValidRow(tableId, tableMap, rowId, row), (tableMap, rowId)=>delValidRow(tableId, tableMap, rowId));
    const setValidRow = (tableId, tableMap, rowId, row, forceDel)=>mapMatch(mapEnsure(tableMap, rowId, ()=>{
            rowIdsChanged(tableId, rowId, 1);
            return mapNew();
        }), row, (rowMap, cellId, cell)=>setValidCell(tableId, rowId, rowMap, cellId, cell), (rowMap, cellId)=>delValidCell(tableId, tableMap, rowId, rowMap, cellId, forceDel));
    const setValidCell = (tableId, rowId, rowMap, cellId, cell)=>{
        if (!collHas(rowMap, cellId)) {
            cellIdsChanged(tableId, rowId, cellId, 1);
        }
        const oldCell = mapGet(rowMap, cellId);
        if (cell !== oldCell) {
            cellChanged(tableId, rowId, cellId, oldCell, cell);
            mapSet(rowMap, cellId, cell);
        }
    };
    const setCellIntoDefaultRow = (tableId, tableMap, rowId, cellId, validCell)=>ifNotUndefined(mapGet(tableMap, rowId), (rowMap)=>setValidCell(tableId, rowId, rowMap, cellId, validCell), ()=>setValidRow(tableId, tableMap, rowId, addDefaultsToRow({
                [cellId]: validCell
            }, tableId, rowId)));
    const setOrDelValues = (values)=>objIsEmpty(values) ? delValues() : setValues(values);
    const setValidValues = (values)=>mapMatch(valuesMap, values, (_valuesMap, valueId, value)=>setValidValue(valueId, value), (_valuesMap, valueId)=>delValidValue(valueId));
    const setValidValue = (valueId, value)=>{
        if (!collHas(valuesMap, valueId)) {
            valueIdsChanged(valueId, 1);
        }
        const oldValue = mapGet(valuesMap, valueId);
        if (value !== oldValue) {
            valueChanged(valueId, oldValue, value);
            mapSet(valuesMap, valueId, value);
        }
    };
    const getNewRowId = (tableId, reuse)=>{
        const [getId] = mapGet(tablePoolFunctions, tableId);
        let rowId;
        do {
            rowId = getId(reuse);
        }while (collHas(mapGet(tablesMap, tableId), rowId))
        return rowId;
    };
    const getOrCreateTable = (tableId)=>mapGet(tablesMap, tableId) ?? setValidTable(tableId, {});
    const delValidTable = (tableId)=>setValidTable(tableId, {});
    const delValidRow = (tableId, tableMap, rowId)=>{
        const [, releaseId] = mapGet(tablePoolFunctions, tableId);
        releaseId(rowId);
        setValidRow(tableId, tableMap, rowId, {}, true);
    };
    const delValidCell = (tableId, table, rowId, row, cellId, forceDel)=>{
        const defaultCell = mapGet(mapGet(tablesSchemaRowCache, tableId)?.[0], cellId);
        if (!isUndefined(defaultCell) && !forceDel) {
            return setValidCell(tableId, rowId, row, cellId, defaultCell);
        }
        const delCell2 = (cellId2)=>{
            cellChanged(tableId, rowId, cellId2, mapGet(row, cellId2));
            cellIdsChanged(tableId, rowId, cellId2, -1);
            mapSet(row, cellId2);
        };
        if (isUndefined(defaultCell)) {
            delCell2(cellId);
        } else {
            mapForEach(row, delCell2);
        }
        if (collIsEmpty(row)) {
            rowIdsChanged(tableId, rowId, -1);
            if (collIsEmpty(mapSet(table, rowId))) {
                tableIdsChanged(tableId, -1);
                mapSet(tablesMap, tableId);
                mapSet(tablePoolFunctions, tableId);
                mapSet(tableCellIds, tableId);
            }
        }
    };
    const delValidValue = (valueId)=>{
        const defaultValue = mapGet(valuesDefaulted, valueId);
        if (!isUndefined(defaultValue)) {
            return setValidValue(valueId, defaultValue);
        }
        valueChanged(valueId, mapGet(valuesMap, valueId));
        valueIdsChanged(valueId, -1);
        mapSet(valuesMap, valueId);
    };
    const tableIdsChanged = (tableId, addedOrRemoved)=>idsChanged(changedTableIds, tableId, addedOrRemoved);
    const rowIdsChanged = (tableId, rowId, addedOrRemoved)=>idsChanged(mapEnsure(changedRowIds, tableId, mapNew), rowId, addedOrRemoved) && mapSet(changedRowCount, tableId, mapEnsure(changedRowCount, tableId, ()=>0) + addedOrRemoved);
    const cellIdsChanged = (tableId, rowId, cellId, addedOrRemoved)=>{
        const cellIds = mapGet(tableCellIds, tableId);
        const count = mapGet(cellIds, cellId) ?? 0;
        if (count == 0 && addedOrRemoved == 1 || count == 1 && addedOrRemoved == -1) {
            idsChanged(mapEnsure(changedTableCellIds, tableId, mapNew), cellId, addedOrRemoved);
        }
        mapSet(cellIds, cellId, count != -addedOrRemoved ? count + addedOrRemoved : null);
        idsChanged(mapEnsure(mapEnsure(changedCellIds, tableId, mapNew), rowId, mapNew), cellId, addedOrRemoved);
    };
    const cellChanged = (tableId, rowId, cellId, oldCell, newCell)=>{
        mapEnsure(mapEnsure(mapEnsure(changedCells, tableId, mapNew), rowId, mapNew), cellId, ()=>[
                oldCell,
                0
            ])[1] = newCell;
        internalListeners[3]?.(tableId, rowId, cellId, newCell);
    };
    const valueIdsChanged = (valueId, addedOrRemoved)=>idsChanged(changedValueIds, valueId, addedOrRemoved);
    const valueChanged = (valueId, oldValue, newValue)=>{
        mapEnsure(changedValues, valueId, ()=>[
                oldValue,
                0
            ])[1] = newValue;
        internalListeners[4]?.(valueId, newValue);
    };
    const cellInvalid = (tableId, rowId, cellId, invalidCell, defaultedCell)=>{
        arrayPush(mapEnsure(mapEnsure(mapEnsure(invalidCells, tableId, mapNew), rowId, mapNew), cellId, ()=>[]), invalidCell);
        return defaultedCell;
    };
    const valueInvalid = (valueId, invalidValue, defaultedValue)=>{
        arrayPush(mapEnsure(invalidValues, valueId, ()=>[]), invalidValue);
        return defaultedValue;
    };
    const getCellChange = (tableId, rowId, cellId)=>ifNotUndefined(mapGet(mapGet(mapGet(changedCells, tableId), rowId), cellId), ([oldCell, newCell])=>[
                true,
                oldCell,
                newCell
            ], ()=>[
                false,
                ...pairNew(getCell(tableId, rowId, cellId))
            ]);
    const getValueChange = (valueId)=>ifNotUndefined(mapGet(changedValues, valueId), ([oldValue, newValue])=>[
                true,
                oldValue,
                newValue
            ], ()=>[
                false,
                ...pairNew(getValue(valueId))
            ]);
    const callInvalidCellListeners = (mutator)=>!collIsEmpty(invalidCells) && !collIsEmpty(invalidCellListeners[mutator]) ? collForEach(mutator ? mapClone3(invalidCells) : invalidCells, (rows, tableId)=>collForEach(rows, (cells, rowId)=>collForEach(cells, (invalidCell, cellId)=>callListeners(invalidCellListeners[mutator], [
                        tableId,
                        rowId,
                        cellId
                    ], invalidCell)))) : 0;
    const callInvalidValueListeners = (mutator)=>!collIsEmpty(invalidValues) && !collIsEmpty(invalidValueListeners[mutator]) ? collForEach(mutator ? mapClone(invalidValues) : invalidValues, (invalidValue, valueId)=>callListeners(invalidValueListeners[mutator], [
                valueId
            ], invalidValue)) : 0;
    const callIdsAndHasListenersIfChanged = (changedIds, idListeners, hasListeners, ids)=>{
        if (!collIsEmpty(changedIds)) {
            callListeners(idListeners, ids, ()=>mapToObj(changedIds));
            mapForEach(changedIds, (changedId, changed)=>callListeners(hasListeners, [
                    ...ids ?? [],
                    changedId
                ], changed == 1));
            return 1;
        }
    };
    const callTabularListenersForChanges = (mutator)=>{
        const hasTablesNow = hasTables();
        if (hasTablesNow != hadTables) {
            callListeners(hasTablesListeners[mutator], void 0, hasTablesNow);
        }
        const emptySortedRowIdListeners = collIsEmpty(sortedRowIdsListeners[mutator]);
        const emptyIdAndHasListeners = collIsEmpty(cellIdsListeners[mutator]) && collIsEmpty(hasCellListeners[mutator]) && collIsEmpty(rowIdsListeners[mutator]) && collIsEmpty(hasRowListeners[mutator]) && collIsEmpty(tableCellIdsListeners[mutator]) && collIsEmpty(hasTableCellListeners[mutator]) && collIsEmpty(rowCountListeners[mutator]) && emptySortedRowIdListeners && collIsEmpty(tableIdsListeners[mutator]) && collIsEmpty(hasTableListeners[mutator]);
        const emptyOtherListeners = collIsEmpty(cellListeners[mutator]) && collIsEmpty(rowListeners[mutator]) && collIsEmpty(tableListeners[mutator]) && collIsEmpty(tablesListeners[mutator]);
        if (!emptyIdAndHasListeners || !emptyOtherListeners) {
            const changes = mutator ? [
                mapClone(changedTableIds),
                mapClone2(changedTableCellIds),
                mapClone(changedRowCount),
                mapClone2(changedRowIds),
                mapClone3(changedCellIds),
                mapClone3(changedCells)
            ] : [
                changedTableIds,
                changedTableCellIds,
                changedRowCount,
                changedRowIds,
                changedCellIds,
                changedCells
            ];
            if (!emptyIdAndHasListeners) {
                callIdsAndHasListenersIfChanged(changes[0], tableIdsListeners[mutator], hasTableListeners[mutator]);
                collForEach(changes[1], (changedIds, tableId)=>callIdsAndHasListenersIfChanged(changedIds, tableCellIdsListeners[mutator], hasTableCellListeners[mutator], [
                        tableId
                    ]));
                collForEach(changes[2], (changedCount, tableId)=>{
                    if (changedCount != 0) {
                        callListeners(rowCountListeners[mutator], [
                            tableId
                        ], getRowCount(tableId));
                    }
                });
                const calledSortableTableIds = setNew();
                collForEach(changes[3], (changedIds, tableId)=>{
                    if (callIdsAndHasListenersIfChanged(changedIds, rowIdsListeners[mutator], hasRowListeners[mutator], [
                        tableId
                    ]) && !emptySortedRowIdListeners) {
                        callListeners(sortedRowIdsListeners[mutator], [
                            tableId,
                            null
                        ]);
                        setAdd(calledSortableTableIds, tableId);
                    }
                });
                if (!emptySortedRowIdListeners) {
                    collForEach(changes[5], (rows, tableId)=>{
                        if (!collHas(calledSortableTableIds, tableId)) {
                            const sortableCellIds = setNew();
                            collForEach(rows, (cells)=>collForEach(cells, ([oldCell, newCell], cellId)=>newCell !== oldCell ? setAdd(sortableCellIds, cellId) : collDel(cells, cellId)));
                            collForEach(sortableCellIds, (cellId)=>callListeners(sortedRowIdsListeners[mutator], [
                                    tableId,
                                    cellId
                                ]));
                        }
                    });
                }
                collForEach(changes[4], (rowCellIds, tableId)=>collForEach(rowCellIds, (changedIds, rowId)=>callIdsAndHasListenersIfChanged(changedIds, cellIdsListeners[mutator], hasCellListeners[mutator], [
                            tableId,
                            rowId
                        ])));
            }
            if (!emptyOtherListeners) {
                let tablesChanged;
                collForEach(changes[5], (rows, tableId)=>{
                    let tableChanged;
                    collForEach(rows, (cells, rowId)=>{
                        let rowChanged;
                        collForEach(cells, ([oldCell, newCell], cellId)=>{
                            if (newCell !== oldCell) {
                                callListeners(cellListeners[mutator], [
                                    tableId,
                                    rowId,
                                    cellId
                                ], newCell, oldCell, getCellChange);
                                tablesChanged = tableChanged = rowChanged = 1;
                            }
                        });
                        if (rowChanged) {
                            callListeners(rowListeners[mutator], [
                                tableId,
                                rowId
                            ], getCellChange);
                        }
                    });
                    if (tableChanged) {
                        callListeners(tableListeners[mutator], [
                            tableId
                        ], getCellChange);
                    }
                });
                if (tablesChanged) {
                    callListeners(tablesListeners[mutator], void 0, getCellChange);
                }
            }
        }
    };
    const callValuesListenersForChanges = (mutator)=>{
        const hasValuesNow = hasValues();
        if (hasValuesNow != hadValues) {
            callListeners(hasValuesListeners[mutator], void 0, hasValuesNow);
        }
        const emptyIdAndHasListeners = collIsEmpty(valueIdsListeners[mutator]) && collIsEmpty(hasValueListeners[mutator]);
        const emptyOtherListeners = collIsEmpty(valueListeners[mutator]) && collIsEmpty(valuesListeners[mutator]);
        if (!emptyIdAndHasListeners || !emptyOtherListeners) {
            const changes = mutator ? [
                mapClone(changedValueIds),
                mapClone(changedValues)
            ] : [
                changedValueIds,
                changedValues
            ];
            if (!emptyIdAndHasListeners) {
                callIdsAndHasListenersIfChanged(changes[0], valueIdsListeners[mutator], hasValueListeners[mutator]);
            }
            if (!emptyOtherListeners) {
                let valuesChanged;
                collForEach(changes[1], ([oldValue, newValue], valueId)=>{
                    if (newValue !== oldValue) {
                        callListeners(valueListeners[mutator], [
                            valueId
                        ], newValue, oldValue, getValueChange);
                        valuesChanged = 1;
                    }
                });
                if (valuesChanged) {
                    callListeners(valuesListeners[mutator], void 0, getValueChange);
                }
            }
        }
    };
    const fluentTransaction = (actions, ...args)=>{
        transaction(()=>actions(...arrayMap(args, id)));
        return store;
    };
    const getContent = ()=>[
            getTables(),
            getValues()
        ];
    const getTables = ()=>mapToObj3(tablesMap);
    const getTableIds = ()=>mapKeys(tablesMap);
    const getTable = (tableId)=>mapToObj2(mapGet(tablesMap, id(tableId)));
    const getTableCellIds = (tableId)=>mapKeys(mapGet(tableCellIds, id(tableId)));
    const getRowCount = (tableId)=>collSize(mapGet(tablesMap, id(tableId)));
    const getRowIds = (tableId)=>mapKeys(mapGet(tablesMap, id(tableId)));
    const getSortedRowIds = (tableId, cellId, descending, offset = 0, limit)=>arrayMap(slice(arraySort(mapMap(mapGet(tablesMap, id(tableId)), (row, rowId)=>[
                isUndefined(cellId) ? rowId : mapGet(row, id(cellId)),
                rowId
            ]), ([cell1], [cell2])=>defaultSorter(cell1, cell2) * (descending ? -1 : 1)), offset, isUndefined(limit) ? limit : offset + limit), ([, rowId])=>rowId);
    const getRow = (tableId, rowId)=>mapToObj(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)));
    const getCellIds = (tableId, rowId)=>mapKeys(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)));
    const getCell = (tableId, rowId, cellId)=>mapGet(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), id(cellId));
    const getValues = ()=>mapToObj(valuesMap);
    const getValueIds = ()=>mapKeys(valuesMap);
    const getValue = (valueId)=>mapGet(valuesMap, id(valueId));
    const hasTables = ()=>!collIsEmpty(tablesMap);
    const hasTable = (tableId)=>collHas(tablesMap, id(tableId));
    const hasTableCell = (tableId, cellId)=>collHas(mapGet(tableCellIds, id(tableId)), id(cellId));
    const hasRow = (tableId, rowId)=>collHas(mapGet(tablesMap, id(tableId)), id(rowId));
    const hasCell = (tableId, rowId, cellId)=>collHas(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), id(cellId));
    const hasValues = ()=>!collIsEmpty(valuesMap);
    const hasValue = (valueId)=>collHas(valuesMap, id(valueId));
    const getTablesJson = ()=>jsonStringWithMap(tablesMap);
    const getValuesJson = ()=>jsonStringWithMap(valuesMap);
    const getJson = ()=>jsonStringWithMap([
            tablesMap,
            valuesMap
        ]);
    const getTablesSchemaJson = ()=>jsonStringWithMap(tablesSchemaMap);
    const getValuesSchemaJson = ()=>jsonStringWithMap(valuesSchemaMap);
    const getSchemaJson = ()=>jsonStringWithMap([
            tablesSchemaMap,
            valuesSchemaMap
        ]);
    const setContent = (content)=>fluentTransaction(()=>{
            const content2 = isFunction(content) ? content() : content;
            if (validateContent(content2)) {
                setValidContent(content2);
            }
        });
    const setTables = (tables)=>fluentTransaction(()=>validateTables(tables) ? setValidTables(tables) : 0);
    const setTable = (tableId, table)=>fluentTransaction((tableId2)=>validateTable(table, tableId2) ? setValidTable(tableId2, table) : 0, tableId);
    const setRow = (tableId, rowId, row)=>fluentTransaction((tableId2, rowId2)=>validateRow(tableId2, rowId2, row) ? setValidRow(tableId2, getOrCreateTable(tableId2), rowId2, row) : 0, tableId, rowId);
    const addRow = (tableId, row, reuseRowIds = true)=>transaction(()=>{
            let rowId = void 0;
            if (validateRow(tableId, rowId, row)) {
                tableId = id(tableId);
                setValidRow(tableId, getOrCreateTable(tableId), rowId = getNewRowId(tableId, reuseRowIds ? 1 : 0), row);
            }
            return rowId;
        });
    const setPartialRow = (tableId, rowId, partialRow)=>fluentTransaction((tableId2, rowId2)=>{
            if (validateRow(tableId2, rowId2, partialRow, 1)) {
                const table = getOrCreateTable(tableId2);
                objMap(partialRow, (cell, cellId)=>setCellIntoDefaultRow(tableId2, table, rowId2, cellId, cell));
            }
        }, tableId, rowId);
    const setCell = (tableId, rowId, cellId, cell)=>fluentTransaction((tableId2, rowId2, cellId2)=>ifNotUndefined(getValidatedCell(tableId2, rowId2, cellId2, isFunction(cell) ? cell(getCell(tableId2, rowId2, cellId2)) : cell), (validCell)=>setCellIntoDefaultRow(tableId2, getOrCreateTable(tableId2), rowId2, cellId2, validCell)), tableId, rowId, cellId);
    const setValues = (values)=>fluentTransaction(()=>validateValues(values) ? setValidValues(values) : 0);
    const setPartialValues = (partialValues)=>fluentTransaction(()=>validateValues(partialValues, 1) ? objMap(partialValues, (value, valueId)=>setValidValue(valueId, value)) : 0);
    const setValue = (valueId, value)=>fluentTransaction((valueId2)=>ifNotUndefined(getValidatedValue(valueId2, isFunction(value) ? value(getValue(valueId2)) : value), (validValue)=>setValidValue(valueId2, validValue)), valueId);
    const applyChanges = (changes)=>fluentTransaction(()=>{
            objMap(changes[0], (table, tableId)=>isUndefined(table) ? delTable(tableId) : objMap(table, (row, rowId)=>isUndefined(row) ? delRow(tableId, rowId) : objMap(row, (cell, cellId)=>setOrDelCell(store, tableId, rowId, cellId, cell))));
            objMap(changes[1], (value, valueId)=>setOrDelValue(store, valueId, value));
        });
    const setTablesJson = (tablesJson)=>{
        try {
            setOrDelTables(jsonParse(tablesJson));
        } catch  {}
        return store;
    };
    const setValuesJson = (valuesJson)=>{
        try {
            setOrDelValues(jsonParse(valuesJson));
        } catch  {}
        return store;
    };
    const setJson = (tablesAndValuesJson)=>fluentTransaction(()=>{
            try {
                const [tables, values] = jsonParse(tablesAndValuesJson);
                setOrDelTables(tables);
                setOrDelValues(values);
            } catch  {
                setTablesJson(tablesAndValuesJson);
            }
        });
    const setTablesSchema = (tablesSchema)=>fluentTransaction(()=>{
            if (hasTablesSchema = validateTablesSchema(tablesSchema)) {
                setValidTablesSchema(tablesSchema);
                if (!collIsEmpty(tablesMap)) {
                    const tables = getTables();
                    delTables();
                    setTables(tables);
                }
            }
        });
    const setValuesSchema = (valuesSchema)=>fluentTransaction(()=>{
            if (hasValuesSchema = validateValuesSchema(valuesSchema)) {
                const values = getValues();
                delValuesSchema();
                delValues();
                hasValuesSchema = true;
                setValidValuesSchema(valuesSchema);
                setValues(values);
            }
        });
    const setSchema = (tablesSchema, valuesSchema)=>fluentTransaction(()=>{
            setTablesSchema(tablesSchema);
            setValuesSchema(valuesSchema);
        });
    const delTables = ()=>fluentTransaction(()=>setValidTables({}));
    const delTable = (tableId)=>fluentTransaction((tableId2)=>collHas(tablesMap, tableId2) ? delValidTable(tableId2) : 0, tableId);
    const delRow = (tableId, rowId)=>fluentTransaction((tableId2, rowId2)=>ifNotUndefined(mapGet(tablesMap, tableId2), (tableMap)=>collHas(tableMap, rowId2) ? delValidRow(tableId2, tableMap, rowId2) : 0), tableId, rowId);
    const delCell = (tableId, rowId, cellId, forceDel)=>fluentTransaction((tableId2, rowId2, cellId2)=>ifNotUndefined(mapGet(tablesMap, tableId2), (tableMap)=>ifNotUndefined(mapGet(tableMap, rowId2), (rowMap)=>collHas(rowMap, cellId2) ? delValidCell(tableId2, tableMap, rowId2, rowMap, cellId2, forceDel) : 0)), tableId, rowId, cellId);
    const delValues = ()=>fluentTransaction(()=>setValidValues({}));
    const delValue = (valueId)=>fluentTransaction((valueId2)=>collHas(valuesMap, valueId2) ? delValidValue(valueId2) : 0, valueId);
    const delTablesSchema = ()=>fluentTransaction(()=>{
            setValidTablesSchema({});
            hasTablesSchema = false;
        });
    const delValuesSchema = ()=>fluentTransaction(()=>{
            setValidValuesSchema({});
            hasValuesSchema = false;
        });
    const delSchema = ()=>fluentTransaction(()=>{
            delTablesSchema();
            delValuesSchema();
        });
    const transaction = (actions, doRollback)=>{
        if (transactions != -1) {
            startTransaction();
            const result = actions();
            finishTransaction(doRollback);
            return result;
        }
    };
    const startTransaction = ()=>{
        if (transactions != -1) {
            transactions++;
        }
        if (transactions == 1) {
            internalListeners[0]?.();
            callListeners(startTransactionListeners);
        }
        return store;
    };
    const getTransactionChanges = ()=>[
            mapToObj(changedCells, (table, tableId)=>mapGet(changedTableIds, tableId) === -1 ? void 0 : mapToObj(table, (row, rowId)=>mapGet(mapGet(changedRowIds, tableId), rowId) === -1 ? void 0 : mapToObj(row, ([, newCell])=>newCell, (changedCell)=>pairIsEqual(changedCell)), collIsEmpty, objIsEmpty), collIsEmpty, objIsEmpty),
            mapToObj(changedValues, ([, newValue])=>newValue, (changedValue)=>pairIsEqual(changedValue)),
            1
        ];
    const getTransactionLog = ()=>[
            !collIsEmpty(changedCells),
            !collIsEmpty(changedValues),
            mapToObj3(changedCells, pairClone, pairIsEqual),
            mapToObj3(invalidCells),
            mapToObj(changedValues, pairClone, pairIsEqual),
            mapToObj(invalidValues),
            mapToObj(changedTableIds),
            mapToObj2(changedRowIds),
            mapToObj3(changedCellIds),
            mapToObj(changedValueIds)
        ];
    const finishTransaction = (doRollback)=>{
        if (transactions > 0) {
            transactions--;
            if (transactions == 0) {
                transactions = 1;
                callInvalidCellListeners(1);
                if (!collIsEmpty(changedCells)) {
                    callTabularListenersForChanges(1);
                }
                callInvalidValueListeners(1);
                if (!collIsEmpty(changedValues)) {
                    callValuesListenersForChanges(1);
                }
                if (doRollback?.(store)) {
                    collForEach(changedCells, (table, tableId)=>collForEach(table, (row, rowId)=>collForEach(row, ([oldCell], cellId)=>setOrDelCell(store, tableId, rowId, cellId, oldCell))));
                    collClear(changedCells);
                    collForEach(changedValues, ([oldValue], valueId)=>setOrDelValue(store, valueId, oldValue));
                    collClear(changedValues);
                }
                callListeners(finishTransactionListeners[0], void 0);
                transactions = -1;
                callInvalidCellListeners(0);
                if (!collIsEmpty(changedCells)) {
                    callTabularListenersForChanges(0);
                }
                callInvalidValueListeners(0);
                if (!collIsEmpty(changedValues)) {
                    callValuesListenersForChanges(0);
                }
                internalListeners[1]?.();
                callListeners(finishTransactionListeners[1], void 0);
                internalListeners[2]?.();
                transactions = 0;
                hadTables = hasTables();
                hadValues = hasValues();
                arrayForEach([
                    changedTableIds,
                    changedTableCellIds,
                    changedRowCount,
                    changedRowIds,
                    changedCellIds,
                    changedCells,
                    invalidCells,
                    changedValueIds,
                    changedValues,
                    invalidValues
                ], collClear);
            }
        }
        return store;
    };
    const forEachTable = (tableCallback)=>collForEach(tablesMap, (tableMap, tableId)=>tableCallback(tableId, (rowCallback)=>collForEach(tableMap, (rowMap, rowId)=>rowCallback(rowId, (cellCallback)=>mapForEach(rowMap, cellCallback)))));
    const forEachTableCell = (tableId, tableCellCallback)=>mapForEach(mapGet(tableCellIds, id(tableId)), tableCellCallback);
    const forEachRow = (tableId, rowCallback)=>collForEach(mapGet(tablesMap, id(tableId)), (rowMap, rowId)=>rowCallback(rowId, (cellCallback)=>mapForEach(rowMap, cellCallback)));
    const forEachCell = (tableId, rowId, cellCallback)=>mapForEach(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), cellCallback);
    const forEachValue = (valueCallback)=>mapForEach(valuesMap, valueCallback);
    const addSortedRowIdsListener = (tableId, cellId, descending, offset, limit, listener, mutator)=>{
        let sortedRowIds = getSortedRowIds(tableId, cellId, descending, offset, limit);
        return addListener(()=>{
            const newSortedRowIds = getSortedRowIds(tableId, cellId, descending, offset, limit);
            if (!arrayIsEqual(newSortedRowIds, sortedRowIds)) {
                sortedRowIds = newSortedRowIds;
                listener(store, tableId, cellId, descending, offset, limit, sortedRowIds);
            }
        }, sortedRowIdsListeners[mutator ? 1 : 0], [
            tableId,
            cellId
        ], [
            getTableIds
        ]);
    };
    const addStartTransactionListener = (listener)=>addListener(listener, startTransactionListeners);
    const addWillFinishTransactionListener = (listener)=>addListener(listener, finishTransactionListeners[0]);
    const addDidFinishTransactionListener = (listener)=>addListener(listener, finishTransactionListeners[1]);
    const callListener = (listenerId)=>{
        callListenerImpl(listenerId);
        return store;
    };
    const delListener = (listenerId)=>{
        delListenerImpl(listenerId);
        return store;
    };
    const getListenerStats = ()=>({
            hasTables: pairCollSize2(hasTablesListeners),
            tables: pairCollSize2(tablesListeners),
            tableIds: pairCollSize2(tableIdsListeners),
            hasTable: pairCollSize2(hasTableListeners),
            table: pairCollSize2(tableListeners),
            tableCellIds: pairCollSize2(tableCellIdsListeners),
            hasTableCell: pairCollSize2(hasTableCellListeners, collSize3),
            rowCount: pairCollSize2(rowCountListeners),
            rowIds: pairCollSize2(rowIdsListeners),
            sortedRowIds: pairCollSize2(sortedRowIdsListeners),
            hasRow: pairCollSize2(hasRowListeners, collSize3),
            row: pairCollSize2(rowListeners, collSize3),
            cellIds: pairCollSize2(cellIdsListeners, collSize3),
            hasCell: pairCollSize2(hasCellListeners, collSize4),
            cell: pairCollSize2(cellListeners, collSize4),
            invalidCell: pairCollSize2(invalidCellListeners, collSize4),
            hasValues: pairCollSize2(hasValuesListeners),
            values: pairCollSize2(valuesListeners),
            valueIds: pairCollSize2(valueIdsListeners),
            hasValue: pairCollSize2(hasValueListeners),
            value: pairCollSize2(valueListeners),
            invalidValue: pairCollSize2(invalidValueListeners),
            transaction: collSize2(startTransactionListeners) + pairCollSize2(finishTransactionListeners)
        });
    const setInternalListeners = (preStartTransaction, preFinishTransaction, postFinishTransaction, cellChanged2, valueChanged2)=>internalListeners = [
            preStartTransaction,
            preFinishTransaction,
            postFinishTransaction,
            cellChanged2,
            valueChanged2
        ];
    const store = {
        getContent,
        getTables,
        getTableIds,
        getTable,
        getTableCellIds,
        getRowCount,
        getRowIds,
        getSortedRowIds,
        getRow,
        getCellIds,
        getCell,
        getValues,
        getValueIds,
        getValue,
        hasTables,
        hasTable,
        hasTableCell,
        hasRow,
        hasCell,
        hasValues,
        hasValue,
        getTablesJson,
        getValuesJson,
        getJson,
        getTablesSchemaJson,
        getValuesSchemaJson,
        getSchemaJson,
        hasTablesSchema: ()=>hasTablesSchema,
        hasValuesSchema: ()=>hasValuesSchema,
        setContent,
        setTables,
        setTable,
        setRow,
        addRow,
        setPartialRow,
        setCell,
        setValues,
        setPartialValues,
        setValue,
        applyChanges,
        setTablesJson,
        setValuesJson,
        setJson,
        setTablesSchema,
        setValuesSchema,
        setSchema,
        delTables,
        delTable,
        delRow,
        delCell,
        delValues,
        delValue,
        delTablesSchema,
        delValuesSchema,
        delSchema,
        transaction,
        startTransaction,
        getTransactionChanges,
        getTransactionLog,
        finishTransaction,
        forEachTable,
        forEachTableCell,
        forEachRow,
        forEachCell,
        forEachValue,
        addSortedRowIdsListener,
        addStartTransactionListener,
        addWillFinishTransactionListener,
        addDidFinishTransactionListener,
        callListener,
        delListener,
        getListenerStats,
        isMergeable: ()=>false,
        // only used internally by other modules
        createStore,
        addListener,
        callListeners,
        setInternalListeners
    };
    objMap({
        [HAS + TABLES]: [
            0,
            hasTablesListeners,
            [],
            ()=>[
                    hasTables()
                ]
        ],
        [TABLES]: [
            0,
            tablesListeners
        ],
        [TABLE_IDS]: [
            0,
            tableIdsListeners
        ],
        [HAS + TABLE]: [
            1,
            hasTableListeners,
            [
                getTableIds
            ],
            (ids)=>[
                    hasTable(...ids)
                ]
        ],
        [TABLE]: [
            1,
            tableListeners,
            [
                getTableIds
            ]
        ],
        [TABLE + CELL_IDS]: [
            1,
            tableCellIdsListeners,
            [
                getTableIds
            ]
        ],
        [HAS + TABLE + CELL]: [
            2,
            hasTableCellListeners,
            [
                getTableIds,
                getTableCellIds
            ],
            (ids)=>[
                    hasTableCell(...ids)
                ]
        ],
        [ROW_COUNT]: [
            1,
            rowCountListeners,
            [
                getTableIds
            ]
        ],
        [ROW_IDS]: [
            1,
            rowIdsListeners,
            [
                getTableIds
            ]
        ],
        [HAS + ROW]: [
            2,
            hasRowListeners,
            [
                getTableIds,
                getRowIds
            ],
            (ids)=>[
                    hasRow(...ids)
                ]
        ],
        [ROW]: [
            2,
            rowListeners,
            [
                getTableIds,
                getRowIds
            ]
        ],
        [CELL_IDS]: [
            2,
            cellIdsListeners,
            [
                getTableIds,
                getRowIds
            ]
        ],
        [HAS + CELL]: [
            3,
            hasCellListeners,
            [
                getTableIds,
                getRowIds,
                getCellIds
            ],
            (ids)=>[
                    hasCell(...ids)
                ]
        ],
        [CELL]: [
            3,
            cellListeners,
            [
                getTableIds,
                getRowIds,
                getCellIds
            ],
            (ids)=>pairNew(getCell(...ids))
        ],
        InvalidCell: [
            3,
            invalidCellListeners
        ],
        [HAS + VALUES]: [
            0,
            hasValuesListeners,
            [],
            ()=>[
                    hasValues()
                ]
        ],
        [VALUES]: [
            0,
            valuesListeners
        ],
        [VALUE_IDS]: [
            0,
            valueIdsListeners
        ],
        [HAS + VALUE]: [
            1,
            hasValueListeners,
            [
                getValueIds
            ],
            (ids)=>[
                    hasValue(...ids)
                ]
        ],
        [VALUE]: [
            1,
            valueListeners,
            [
                getValueIds
            ],
            (ids)=>pairNew(getValue(ids[0]))
        ],
        InvalidValue: [
            1,
            invalidValueListeners
        ]
    }, ([argumentCount, idSetNode, pathGetters, extraArgsGetter], listenable)=>{
        store[ADD + listenable + LISTENER] = (...args)=>addListener(args[argumentCount], idSetNode[args[argumentCount + 1] ? 1 : 0], argumentCount > 0 ? slice(args, 0, argumentCount) : void 0, pathGetters, extraArgsGetter);
    });
    return objFreeze(store);
};
const Inspector = ({ position = 'right', open = false })=>{
    const s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCreateStore"])(createStore);
    const index = POSITIONS.indexOf(position);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$tinybase$40$5$2e$4$2e$8_$40$cloudflare$2b$workers$2d$types$40$4$2e$20250224$2e$0_prettier$40$3$2e$5$2e$2_react$2d$dom$40$19$2e$0$2e$0_r_f119fa6fd70ae136b14596e010fc1b02$2f$node_modules$2f$tinybase$2f$ui$2d$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCreatePersister"])(s, {
        "Inspector.useCreatePersister": (s2)=>createSessionPersister(s2, UNIQUE_ID)
    }["Inspector.useCreatePersister"], void 0, {
        "Inspector.useCreatePersister": async (persister)=>{
            await persister.load([
                {},
                {
                    position: index == -1 ? 1 : index,
                    open: !!open
                }
            ]);
            await persister.startAutoSave();
        }
    }["Inspector.useCreatePersister"]);
    return /* @__PURE__ */ createElement(Fragment, null, /* @__PURE__ */ createElement('aside', {
        id: UNIQUE_ID
    }, /* @__PURE__ */ createElement(Nub, {
        s
    }), /* @__PURE__ */ createElement(Panel, {
        s
    })), /* @__PURE__ */ createElement('style', null, APP_STYLESHEET));
};
;
}}),
}]);

//# sourceMappingURL=node_modules__pnpm_17e1292f._.js.map