{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored[\n  'react-ssr'\n].ReactJsxDevRuntime\n"],"names":["module","exports","require","vendored","ReactJsxDevRuntime"],"mappings":";AAAAA,OAAOC,OAAO,GAAGC,QAAQ,uMAAyBC,QAAQ,CACxD,YACD,CAACC,kBAAkB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/tinybase%405.4.8_%40cloudflare%2Bworkers-types%404.20250224.0_prettier%403.5.2_react-dom%4019.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/index.js"],"sourcesContent":["const getTypeOf = (thing) => typeof thing;\nconst EMPTY_STRING = '';\nconst STRING = getTypeOf(EMPTY_STRING);\nconst BOOLEAN = getTypeOf(true);\nconst NUMBER = getTypeOf(0);\nconst FUNCTION = getTypeOf(getTypeOf);\nconst TYPE = 'type';\nconst DEFAULT = 'default';\nconst SUM = 'sum';\nconst AVG = 'avg';\nconst MIN = 'min';\nconst MAX = 'max';\nconst LISTENER = 'Listener';\nconst RESULT = 'Result';\nconst GET = 'get';\nconst SET = 'set';\nconst ADD = 'add';\nconst DEL = 'del';\nconst HAS = 'Has';\nconst IDS = 'Ids';\nconst TABLE = 'Table';\nconst TABLES = TABLE + 's';\nconst TABLE_IDS = TABLE + IDS;\nconst ROW = 'Row';\nconst ROW_COUNT = ROW + 'Count';\nconst ROW_IDS = ROW + IDS;\nconst SORTED_ROW_IDS = 'Sorted' + ROW + IDS;\nconst CELL = 'Cell';\nconst CELL_IDS = CELL + IDS;\nconst VALUE = 'Value';\nconst VALUES = VALUE + 's';\nconst VALUE_IDS = VALUE + IDS;\nconst TRANSACTION = 'Transaction';\nconst id = (key) => EMPTY_STRING + key;\nconst strStartsWith = (str, prefix) => str.startsWith(prefix);\nconst strEndsWith = (str, suffix) => str.endsWith(suffix);\nconst strSplit = (str, separator = EMPTY_STRING, limit) =>\n  str.split(separator, limit);\n\nconst GLOBAL = globalThis;\nconst math = Math;\nconst mathMax = math.max;\nconst mathMin = math.min;\nconst mathFloor = math.floor;\nconst isFiniteNumber = isFinite;\nconst isInstanceOf = (thing, cls) => thing instanceof cls;\nconst isUndefined = (thing) => thing == void 0;\nconst ifNotUndefined = (value, then, otherwise) =>\n  isUndefined(value) ? otherwise?.() : then(value);\nconst isTypeStringOrBoolean = (type) => type == STRING || type == BOOLEAN;\nconst isString = (thing) => getTypeOf(thing) == STRING;\nconst isFunction = (thing) => getTypeOf(thing) == FUNCTION;\nconst isArray = (thing) => Array.isArray(thing);\nconst slice = (arrayOrString, start, end) => arrayOrString.slice(start, end);\nconst size = (arrayOrString) => arrayOrString.length;\nconst test = (regex, subject) => regex.test(subject);\nconst getUndefined = () => void 0;\n\nconst arrayHas = (array, value) => array.includes(value);\nconst arrayEvery = (array, cb) => array.every(cb);\nconst arrayIsEqual = (array1, array2) =>\n  size(array1) === size(array2) &&\n  arrayEvery(array1, (value1, index) => array2[index] === value1);\nconst arrayIsSorted = (array, sorter) =>\n  arrayEvery(\n    array,\n    (value, index) => index == 0 || sorter(array[index - 1], value) <= 0,\n  );\nconst arraySort = (array, sorter) => array.sort(sorter);\nconst arrayForEach = (array, cb) => array.forEach(cb);\nconst arrayMap = (array, cb) => array.map(cb);\nconst arraySum = (array) => arrayReduce(array, (i, j) => i + j, 0);\nconst arrayIsEmpty = (array) => size(array) == 0;\nconst arrayReduce = (array, cb, initial) => array.reduce(cb, initial);\nconst arrayClear = (array, to) => array.splice(0, to);\nconst arrayPush = (array, ...values) => array.push(...values);\nconst arrayPop = (array) => array.pop();\nconst arrayUnshift = (array, ...values) => array.unshift(...values);\nconst arrayShift = (array) => array.shift();\n\nconst object = Object;\nconst getPrototypeOf = (obj) => object.getPrototypeOf(obj);\nconst objEntries = object.entries;\nconst objFrozen = object.isFrozen;\nconst isObject = (obj) =>\n  !isUndefined(obj) &&\n  ifNotUndefined(\n    getPrototypeOf(obj),\n    (objPrototype) =>\n      objPrototype == object.prototype ||\n      isUndefined(getPrototypeOf(objPrototype)),\n\n    /* istanbul ignore next */\n    () => true,\n  );\nconst objIds = object.keys;\nconst objFreeze = object.freeze;\nconst objNew = (entries = []) => object.fromEntries(entries);\nconst objHas = (obj, id) => id in obj;\nconst objDel = (obj, id) => {\n  delete obj[id];\n  return obj;\n};\nconst objForEach = (obj, cb) =>\n  arrayForEach(objEntries(obj), ([id, value]) => cb(value, id));\nconst objToArray = (obj, cb) =>\n  arrayMap(objEntries(obj), ([id, value]) => cb(value, id));\nconst objMap = (obj, cb) =>\n  objNew(objToArray(obj, (value, id) => [id, cb(value, id)]));\nconst objSize = (obj) => size(objIds(obj));\nconst objIsEmpty = (obj) => isObject(obj) && objSize(obj) == 0;\nconst objEnsure = (obj, id, getDefaultValue) => {\n  if (!objHas(obj, id)) {\n    obj[id] = getDefaultValue();\n  }\n  return obj[id];\n};\nconst objValidate = (obj, validateChild, onInvalidObj, emptyIsValid = 0) => {\n  if (\n    isUndefined(obj) ||\n    !isObject(obj) ||\n    (!emptyIsValid && objIsEmpty(obj)) ||\n    objFrozen(obj)\n  ) {\n    onInvalidObj?.();\n    return false;\n  }\n  objForEach(obj, (child, id) => {\n    if (!validateChild(child, id)) {\n      objDel(obj, id);\n    }\n  });\n  return emptyIsValid ? true : !objIsEmpty(obj);\n};\n\nconst collSizeN = (collSizer) => (coll) =>\n  arrayReduce(collValues(coll), (total, coll2) => total + collSizer(coll2), 0);\nconst collSize = (coll) => coll?.size ?? 0;\nconst collSize2 = collSizeN(collSize);\nconst collSize3 = collSizeN(collSize2);\nconst collSize4 = collSizeN(collSize3);\nconst collHas = (coll, keyOrValue) => coll?.has(keyOrValue) ?? false;\nconst collIsEmpty = (coll) => isUndefined(coll) || collSize(coll) == 0;\nconst collValues = (coll) => [...(coll?.values() ?? [])];\nconst collClear = (coll) => coll.clear();\nconst collForEach = (coll, cb) => coll?.forEach(cb);\nconst collDel = (coll, keyOrValue) => coll?.delete(keyOrValue);\n\nconst mapNew = (entries) => new Map(entries);\nconst mapKeys = (map) => [...(map?.keys() ?? [])];\nconst mapGet = (map, key) => map?.get(key);\nconst mapForEach = (map, cb) =>\n  collForEach(map, (value, key) => cb(key, value));\nconst mapMap = (coll, cb) =>\n  arrayMap([...(coll?.entries() ?? [])], ([key, value]) => cb(value, key));\nconst mapSet = (map, key, value) =>\n  isUndefined(value) ? (collDel(map, key), map) : map?.set(key, value);\nconst mapEnsure = (map, key, getDefaultValue, hadExistingValue) => {\n  if (!collHas(map, key)) {\n    mapSet(map, key, getDefaultValue());\n  } else {\n    hadExistingValue?.(mapGet(map, key));\n  }\n  return mapGet(map, key);\n};\nconst mapMatch = (map, obj, set, del = mapSet) => {\n  objMap(obj, (value, id) => set(map, id, value));\n  mapForEach(map, (id) => (objHas(obj, id) ? 0 : del(map, id)));\n  return map;\n};\nconst mapToObj = (map, valueMapper, excludeMapValue, excludeObjValue) => {\n  const obj = {};\n  collForEach(map, (mapValue, id) => {\n    if (!excludeMapValue?.(mapValue, id)) {\n      const objValue = valueMapper ? valueMapper(mapValue, id) : mapValue;\n      if (!excludeObjValue?.(objValue)) {\n        obj[id] = objValue;\n      }\n    }\n  });\n  return obj;\n};\nconst mapToObj2 = (map, valueMapper, excludeMapValue) =>\n  mapToObj(\n    map,\n    (childMap) => mapToObj(childMap, valueMapper, excludeMapValue),\n    collIsEmpty,\n    objIsEmpty,\n  );\nconst mapToObj3 = (map, valueMapper, excludeMapValue) =>\n  mapToObj(\n    map,\n    (childMap) => mapToObj2(childMap, valueMapper, excludeMapValue),\n    collIsEmpty,\n    objIsEmpty,\n  );\nconst mapClone = (map, mapValue) => {\n  const map2 = mapNew();\n  collForEach(map, (value, key) => map2.set(key, mapValue?.(value) ?? value));\n  return map2;\n};\nconst mapClone2 = (map) => mapClone(map, mapClone);\nconst mapClone3 = (map) => mapClone(map, mapClone2);\nconst visitTree = (node, path, ensureLeaf, pruneLeaf, p = 0) =>\n  ifNotUndefined(\n    (ensureLeaf ? mapEnsure : mapGet)(\n      node,\n      path[p],\n      p > size(path) - 2 ? ensureLeaf : mapNew,\n    ),\n    (nodeOrLeaf) => {\n      if (p > size(path) - 2) {\n        if (pruneLeaf?.(nodeOrLeaf)) {\n          mapSet(node, path[p]);\n        }\n        return nodeOrLeaf;\n      }\n      const leaf = visitTree(nodeOrLeaf, path, ensureLeaf, pruneLeaf, p + 1);\n      if (collIsEmpty(nodeOrLeaf)) {\n        mapSet(node, path[p]);\n      }\n      return leaf;\n    },\n  );\n\nconst getCellOrValueType = (cellOrValue) => {\n  const type = getTypeOf(cellOrValue);\n  return isTypeStringOrBoolean(type) ||\n    (type == NUMBER && isFiniteNumber(cellOrValue))\n    ? type\n    : void 0;\n};\nconst isCellOrValueOrNullOrUndefined = (cellOrValue) =>\n  isUndefined(cellOrValue) || !isUndefined(getCellOrValueType(cellOrValue));\nconst setOrDelCell = (store, tableId, rowId, cellId, cell) =>\n  isUndefined(cell)\n    ? store.delCell(tableId, rowId, cellId, true)\n    : store.setCell(tableId, rowId, cellId, cell);\nconst setOrDelValue = (store, valueId, value) =>\n  isUndefined(value) ? store.delValue(valueId) : store.setValue(valueId, value);\n\nconst setNew = (entryOrEntries) =>\n  new Set(\n    isArray(entryOrEntries) || isUndefined(entryOrEntries)\n      ? entryOrEntries\n      : [entryOrEntries],\n  );\nconst setAdd = (set, value) => set?.add(value);\n\nconst getDefinableFunctions = (\n  store,\n  getDefaultThing,\n  validateRowValue,\n  addListener,\n  callListeners,\n) => {\n  const hasRow = store.hasRow;\n  const tableIds = mapNew();\n  const things = mapNew();\n  const thingIdListeners = mapNew();\n  const allRowValues = mapNew();\n  const allSortKeys = mapNew();\n  const storeListenerIds = mapNew();\n  const getStore = () => store;\n  const getThingIds = () => mapKeys(tableIds);\n  const forEachThing = (cb) => mapForEach(things, cb);\n  const hasThing = (id) => collHas(things, id);\n  const getTableId = (id) => mapGet(tableIds, id);\n  const getThing = (id) => mapGet(things, id);\n  const setThing = (id, thing) => mapSet(things, id, thing);\n  const addStoreListeners = (id, andCall, ...listenerIds) => {\n    const set = mapEnsure(storeListenerIds, id, setNew);\n    arrayForEach(\n      listenerIds,\n      (listenerId) =>\n        setAdd(set, listenerId) && andCall && store.callListener(listenerId),\n    );\n    return listenerIds;\n  };\n  const delStoreListeners = (id, ...listenerIds) =>\n    ifNotUndefined(mapGet(storeListenerIds, id), (allListenerIds) => {\n      arrayForEach(\n        arrayIsEmpty(listenerIds) ? collValues(allListenerIds) : listenerIds,\n        (listenerId) => {\n          store.delListener(listenerId);\n          collDel(allListenerIds, listenerId);\n        },\n      );\n      if (collIsEmpty(allListenerIds)) {\n        mapSet(storeListenerIds, id);\n      }\n    });\n  const setDefinition = (id, tableId) => {\n    mapSet(tableIds, id, tableId);\n    if (!collHas(things, id)) {\n      mapSet(things, id, getDefaultThing());\n      mapSet(allRowValues, id, mapNew());\n      mapSet(allSortKeys, id, mapNew());\n      callListeners(thingIdListeners);\n    }\n  };\n  const setDefinitionAndListen = (\n    id,\n    tableId,\n    onChanged,\n    getRowValue,\n    getSortKey,\n  ) => {\n    setDefinition(id, tableId);\n    const changedRowValues = mapNew();\n    const changedSortKeys = mapNew();\n    const rowValues = mapGet(allRowValues, id);\n    const sortKeys = mapGet(allSortKeys, id);\n    const processRow = (rowId) => {\n      const getCell = (cellId) => store.getCell(tableId, rowId, cellId);\n      const oldRowValue = mapGet(rowValues, rowId);\n      const newRowValue = hasRow(tableId, rowId)\n        ? validateRowValue(getRowValue(getCell, rowId))\n        : void 0;\n      if (\n        !(\n          oldRowValue === newRowValue ||\n          (isArray(oldRowValue) &&\n            isArray(newRowValue) &&\n            arrayIsEqual(oldRowValue, newRowValue))\n        )\n      ) {\n        mapSet(changedRowValues, rowId, [oldRowValue, newRowValue]);\n      }\n      if (!isUndefined(getSortKey)) {\n        const oldSortKey = mapGet(sortKeys, rowId);\n        const newSortKey = hasRow(tableId, rowId)\n          ? getSortKey(getCell, rowId)\n          : void 0;\n        if (oldSortKey != newSortKey) {\n          mapSet(changedSortKeys, rowId, newSortKey);\n        }\n      }\n    };\n    const processTable = (force) => {\n      onChanged(\n        () => {\n          collForEach(changedRowValues, ([, newRowValue], rowId) =>\n            mapSet(rowValues, rowId, newRowValue),\n          );\n          collForEach(changedSortKeys, (newSortKey, rowId) =>\n            mapSet(sortKeys, rowId, newSortKey),\n          );\n        },\n        changedRowValues,\n        changedSortKeys,\n        rowValues,\n        sortKeys,\n        force,\n      );\n      collClear(changedRowValues);\n      collClear(changedSortKeys);\n    };\n    mapForEach(rowValues, processRow);\n    if (store.hasTable(tableId)) {\n      arrayForEach(store.getRowIds(tableId), (rowId) => {\n        if (!collHas(rowValues, rowId)) {\n          processRow(rowId);\n        }\n      });\n    }\n    processTable(true);\n    delStoreListeners(id);\n    addStoreListeners(\n      id,\n      0,\n      store.addRowListener(tableId, null, (_store, _tableId, rowId) =>\n        processRow(rowId),\n      ),\n      store.addTableListener(tableId, () => processTable()),\n    );\n  };\n  const delDefinition = (id) => {\n    mapSet(tableIds, id);\n    mapSet(things, id);\n    mapSet(allRowValues, id);\n    mapSet(allSortKeys, id);\n    delStoreListeners(id);\n    callListeners(thingIdListeners);\n  };\n  const addThingIdsListener = (listener) =>\n    addListener(listener, thingIdListeners);\n  const destroy = () => mapForEach(storeListenerIds, delDefinition);\n  return [\n    getStore,\n    getThingIds,\n    forEachThing,\n    hasThing,\n    getTableId,\n    getThing,\n    setThing,\n    setDefinition,\n    setDefinitionAndListen,\n    delDefinition,\n    addThingIdsListener,\n    destroy,\n    addStoreListeners,\n    delStoreListeners,\n  ];\n};\nconst getRowCellFunction = (getRowCell, defaultCellValue) =>\n  isString(getRowCell)\n    ? (getCell) => getCell(getRowCell)\n    : (getRowCell ?? (() => defaultCellValue ?? EMPTY_STRING));\nconst getCreateFunction = (getFunction, initFunction) => {\n  const thingsByStore = /* @__PURE__ */ new WeakMap();\n  return (store) => {\n    if (!thingsByStore.has(store)) {\n      thingsByStore.set(store, getFunction(store));\n    }\n    const thing = thingsByStore.get(store);\n    initFunction?.(thing);\n    return thing;\n  };\n};\n\nconst INTEGER = /^\\d+$/;\nconst getPoolFunctions = () => {\n  const pool = [];\n  let nextId = 0;\n  return [\n    (reuse) => (reuse ? arrayShift(pool) : null) ?? EMPTY_STRING + nextId++,\n    (id) => {\n      if (test(INTEGER, id) && size(pool) < 1e3) {\n        arrayPush(pool, id);\n      }\n    },\n  ];\n};\n\nconst getWildcardedLeaves = (deepIdSet, path = [EMPTY_STRING]) => {\n  const leaves = [];\n  const deep = (node, p) =>\n    p == size(path)\n      ? arrayPush(leaves, node)\n      : path[p] === null\n        ? collForEach(node, (node2) => deep(node2, p + 1))\n        : arrayForEach([path[p], null], (id) => deep(mapGet(node, id), p + 1));\n  deep(deepIdSet, 0);\n  return leaves;\n};\nconst getListenerFunctions = (getThing) => {\n  let thing;\n  const [getId, releaseId] = getPoolFunctions();\n  const allListeners = mapNew();\n  const addListener = (\n    listener,\n    idSetNode,\n    path,\n    pathGetters = [],\n    extraArgsGetter = () => [],\n  ) => {\n    thing ??= getThing();\n    const id = getId(1);\n    mapSet(allListeners, id, [\n      listener,\n      idSetNode,\n      path,\n      pathGetters,\n      extraArgsGetter,\n    ]);\n    setAdd(visitTree(idSetNode, path ?? [EMPTY_STRING], setNew), id);\n    return id;\n  };\n  const callListeners = (idSetNode, ids, ...extraArgs) =>\n    arrayForEach(getWildcardedLeaves(idSetNode, ids), (set) =>\n      collForEach(set, (id) =>\n        mapGet(allListeners, id)[0](thing, ...(ids ?? []), ...extraArgs),\n      ),\n    );\n  const delListener = (id) =>\n    ifNotUndefined(mapGet(allListeners, id), ([, idSetNode, idOrNulls]) => {\n      visitTree(idSetNode, idOrNulls ?? [EMPTY_STRING], void 0, (idSet) => {\n        collDel(idSet, id);\n        return collIsEmpty(idSet) ? 1 : 0;\n      });\n      mapSet(allListeners, id);\n      releaseId(id);\n      return idOrNulls;\n    });\n  const callListener = (id) =>\n    ifNotUndefined(\n      mapGet(allListeners, id),\n      ([listener, , path = [], pathGetters, extraArgsGetter]) => {\n        const callWithIds = (...ids) => {\n          const index = size(ids);\n          if (index == size(path)) {\n            listener(thing, ...ids, ...extraArgsGetter(ids));\n          } else if (isUndefined(path[index])) {\n            arrayForEach(pathGetters[index]?.(...ids) ?? [], (id2) =>\n              callWithIds(...ids, id2),\n            );\n          } else {\n            callWithIds(...ids, path[index]);\n          }\n        };\n        callWithIds();\n      },\n    );\n  return [addListener, callListeners, delListener, callListener];\n};\n\nconst createCheckpoints = getCreateFunction(\n  (store) => {\n    let backwardIdsSize = 100;\n    let currentId;\n    let cellsDelta = mapNew();\n    let valuesDelta = mapNew();\n    let listening = 1;\n    let nextCheckpointId;\n    let checkpointsChanged;\n    const checkpointIdsListeners = mapNew();\n    const checkpointListeners = mapNew();\n    const [addListener, callListeners, delListenerImpl] = getListenerFunctions(\n      () => checkpoints,\n    );\n    const deltas = mapNew();\n    const labels = mapNew();\n    const backwardIds = [];\n    const forwardIds = [];\n    const updateStore = (oldOrNew, checkpointId) => {\n      listening = 0;\n      store.transaction(() => {\n        const [cellsDelta2, valuesDelta2] = mapGet(deltas, checkpointId);\n        collForEach(cellsDelta2, (table, tableId) =>\n          collForEach(table, (row, rowId) =>\n            collForEach(row, (oldNew, cellId) =>\n              setOrDelCell(store, tableId, rowId, cellId, oldNew[oldOrNew]),\n            ),\n          ),\n        );\n        collForEach(valuesDelta2, (oldNew, valueId) =>\n          setOrDelValue(store, valueId, oldNew[oldOrNew]),\n        );\n      });\n      listening = 1;\n    };\n    const clearCheckpointId = (checkpointId) => {\n      mapSet(deltas, checkpointId);\n      mapSet(labels, checkpointId);\n      callListeners(checkpointListeners, [checkpointId]);\n    };\n    const clearCheckpointIds = (checkpointIds, to) =>\n      arrayForEach(\n        arrayClear(checkpointIds, to ?? size(checkpointIds)),\n        clearCheckpointId,\n      );\n    const trimBackwardsIds = () =>\n      clearCheckpointIds(backwardIds, size(backwardIds) - backwardIdsSize);\n    const storeChanged = () =>\n      ifNotUndefined(currentId, () => {\n        arrayPush(backwardIds, currentId);\n        trimBackwardsIds();\n        clearCheckpointIds(forwardIds);\n        currentId = void 0;\n        checkpointsChanged = 1;\n      });\n    const storeUnchanged = () => {\n      currentId = arrayPop(backwardIds);\n      checkpointsChanged = 1;\n    };\n    let cellListenerId;\n    let valueListenerId;\n    const addCheckpointImpl = (label = EMPTY_STRING) => {\n      if (isUndefined(currentId)) {\n        currentId = EMPTY_STRING + nextCheckpointId++;\n        mapSet(deltas, currentId, [cellsDelta, valuesDelta]);\n        setCheckpoint(currentId, label);\n        cellsDelta = mapNew();\n        valuesDelta = mapNew();\n        checkpointsChanged = 1;\n      }\n      return currentId;\n    };\n    const goBackwardImpl = () => {\n      if (!arrayIsEmpty(backwardIds)) {\n        arrayUnshift(forwardIds, addCheckpointImpl());\n        updateStore(0, currentId);\n        currentId = arrayPop(backwardIds);\n        checkpointsChanged = 1;\n      }\n    };\n    const goForwardImpl = () => {\n      if (!arrayIsEmpty(forwardIds)) {\n        arrayPush(backwardIds, currentId);\n        currentId = arrayShift(forwardIds);\n        updateStore(1, currentId);\n        checkpointsChanged = 1;\n      }\n    };\n    const callListenersIfChanged = () => {\n      if (checkpointsChanged) {\n        callListeners(checkpointIdsListeners);\n        checkpointsChanged = 0;\n      }\n    };\n    const setSize = (size2) => {\n      backwardIdsSize = size2;\n      trimBackwardsIds();\n      return checkpoints;\n    };\n    const addCheckpoint = (label) => {\n      const id = addCheckpointImpl(label);\n      callListenersIfChanged();\n      return id;\n    };\n    const setCheckpoint = (checkpointId, label) => {\n      if (\n        hasCheckpoint(checkpointId) &&\n        mapGet(labels, checkpointId) !== label\n      ) {\n        mapSet(labels, checkpointId, label);\n        callListeners(checkpointListeners, [checkpointId]);\n      }\n      return checkpoints;\n    };\n    const getStore = () => store;\n    const getCheckpointIds = () => [\n      [...backwardIds],\n      currentId,\n      [...forwardIds],\n    ];\n    const forEachCheckpoint = (checkpointCallback) =>\n      mapForEach(labels, checkpointCallback);\n    const hasCheckpoint = (checkpointId) => collHas(deltas, checkpointId);\n    const getCheckpoint = (checkpointId) => mapGet(labels, checkpointId);\n    const goBackward = () => {\n      goBackwardImpl();\n      callListenersIfChanged();\n      return checkpoints;\n    };\n    const goForward = () => {\n      goForwardImpl();\n      callListenersIfChanged();\n      return checkpoints;\n    };\n    const goTo = (checkpointId) => {\n      const action = arrayHas(backwardIds, checkpointId)\n        ? goBackwardImpl\n        : arrayHas(forwardIds, checkpointId)\n          ? goForwardImpl\n          : null;\n      while (!isUndefined(action) && checkpointId != currentId) {\n        action();\n      }\n      callListenersIfChanged();\n      return checkpoints;\n    };\n    const addCheckpointIdsListener = (listener) =>\n      addListener(listener, checkpointIdsListeners);\n    const addCheckpointListener = (checkpointId, listener) =>\n      addListener(listener, checkpointListeners, [checkpointId]);\n    const delListener = (listenerId) => {\n      delListenerImpl(listenerId);\n      return checkpoints;\n    };\n    const clear = () => {\n      clearCheckpointIds(backwardIds);\n      clearCheckpointIds(forwardIds);\n      if (!isUndefined(currentId)) {\n        clearCheckpointId(currentId);\n      }\n      currentId = void 0;\n      nextCheckpointId = 0;\n      addCheckpoint();\n      return checkpoints;\n    };\n    const clearForward = () => {\n      if (!arrayIsEmpty(forwardIds)) {\n        clearCheckpointIds(forwardIds);\n        callListeners(checkpointIdsListeners);\n      }\n      return checkpoints;\n    };\n    const destroy = () => {\n      store.delListener(cellListenerId);\n      store.delListener(valueListenerId);\n    };\n    const getListenerStats = () => ({\n      checkpointIds: collSize2(checkpointIdsListeners),\n      checkpoint: collSize2(checkpointListeners),\n    });\n    const _registerListeners = () => {\n      cellListenerId = store.addCellListener(\n        null,\n        null,\n        null,\n        (_store, tableId, rowId, cellId, newCell, oldCell) => {\n          if (listening) {\n            storeChanged();\n            const table = mapEnsure(cellsDelta, tableId, mapNew);\n            const row = mapEnsure(table, rowId, mapNew);\n            const oldNew = mapEnsure(row, cellId, () => [oldCell, void 0]);\n            oldNew[1] = newCell;\n            if (\n              oldNew[0] === newCell &&\n              collIsEmpty(mapSet(row, cellId)) &&\n              collIsEmpty(mapSet(table, rowId)) &&\n              collIsEmpty(mapSet(cellsDelta, tableId))\n            ) {\n              storeUnchanged();\n            }\n            callListenersIfChanged();\n          }\n        },\n      );\n      valueListenerId = store.addValueListener(\n        null,\n        (_store, valueId, newValue, oldValue) => {\n          if (listening) {\n            storeChanged();\n            const oldNew = mapEnsure(valuesDelta, valueId, () => [\n              oldValue,\n              void 0,\n            ]);\n            oldNew[1] = newValue;\n            if (\n              oldNew[0] === newValue &&\n              collIsEmpty(mapSet(valuesDelta, valueId))\n            ) {\n              storeUnchanged();\n            }\n            callListenersIfChanged();\n          }\n        },\n      );\n    };\n    const checkpoints = {\n      setSize,\n      addCheckpoint,\n      setCheckpoint,\n      getStore,\n      getCheckpointIds,\n      forEachCheckpoint,\n      hasCheckpoint,\n      getCheckpoint,\n      goBackward,\n      goForward,\n      goTo,\n      addCheckpointIdsListener,\n      addCheckpointListener,\n      delListener,\n      clear,\n      clearForward,\n      destroy,\n      getListenerStats,\n      _registerListeners,\n    };\n    return objFreeze(checkpoints.clear());\n  },\n  (checkpoints) => checkpoints._registerListeners(),\n);\n\nconst MASK6 = 63;\nconst ENCODE = /* @__PURE__ */ strSplit(\n  '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz',\n);\nconst DECODE = /* @__PURE__ */ mapNew(\n  /* @__PURE__ */ arrayMap(ENCODE, (char, index) => [char, index]),\n);\nconst encode = (num) => ENCODE[num & MASK6];\nconst decode = (str, pos) => mapGet(DECODE, str[pos]) ?? 0;\n\nconst getRandomValues = GLOBAL.crypto\n  ? (array) => GLOBAL.crypto.getRandomValues(array)\n  : /* istanbul ignore next */\n    (array) => arrayMap(array, () => mathFloor(math.random() * 256));\nconst defaultSorter = (sortKey1, sortKey2) =>\n  (sortKey1 ?? 0) < (sortKey2 ?? 0) ? -1 : 1;\nconst getUniqueId = (length = 16) =>\n  arrayReduce(\n    getRandomValues(new Uint8Array(length)),\n    (uniqueId, number) => uniqueId + encode(number),\n    '',\n  );\n\nconst createIndexes = getCreateFunction((store) => {\n  const sliceIdsListeners = mapNew();\n  const sliceRowIdsListeners = mapNew();\n  const [addListener, callListeners, delListenerImpl] = getListenerFunctions(\n    () => indexes,\n  );\n  const [\n    getStore,\n    getIndexIds,\n    forEachIndexImpl,\n    hasIndex,\n    getTableId,\n    getIndex,\n    setIndex,\n    ,\n    setDefinitionAndListen,\n    delDefinition,\n    addIndexIdsListener,\n    destroy,\n  ] = getDefinableFunctions(\n    store,\n    mapNew,\n    (value) =>\n      isUndefined(value)\n        ? EMPTY_STRING\n        : isArray(value)\n          ? arrayMap(value, id)\n          : id(value),\n    addListener,\n    callListeners,\n  );\n  const hasSlice = (indexId, sliceId) => collHas(getIndex(indexId), sliceId);\n  const setIndexDefinition = (\n    indexId,\n    tableId,\n    getSliceIdOrIds,\n    getSortKey,\n    sliceIdSorter,\n    rowIdSorter = defaultSorter,\n  ) => {\n    const sliceIdArraySorter = isUndefined(sliceIdSorter)\n      ? void 0\n      : ([id1], [id2]) => sliceIdSorter(id1, id2);\n    setDefinitionAndListen(\n      indexId,\n      tableId,\n      (change, changedSliceIds, changedSortKeys, sliceIds, sortKeys, force) => {\n        let sliceIdsChanged = 0;\n        const changedSlices = setNew();\n        const unsortedSlices = setNew();\n        const index = getIndex(indexId);\n        collForEach(\n          changedSliceIds,\n          ([oldSliceIdOrIds, newSliceIdOrIds], rowId) => {\n            const oldSliceIds = setNew(oldSliceIdOrIds);\n            const newSliceIds = setNew(newSliceIdOrIds);\n            collForEach(oldSliceIds, (oldSliceId) =>\n              collDel(newSliceIds, oldSliceId)\n                ? collDel(oldSliceIds, oldSliceId)\n                : 0,\n            );\n            collForEach(oldSliceIds, (oldSliceId) => {\n              setAdd(changedSlices, oldSliceId);\n              ifNotUndefined(mapGet(index, oldSliceId), (oldSlice) => {\n                collDel(oldSlice, rowId);\n                if (collIsEmpty(oldSlice)) {\n                  mapSet(index, oldSliceId);\n                  sliceIdsChanged = 1;\n                }\n              });\n            });\n            collForEach(newSliceIds, (newSliceId) => {\n              setAdd(changedSlices, newSliceId);\n              if (!collHas(index, newSliceId)) {\n                mapSet(index, newSliceId, setNew());\n                sliceIdsChanged = 1;\n              }\n              setAdd(mapGet(index, newSliceId), rowId);\n              if (!isUndefined(getSortKey)) {\n                setAdd(unsortedSlices, newSliceId);\n              }\n            });\n          },\n        );\n        change();\n        if (!collIsEmpty(sortKeys)) {\n          if (force) {\n            mapForEach(index, (sliceId) => setAdd(unsortedSlices, sliceId));\n          } else {\n            mapForEach(changedSortKeys, (rowId) =>\n              ifNotUndefined(mapGet(sliceIds, rowId), (sliceId) =>\n                setAdd(unsortedSlices, sliceId),\n              ),\n            );\n          }\n          collForEach(unsortedSlices, (sliceId) => {\n            const rowIdArraySorter = (rowId1, rowId2) =>\n              rowIdSorter(\n                mapGet(sortKeys, rowId1),\n                mapGet(sortKeys, rowId2),\n                sliceId,\n              );\n            const sliceArray = [...mapGet(index, sliceId)];\n            if (!arrayIsSorted(sliceArray, rowIdArraySorter)) {\n              mapSet(\n                index,\n                sliceId,\n                setNew(arraySort(sliceArray, rowIdArraySorter)),\n              );\n              setAdd(changedSlices, sliceId);\n            }\n          });\n        }\n        if (sliceIdsChanged || force) {\n          if (!isUndefined(sliceIdArraySorter)) {\n            const indexArray = [...index];\n            if (!arrayIsSorted(indexArray, sliceIdArraySorter)) {\n              setIndex(\n                indexId,\n                mapNew(arraySort(indexArray, sliceIdArraySorter)),\n              );\n              sliceIdsChanged = 1;\n            }\n          }\n        }\n        if (sliceIdsChanged) {\n          callListeners(sliceIdsListeners, [indexId]);\n        }\n        collForEach(changedSlices, (sliceId) =>\n          callListeners(sliceRowIdsListeners, [indexId, sliceId]),\n        );\n      },\n      getRowCellFunction(getSliceIdOrIds),\n      ifNotUndefined(getSortKey, getRowCellFunction),\n    );\n    return indexes;\n  };\n  const forEachIndex = (indexCallback) =>\n    forEachIndexImpl((indexId, slices) =>\n      indexCallback(indexId, (sliceCallback) =>\n        forEachSliceImpl(indexId, sliceCallback, slices),\n      ),\n    );\n  const forEachSlice = (indexId, sliceCallback) =>\n    forEachSliceImpl(indexId, sliceCallback, getIndex(indexId));\n  const forEachSliceImpl = (indexId, sliceCallback, slices) => {\n    const tableId = getTableId(indexId);\n    collForEach(slices, (rowIds, sliceId) =>\n      sliceCallback(sliceId, (rowCallback) =>\n        collForEach(rowIds, (rowId) =>\n          rowCallback(rowId, (cellCallback) =>\n            store.forEachCell(tableId, rowId, cellCallback),\n          ),\n        ),\n      ),\n    );\n  };\n  const delIndexDefinition = (indexId) => {\n    delDefinition(indexId);\n    return indexes;\n  };\n  const getSliceIds = (indexId) => mapKeys(getIndex(indexId));\n  const getSliceRowIds = (indexId, sliceId) =>\n    collValues(mapGet(getIndex(indexId), sliceId));\n  const addSliceIdsListener = (indexId, listener) =>\n    addListener(listener, sliceIdsListeners, [indexId]);\n  const addSliceRowIdsListener = (indexId, sliceId, listener) =>\n    addListener(listener, sliceRowIdsListeners, [indexId, sliceId]);\n  const delListener = (listenerId) => {\n    delListenerImpl(listenerId);\n    return indexes;\n  };\n  const getListenerStats = () => ({\n    sliceIds: collSize2(sliceIdsListeners),\n    sliceRowIds: collSize3(sliceRowIdsListeners),\n  });\n  const indexes = {\n    setIndexDefinition,\n    delIndexDefinition,\n    getStore,\n    getIndexIds,\n    forEachIndex,\n    forEachSlice,\n    hasIndex,\n    hasSlice,\n    getTableId,\n    getSliceIds,\n    getSliceRowIds,\n    addIndexIdsListener,\n    addSliceIdsListener,\n    addSliceRowIdsListener,\n    delListener,\n    destroy,\n    getListenerStats,\n  };\n  return objFreeze(indexes);\n});\n\nconst numericAggregators = /* @__PURE__ */ mapNew([\n  [\n    AVG,\n    [\n      (numbers, length) => arraySum(numbers) / length,\n      (metric, add, length) => metric + (add - metric) / (length + 1),\n      (metric, remove, length) => metric + (metric - remove) / (length - 1),\n      (metric, add, remove, length) => metric + (add - remove) / length,\n    ],\n  ],\n  [\n    MAX,\n    [\n      (numbers) => mathMax(...numbers),\n      (metric, add) => mathMax(add, metric),\n      (metric, remove) => (remove == metric ? void 0 : metric),\n      (metric, add, remove) =>\n        remove == metric ? void 0 : mathMax(add, metric),\n    ],\n  ],\n  [\n    MIN,\n    [\n      (numbers) => mathMin(...numbers),\n      (metric, add) => mathMin(add, metric),\n      (metric, remove) => (remove == metric ? void 0 : metric),\n      (metric, add, remove) =>\n        remove == metric ? void 0 : mathMin(add, metric),\n    ],\n  ],\n  [\n    SUM,\n    [\n      (numbers) => arraySum(numbers),\n      (metric, add) => metric + add,\n      (metric, remove) => metric - remove,\n      (metric, add, remove) => metric - remove + add,\n    ],\n  ],\n]);\nconst getAggregateValue = (\n  aggregateValue,\n  oldLength,\n  newValues,\n  changedValues,\n  aggregators,\n  force = false,\n) => {\n  if (collIsEmpty(newValues)) {\n    return void 0;\n  }\n  const [aggregate, aggregateAdd, aggregateRemove, aggregateReplace] =\n    aggregators;\n  force ||= isUndefined(aggregateValue);\n  collForEach(changedValues, ([oldValue, newValue]) => {\n    if (!force) {\n      aggregateValue = isUndefined(oldValue)\n        ? aggregateAdd?.(aggregateValue, newValue, oldLength++)\n        : isUndefined(newValue)\n          ? aggregateRemove?.(aggregateValue, oldValue, oldLength--)\n          : aggregateReplace?.(aggregateValue, newValue, oldValue, oldLength);\n      force ||= isUndefined(aggregateValue);\n    }\n  });\n  return force\n    ? aggregate(collValues(newValues), collSize(newValues))\n    : aggregateValue;\n};\n\nconst createMetrics = getCreateFunction((store) => {\n  const metricListeners = mapNew();\n  const [addListener, callListeners, delListenerImpl] = getListenerFunctions(\n    () => metrics,\n  );\n  const [\n    getStore,\n    getMetricIds,\n    forEachMetric,\n    hasMetric,\n    getTableId,\n    getMetric,\n    setMetric,\n    ,\n    setDefinitionAndListen,\n    delDefinition,\n    addMetricIdsListener,\n    destroy,\n  ] = getDefinableFunctions(\n    store,\n    getUndefined,\n    (value) =>\n      isNaN(value) ||\n      isUndefined(value) ||\n      value === true ||\n      value === false ||\n      value === EMPTY_STRING\n        ? void 0\n        : value * 1,\n    addListener,\n    callListeners,\n  );\n  const setMetricDefinition = (\n    metricId,\n    tableId,\n    aggregate,\n    getNumber,\n    aggregateAdd,\n    aggregateRemove,\n    aggregateReplace,\n  ) => {\n    const aggregators = isFunction(aggregate)\n      ? [aggregate, aggregateAdd, aggregateRemove, aggregateReplace]\n      : (mapGet(numericAggregators, aggregate) ??\n        mapGet(numericAggregators, SUM));\n    setDefinitionAndListen(\n      metricId,\n      tableId,\n      (change, changedNumbers, _changedSortKeys, numbers, _sortKeys, force) => {\n        const oldMetric = getMetric(metricId);\n        const oldLength = collSize(numbers);\n        force ||= isUndefined(oldMetric);\n        change();\n        let newMetric = getAggregateValue(\n          oldMetric,\n          oldLength,\n          numbers,\n          changedNumbers,\n          aggregators,\n          force,\n        );\n        if (!isFiniteNumber(newMetric)) {\n          newMetric = void 0;\n        }\n        if (newMetric != oldMetric) {\n          setMetric(metricId, newMetric);\n          callListeners(metricListeners, [metricId], newMetric, oldMetric);\n        }\n      },\n      getRowCellFunction(getNumber, 1),\n    );\n    return metrics;\n  };\n  const delMetricDefinition = (metricId) => {\n    delDefinition(metricId);\n    return metrics;\n  };\n  const addMetricListener = (metricId, listener) =>\n    addListener(listener, metricListeners, [metricId]);\n  const delListener = (listenerId) => {\n    delListenerImpl(listenerId);\n    return metrics;\n  };\n  const getListenerStats = () => ({\n    metric: collSize2(metricListeners),\n  });\n  const metrics = {\n    setMetricDefinition,\n    delMetricDefinition,\n    getStore,\n    getMetricIds,\n    forEachMetric,\n    hasMetric,\n    getTableId,\n    getMetric,\n    addMetricIdsListener,\n    addMetricListener,\n    delListener,\n    destroy,\n    getListenerStats,\n  };\n  return objFreeze(metrics);\n});\n\nconst createQueries = getCreateFunction((store) => {\n  const createStore = store.createStore;\n  const preStore = createStore();\n  const resultStore = createStore();\n  const preStoreListenerIds = mapNew();\n  const {\n    addListener,\n    callListeners,\n    delListener: delListenerImpl,\n  } = resultStore;\n  const [\n    getStore,\n    getQueryIds,\n    forEachQuery,\n    hasQuery,\n    getTableId,\n    ,\n    ,\n    setDefinition,\n    ,\n    delDefinition,\n    addQueryIdsListenerImpl,\n    destroy,\n    addStoreListeners,\n    delStoreListeners,\n  ] = getDefinableFunctions(\n    store,\n    () => true,\n    getUndefined,\n    addListener,\n    callListeners,\n  );\n  const addPreStoreListener = (preStore2, queryId, ...listenerIds) =>\n    arrayForEach(listenerIds, (listenerId) =>\n      setAdd(\n        mapEnsure(\n          mapEnsure(preStoreListenerIds, queryId, mapNew),\n          preStore2,\n          setNew,\n        ),\n        listenerId,\n      ),\n    );\n  const resetPreStores = (queryId) => {\n    ifNotUndefined(\n      mapGet(preStoreListenerIds, queryId),\n      (queryPreStoreListenerIds) => {\n        mapForEach(queryPreStoreListenerIds, (preStore2, listenerIds) =>\n          collForEach(listenerIds, (listenerId) =>\n            preStore2.delListener(listenerId),\n          ),\n        );\n        collClear(queryPreStoreListenerIds);\n      },\n    );\n    arrayForEach([resultStore, preStore], (store2) => store2.delTable(queryId));\n  };\n  const synchronizeTransactions = (queryId, fromStore, toStore) =>\n    addPreStoreListener(\n      fromStore,\n      queryId,\n      fromStore.addStartTransactionListener(toStore.startTransaction),\n      fromStore.addDidFinishTransactionListener(() =>\n        toStore.finishTransaction(),\n      ),\n    );\n  const setQueryDefinition = (queryId, tableId, build) => {\n    setDefinition(queryId, tableId);\n    resetPreStores(queryId);\n    const selectEntries = [];\n    const joinEntries = [[null, [tableId, null, null, [], mapNew()]]];\n    const wheres = [];\n    const groupEntries = [];\n    const havings = [];\n    const select = (arg1, arg2) => {\n      const selectEntry = isFunction(arg1)\n        ? [size(selectEntries) + EMPTY_STRING, arg1]\n        : [\n            isUndefined(arg2) ? arg1 : arg2,\n            (getTableCell) => getTableCell(arg1, arg2),\n          ];\n      arrayPush(selectEntries, selectEntry);\n      return {as: (selectedCellId) => (selectEntry[0] = selectedCellId)};\n    };\n    const join = (joinedTableId, arg1, arg2) => {\n      const fromIntermediateJoinedTableId =\n        isUndefined(arg2) || isFunction(arg1) ? null : arg1;\n      const onArg = isUndefined(fromIntermediateJoinedTableId) ? arg1 : arg2;\n      const joinEntry = [\n        joinedTableId,\n        [\n          joinedTableId,\n          fromIntermediateJoinedTableId,\n          isFunction(onArg) ? onArg : (getCell) => getCell(onArg),\n          [],\n          mapNew(),\n        ],\n      ];\n      arrayPush(joinEntries, joinEntry);\n      return {as: (joinedTableId2) => (joinEntry[0] = joinedTableId2)};\n    };\n    const where = (arg1, arg2, arg3) =>\n      arrayPush(\n        wheres,\n        isFunction(arg1)\n          ? arg1\n          : isUndefined(arg3)\n            ? (getTableCell) => getTableCell(arg1) === arg2\n            : (getTableCell) => getTableCell(arg1, arg2) === arg3,\n      );\n    const group = (\n      selectedCellId,\n      aggregate,\n      aggregateAdd,\n      aggregateRemove,\n      aggregateReplace,\n    ) => {\n      const groupEntry = [\n        selectedCellId,\n        [\n          selectedCellId,\n          isFunction(aggregate)\n            ? [aggregate, aggregateAdd, aggregateRemove, aggregateReplace]\n            : (mapGet(numericAggregators, aggregate) ?? [\n                (_cells, length) => length,\n              ]),\n        ],\n      ];\n      arrayPush(groupEntries, groupEntry);\n      return {as: (groupedCellId) => (groupEntry[0] = groupedCellId)};\n    };\n    const having = (arg1, arg2) =>\n      arrayPush(\n        havings,\n        isFunction(arg1)\n          ? arg1\n          : (getSelectedOrGroupedCell) =>\n              getSelectedOrGroupedCell(arg1) === arg2,\n      );\n    build({select, join, where, group, having});\n    const selects = mapNew(selectEntries);\n    if (collIsEmpty(selects)) {\n      return queries;\n    }\n    const joins = mapNew(joinEntries);\n    mapForEach(joins, (asTableId, [, fromAsTableId]) =>\n      ifNotUndefined(mapGet(joins, fromAsTableId), ({3: toAsTableIds}) =>\n        isUndefined(asTableId) ? 0 : arrayPush(toAsTableIds, asTableId),\n      ),\n    );\n    const groups = mapNew(groupEntries);\n    let selectJoinWhereStore = preStore;\n    if (collIsEmpty(groups) && arrayIsEmpty(havings)) {\n      selectJoinWhereStore = resultStore;\n    } else {\n      synchronizeTransactions(queryId, selectJoinWhereStore, resultStore);\n      const groupedSelectedCellIds = mapNew();\n      mapForEach(groups, (groupedCellId, [selectedCellId, aggregators]) =>\n        setAdd(mapEnsure(groupedSelectedCellIds, selectedCellId, setNew), [\n          groupedCellId,\n          aggregators,\n        ]),\n      );\n      const groupBySelectedCellIds = setNew();\n      mapForEach(selects, (selectedCellId) =>\n        collHas(groupedSelectedCellIds, selectedCellId)\n          ? 0\n          : setAdd(groupBySelectedCellIds, selectedCellId),\n      );\n      const tree = mapNew();\n      const writeGroupRow = (\n        leaf,\n        changedGroupedSelectedCells,\n        selectedRowId,\n        forceRemove,\n      ) =>\n        ifNotUndefined(\n          leaf,\n          ([selectedCells, selectedRowIds, groupRowId, groupRow]) => {\n            mapForEach(\n              changedGroupedSelectedCells,\n              (selectedCellId, [newCell]) => {\n                const selectedCell = mapEnsure(\n                  selectedCells,\n                  selectedCellId,\n                  mapNew,\n                );\n                const oldLeafCell = mapGet(selectedCell, selectedRowId);\n                const newLeafCell = forceRemove ? void 0 : newCell;\n                if (oldLeafCell !== newLeafCell) {\n                  const oldNewSet = setNew([[oldLeafCell, newLeafCell]]);\n                  const oldLength = collSize(selectedCell);\n                  mapSet(selectedCell, selectedRowId, newLeafCell);\n                  collForEach(\n                    mapGet(groupedSelectedCellIds, selectedCellId),\n                    ([groupedCellId, aggregators]) => {\n                      const aggregateValue = getAggregateValue(\n                        groupRow[groupedCellId],\n                        oldLength,\n                        selectedCell,\n                        oldNewSet,\n                        aggregators,\n                      );\n                      groupRow[groupedCellId] = isUndefined(\n                        getCellOrValueType(aggregateValue),\n                      )\n                        ? null\n                        : aggregateValue;\n                    },\n                  );\n                }\n              },\n            );\n            if (\n              collIsEmpty(selectedRowIds) ||\n              !arrayEvery(havings, (having2) =>\n                having2((cellId) => groupRow[cellId]),\n              )\n            ) {\n              resultStore.delRow(queryId, groupRowId);\n            } else if (isUndefined(groupRowId)) {\n              leaf[2] = resultStore.addRow(queryId, groupRow);\n            } else {\n              resultStore.setRow(queryId, groupRowId, groupRow);\n            }\n          },\n        );\n      addPreStoreListener(\n        selectJoinWhereStore,\n        queryId,\n        selectJoinWhereStore.addRowListener(\n          queryId,\n          null,\n          (_store, _tableId, selectedRowId, getCellChange) => {\n            const oldPath = [];\n            const newPath = [];\n            const changedGroupedSelectedCells = mapNew();\n            const rowExists = selectJoinWhereStore.hasRow(\n              queryId,\n              selectedRowId,\n            );\n            let changedLeaf = !rowExists;\n            collForEach(groupBySelectedCellIds, (selectedCellId) => {\n              const [changed, oldCell, newCell] = getCellChange(\n                queryId,\n                selectedRowId,\n                selectedCellId,\n              );\n              arrayPush(oldPath, oldCell);\n              arrayPush(newPath, newCell);\n              changedLeaf ||= changed;\n            });\n            mapForEach(groupedSelectedCellIds, (selectedCellId) => {\n              const [changed, , newCell] = getCellChange(\n                queryId,\n                selectedRowId,\n                selectedCellId,\n              );\n              if (changedLeaf || changed) {\n                mapSet(changedGroupedSelectedCells, selectedCellId, [newCell]);\n              }\n            });\n            if (changedLeaf) {\n              writeGroupRow(\n                visitTree(tree, oldPath, void 0, ([, selectedRowIds]) => {\n                  collDel(selectedRowIds, selectedRowId);\n                  return collIsEmpty(selectedRowIds);\n                }),\n                changedGroupedSelectedCells,\n                selectedRowId,\n                1,\n              );\n            }\n            if (rowExists) {\n              writeGroupRow(\n                visitTree(\n                  tree,\n                  newPath,\n                  () => {\n                    const groupRow = {};\n                    collForEach(\n                      groupBySelectedCellIds,\n                      (selectedCellId) =>\n                        (groupRow[selectedCellId] =\n                          selectJoinWhereStore.getCell(\n                            queryId,\n                            selectedRowId,\n                            selectedCellId,\n                          )),\n                    );\n                    return [mapNew(), setNew(), void 0, groupRow];\n                  },\n                  ([, selectedRowIds]) => {\n                    setAdd(selectedRowIds, selectedRowId);\n                  },\n                ),\n                changedGroupedSelectedCells,\n                selectedRowId,\n              );\n            }\n          },\n        ),\n      );\n    }\n    synchronizeTransactions(queryId, store, selectJoinWhereStore);\n    const writeSelectRow = (rootRowId) => {\n      const getTableCell = (arg1, arg2) =>\n        store.getCell(\n          ...(isUndefined(arg2)\n            ? [tableId, rootRowId, arg1]\n            : arg1 === tableId\n              ? [tableId, rootRowId, arg2]\n              : [\n                  mapGet(joins, arg1)?.[0],\n                  mapGet(mapGet(joins, arg1)?.[4], rootRowId)?.[0],\n                  arg2,\n                ]),\n        );\n      selectJoinWhereStore.transaction(() =>\n        arrayEvery(wheres, (where2) => where2(getTableCell))\n          ? mapForEach(selects, (asCellId, tableCellGetter) =>\n              setOrDelCell(\n                selectJoinWhereStore,\n                queryId,\n                rootRowId,\n                asCellId,\n                tableCellGetter(getTableCell, rootRowId),\n              ),\n            )\n          : selectJoinWhereStore.delRow(queryId, rootRowId),\n      );\n    };\n    const listenToTable = (rootRowId, tableId2, rowId, joinedTableIds2) => {\n      const getCell = (cellId) => store.getCell(tableId2, rowId, cellId);\n      arrayForEach(joinedTableIds2, (remoteAsTableId) => {\n        const [realJoinedTableId, , on, nextJoinedTableIds, remoteIdPair] =\n          mapGet(joins, remoteAsTableId);\n        const remoteRowId = on?.(getCell, rootRowId);\n        const [previousRemoteRowId, previousRemoteListenerId] =\n          mapGet(remoteIdPair, rootRowId) ?? [];\n        if (remoteRowId != previousRemoteRowId) {\n          if (!isUndefined(previousRemoteListenerId)) {\n            delStoreListeners(queryId, previousRemoteListenerId);\n          }\n          mapSet(\n            remoteIdPair,\n            rootRowId,\n            isUndefined(remoteRowId)\n              ? null\n              : [\n                  remoteRowId,\n                  ...addStoreListeners(\n                    queryId,\n                    1,\n                    store.addRowListener(realJoinedTableId, remoteRowId, () =>\n                      listenToTable(\n                        rootRowId,\n                        realJoinedTableId,\n                        remoteRowId,\n                        nextJoinedTableIds,\n                      ),\n                    ),\n                  ),\n                ],\n          );\n        }\n      });\n      writeSelectRow(rootRowId);\n    };\n    const {3: joinedTableIds} = mapGet(joins, null);\n    selectJoinWhereStore.transaction(() =>\n      addStoreListeners(\n        queryId,\n        1,\n        store.addRowListener(tableId, null, (_store, _tableId, rootRowId) => {\n          if (store.hasRow(tableId, rootRowId)) {\n            listenToTable(rootRowId, tableId, rootRowId, joinedTableIds);\n          } else {\n            selectJoinWhereStore.delRow(queryId, rootRowId);\n            collForEach(joins, ({4: idsByRootRowId}) =>\n              ifNotUndefined(\n                mapGet(idsByRootRowId, rootRowId),\n                ([, listenerId]) => {\n                  delStoreListeners(queryId, listenerId);\n                  mapSet(idsByRootRowId, rootRowId);\n                },\n              ),\n            );\n          }\n        }),\n      ),\n    );\n    return queries;\n  };\n  const delQueryDefinition = (queryId) => {\n    resetPreStores(queryId);\n    delDefinition(queryId);\n    return queries;\n  };\n  const addQueryIdsListener = (listener) =>\n    addQueryIdsListenerImpl(() => listener(queries));\n  const delListener = (listenerId) => {\n    delListenerImpl(listenerId);\n    return queries;\n  };\n  const getListenerStats = () => {\n    const {\n      tables: _1,\n      tableIds: _2,\n      transaction: _3,\n      ...stats\n    } = resultStore.getListenerStats();\n    return stats;\n  };\n  const queries = {\n    setQueryDefinition,\n    delQueryDefinition,\n    getStore,\n    getQueryIds,\n    forEachQuery,\n    hasQuery,\n    getTableId,\n    addQueryIdsListener,\n    delListener,\n    destroy,\n    getListenerStats,\n  };\n  objMap(\n    {\n      [TABLE]: [1, 1],\n      [TABLE + CELL_IDS]: [0, 1],\n      [ROW_COUNT]: [0, 1],\n      [ROW_IDS]: [0, 1],\n      [SORTED_ROW_IDS]: [0, 5],\n      [ROW]: [1, 2],\n      [CELL_IDS]: [0, 2],\n      [CELL]: [1, 3],\n    },\n    ([hasAndForEach, argumentCount], gettable) => {\n      arrayForEach(\n        hasAndForEach ? [GET, 'has', 'forEach'] : [GET],\n        (prefix) =>\n          (queries[prefix + RESULT + gettable] = (...args) =>\n            resultStore[prefix + gettable](...args)),\n      );\n      queries[ADD + RESULT + gettable + LISTENER] = (...args) =>\n        resultStore[ADD + gettable + LISTENER](\n          ...slice(args, 0, argumentCount),\n          (_store, ...listenerArgs) =>\n            args[argumentCount](queries, ...listenerArgs),\n          true,\n        );\n    },\n  );\n  return objFreeze(queries);\n});\n\nconst createRelationships = getCreateFunction((store) => {\n  const remoteTableIds = mapNew();\n  const remoteRowIdListeners = mapNew();\n  const localRowIdsListeners = mapNew();\n  const linkedRowIdsListeners = mapNew();\n  const [addListener, callListeners, delListenerImpl] = getListenerFunctions(\n    () => relationships,\n  );\n  const [\n    getStore,\n    getRelationshipIds,\n    forEachRelationshipImpl,\n    hasRelationship,\n    getLocalTableId,\n    getRelationship,\n    ,\n    ,\n    setDefinitionAndListen,\n    delDefinition,\n    addRelationshipIdsListener,\n    destroy,\n  ] = getDefinableFunctions(\n    store,\n    () => [mapNew(), mapNew(), mapNew(), mapNew()],\n    (value) => (isUndefined(value) ? void 0 : value + EMPTY_STRING),\n    addListener,\n    callListeners,\n  );\n  const getLinkedRowIdsCache = (relationshipId, firstRowId, skipCache) =>\n    ifNotUndefined(\n      getRelationship(relationshipId),\n      ([remoteRows, , linkedRowsCache]) => {\n        if (!collHas(linkedRowsCache, firstRowId)) {\n          const linkedRows = setNew();\n          if (\n            getLocalTableId(relationshipId) != getRemoteTableId(relationshipId)\n          ) {\n            setAdd(linkedRows, firstRowId);\n          } else {\n            let rowId = firstRowId;\n            while (!isUndefined(rowId) && !collHas(linkedRows, rowId)) {\n              setAdd(linkedRows, rowId);\n              rowId = mapGet(remoteRows, rowId);\n            }\n          }\n          if (skipCache) {\n            return linkedRows;\n          }\n          mapSet(linkedRowsCache, firstRowId, linkedRows);\n        }\n        return mapGet(linkedRowsCache, firstRowId);\n      },\n    );\n  const delLinkedRowIdsCache = (relationshipId, firstRowId) =>\n    ifNotUndefined(getRelationship(relationshipId), ([, , linkedRowsCache]) =>\n      mapSet(linkedRowsCache, firstRowId),\n    );\n  const setRelationshipDefinition = (\n    relationshipId,\n    localTableId,\n    remoteTableId,\n    getRemoteRowId2,\n  ) => {\n    mapSet(remoteTableIds, relationshipId, remoteTableId);\n    setDefinitionAndListen(\n      relationshipId,\n      localTableId,\n      (change, changedRemoteRowIds) => {\n        const changedLocalRows = setNew();\n        const changedRemoteRows = setNew();\n        const changedLinkedRows = setNew();\n        const [localRows, remoteRows] = getRelationship(relationshipId);\n        collForEach(\n          changedRemoteRowIds,\n          ([oldRemoteRowId, newRemoteRowId], localRowId) => {\n            if (!isUndefined(oldRemoteRowId)) {\n              setAdd(changedRemoteRows, oldRemoteRowId);\n              ifNotUndefined(\n                mapGet(remoteRows, oldRemoteRowId),\n                (oldRemoteRow) => {\n                  collDel(oldRemoteRow, localRowId);\n                  if (collIsEmpty(oldRemoteRow)) {\n                    mapSet(remoteRows, oldRemoteRowId);\n                  }\n                },\n              );\n            }\n            if (!isUndefined(newRemoteRowId)) {\n              setAdd(changedRemoteRows, newRemoteRowId);\n              if (!collHas(remoteRows, newRemoteRowId)) {\n                mapSet(remoteRows, newRemoteRowId, setNew());\n              }\n              setAdd(mapGet(remoteRows, newRemoteRowId), localRowId);\n            }\n            setAdd(changedLocalRows, localRowId);\n            mapSet(localRows, localRowId, newRemoteRowId);\n            mapForEach(\n              mapGet(linkedRowIdsListeners, relationshipId),\n              (firstRowId) => {\n                if (\n                  collHas(\n                    getLinkedRowIdsCache(relationshipId, firstRowId),\n                    localRowId,\n                  )\n                ) {\n                  setAdd(changedLinkedRows, firstRowId);\n                }\n              },\n            );\n          },\n        );\n        change();\n        collForEach(changedLocalRows, (localRowId) =>\n          callListeners(remoteRowIdListeners, [relationshipId, localRowId]),\n        );\n        collForEach(changedRemoteRows, (remoteRowId) =>\n          callListeners(localRowIdsListeners, [relationshipId, remoteRowId]),\n        );\n        collForEach(changedLinkedRows, (firstRowId) => {\n          delLinkedRowIdsCache(relationshipId, firstRowId);\n          callListeners(linkedRowIdsListeners, [relationshipId, firstRowId]);\n        });\n      },\n      getRowCellFunction(getRemoteRowId2),\n    );\n    return relationships;\n  };\n  const forEachRelationship = (relationshipCallback) =>\n    forEachRelationshipImpl((relationshipId) =>\n      relationshipCallback(relationshipId, (rowCallback) =>\n        store.forEachRow(getLocalTableId(relationshipId), rowCallback),\n      ),\n    );\n  const delRelationshipDefinition = (relationshipId) => {\n    mapSet(remoteTableIds, relationshipId);\n    delDefinition(relationshipId);\n    return relationships;\n  };\n  const getRemoteTableId = (relationshipId) =>\n    mapGet(remoteTableIds, relationshipId);\n  const getRemoteRowId = (relationshipId, localRowId) =>\n    mapGet(getRelationship(relationshipId)?.[0], localRowId);\n  const getLocalRowIds = (relationshipId, remoteRowId) =>\n    collValues(mapGet(getRelationship(relationshipId)?.[1], remoteRowId));\n  const getLinkedRowIds = (relationshipId, firstRowId) =>\n    isUndefined(getRelationship(relationshipId))\n      ? [firstRowId]\n      : collValues(getLinkedRowIdsCache(relationshipId, firstRowId, true));\n  const addRemoteRowIdListener = (relationshipId, localRowId, listener) =>\n    addListener(listener, remoteRowIdListeners, [relationshipId, localRowId]);\n  const addLocalRowIdsListener = (relationshipId, remoteRowId, listener) =>\n    addListener(listener, localRowIdsListeners, [relationshipId, remoteRowId]);\n  const addLinkedRowIdsListener = (relationshipId, firstRowId, listener) => {\n    getLinkedRowIdsCache(relationshipId, firstRowId);\n    return addListener(listener, linkedRowIdsListeners, [\n      relationshipId,\n      firstRowId,\n    ]);\n  };\n  const delListener = (listenerId) => {\n    delLinkedRowIdsCache(...(delListenerImpl(listenerId) ?? []));\n    return relationships;\n  };\n  const getListenerStats = () => ({\n    remoteRowId: collSize3(remoteRowIdListeners),\n    localRowIds: collSize3(localRowIdsListeners),\n    linkedRowIds: collSize3(linkedRowIdsListeners),\n  });\n  const relationships = {\n    setRelationshipDefinition,\n    delRelationshipDefinition,\n    getStore,\n    getRelationshipIds,\n    forEachRelationship,\n    hasRelationship,\n    getLocalTableId,\n    getRemoteTableId,\n    getRemoteRowId,\n    getLocalRowIds,\n    getLinkedRowIds,\n    addRelationshipIdsListener,\n    addRemoteRowIdListener,\n    addLocalRowIdsListener,\n    addLinkedRowIdsListener,\n    delListener,\n    destroy,\n    getListenerStats,\n  };\n  return objFreeze(relationships);\n});\n\nconst textEncoder = /* @__PURE__ */ new GLOBAL.TextEncoder();\nconst getHash = (value) => {\n  let hash = 2166136261;\n  arrayForEach(textEncoder.encode(value), (char) => {\n    hash ^= char;\n    hash +=\n      (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  });\n  return hash >>> 0;\n};\n\nconst stampClone = ([value, time]) => stampNew(value, time);\nconst stampCloneWithHash = ([value, time, hash]) => [value, time, hash];\nconst stampNew = (value, time) => (time ? [value, time] : [value]);\nconst stampNewWithHash = (value, time, hash) => [value, time, hash];\nconst getStampHash = (stamp) => stamp[2];\nconst hashIdAndHash = (id, hash) => getHash(id + ':' + hash);\nconst replaceTimeHash = (oldTime, newTime) =>\n  newTime > oldTime ? (oldTime ? getHash(oldTime) : 0) ^ getHash(newTime) : 0;\nconst getLatestTime = (time1, time2) =>\n  /* istanbul ignore next */\n  ((time1 ?? '') > (time2 ?? '') ? time1 : time2) ?? '';\nconst stampUpdate = (stamp, time, hash) => {\n  if (time > stamp[1]) {\n    stamp[1] = time;\n  }\n  stamp[2] = hash >>> 0;\n};\nconst stampNewObj = (time = EMPTY_STRING) => stampNew(objNew(), time);\nconst stampNewMap = (time = EMPTY_STRING) => [mapNew(), time, 0];\nconst stampMapToObjWithHash = (\n  [map, time, hash],\n  mapper = stampCloneWithHash,\n) => [mapToObj(map, mapper), time, hash];\nconst stampMapToObjWithoutHash = ([map, time], mapper = stampClone) =>\n  stampNew(mapToObj(map, mapper), time);\nconst stampValidate = (stamp, validateThing) =>\n  isArray(stamp) &&\n  size(stamp) == 3 &&\n  isString(stamp[1]) &&\n  getTypeOf(stamp[2]) == NUMBER &&\n  isFiniteNumber(stamp[2]) &&\n  validateThing(stamp[0]);\n\nconst pairNew = (value) => [value, value];\nconst pairCollSize2 = (pair, func = collSize2) => func(pair[0]) + func(pair[1]);\nconst pairNewMap = () => [mapNew(), mapNew()];\nconst pairClone = (array) => [...array];\nconst pairIsEqual = ([entry1, entry2]) => entry1 === entry2;\n\nconst jsonString = JSON.stringify;\nconst jsonParse = JSON.parse;\nconst jsonStringWithMap = (obj) =>\n  jsonString(obj, (_key, value) =>\n    isInstanceOf(value, Map) ? object.fromEntries([...value]) : value,\n  );\n\nconst idsChanged = (changedIds, id2, addedOrRemoved) =>\n  mapSet(\n    changedIds,\n    id2,\n    mapGet(changedIds, id2) == -addedOrRemoved ? void 0 : addedOrRemoved,\n  );\nconst createStore = () => {\n  let hasTablesSchema;\n  let hasValuesSchema;\n  let hadTables = false;\n  let hadValues = false;\n  let transactions = 0;\n  let internalListeners = [];\n  const changedTableIds = mapNew();\n  const changedTableCellIds = mapNew();\n  const changedRowCount = mapNew();\n  const changedRowIds = mapNew();\n  const changedCellIds = mapNew();\n  const changedCells = mapNew();\n  const changedValueIds = mapNew();\n  const changedValues = mapNew();\n  const invalidCells = mapNew();\n  const invalidValues = mapNew();\n  const tablesSchemaMap = mapNew();\n  const tablesSchemaRowCache = mapNew();\n  const valuesSchemaMap = mapNew();\n  const valuesDefaulted = mapNew();\n  const valuesNonDefaulted = setNew();\n  const tablePoolFunctions = mapNew();\n  const tableCellIds = mapNew();\n  const tablesMap = mapNew();\n  const valuesMap = mapNew();\n  const hasTablesListeners = pairNewMap();\n  const tablesListeners = pairNewMap();\n  const tableIdsListeners = pairNewMap();\n  const hasTableListeners = pairNewMap();\n  const tableListeners = pairNewMap();\n  const tableCellIdsListeners = pairNewMap();\n  const hasTableCellListeners = pairNewMap();\n  const rowCountListeners = pairNewMap();\n  const rowIdsListeners = pairNewMap();\n  const sortedRowIdsListeners = pairNewMap();\n  const hasRowListeners = pairNewMap();\n  const rowListeners = pairNewMap();\n  const cellIdsListeners = pairNewMap();\n  const hasCellListeners = pairNewMap();\n  const cellListeners = pairNewMap();\n  const invalidCellListeners = pairNewMap();\n  const invalidValueListeners = pairNewMap();\n  const hasValuesListeners = pairNewMap();\n  const valuesListeners = pairNewMap();\n  const valueIdsListeners = pairNewMap();\n  const hasValueListeners = pairNewMap();\n  const valueListeners = pairNewMap();\n  const startTransactionListeners = mapNew();\n  const finishTransactionListeners = pairNewMap();\n  const [addListener, callListeners, delListenerImpl, callListenerImpl] =\n    getListenerFunctions(() => store);\n  const validateTablesSchema = (tableSchema) =>\n    objValidate(tableSchema, (tableSchema2) =>\n      objValidate(tableSchema2, validateCellOrValueSchema),\n    );\n  const validateValuesSchema = (valuesSchema) =>\n    objValidate(valuesSchema, validateCellOrValueSchema);\n  const validateCellOrValueSchema = (schema) => {\n    if (!objValidate(schema, (_child, id2) => arrayHas([TYPE, DEFAULT], id2))) {\n      return false;\n    }\n    const type = schema[TYPE];\n    if (!isTypeStringOrBoolean(type) && type != NUMBER) {\n      return false;\n    }\n    if (getCellOrValueType(schema[DEFAULT]) != type) {\n      objDel(schema, DEFAULT);\n    }\n    return true;\n  };\n  const validateContent = isArray;\n  const validateTables = (tables) =>\n    objValidate(tables, validateTable, cellInvalid);\n  const validateTable = (table, tableId) =>\n    (!hasTablesSchema ||\n      collHas(tablesSchemaMap, tableId) ||\n      /* istanbul ignore next */\n      cellInvalid(tableId)) &&\n    objValidate(\n      table,\n      (row, rowId) => validateRow(tableId, rowId, row),\n      () => cellInvalid(tableId),\n    );\n  const validateRow = (tableId, rowId, row, skipDefaults) =>\n    objValidate(\n      skipDefaults ? row : addDefaultsToRow(row, tableId, rowId),\n      (cell, cellId) =>\n        ifNotUndefined(\n          getValidatedCell(tableId, rowId, cellId, cell),\n          (validCell) => {\n            row[cellId] = validCell;\n            return true;\n          },\n          () => false,\n        ),\n      () => cellInvalid(tableId, rowId),\n    );\n  const getValidatedCell = (tableId, rowId, cellId, cell) =>\n    hasTablesSchema\n      ? ifNotUndefined(\n          mapGet(mapGet(tablesSchemaMap, tableId), cellId),\n          (cellSchema) =>\n            getCellOrValueType(cell) != cellSchema[TYPE]\n              ? cellInvalid(tableId, rowId, cellId, cell, cellSchema[DEFAULT])\n              : cell,\n          () => cellInvalid(tableId, rowId, cellId, cell),\n        )\n      : isUndefined(getCellOrValueType(cell))\n        ? cellInvalid(tableId, rowId, cellId, cell)\n        : cell;\n  const validateValues = (values, skipDefaults) =>\n    objValidate(\n      skipDefaults ? values : addDefaultsToValues(values),\n      (value, valueId) =>\n        ifNotUndefined(\n          getValidatedValue(valueId, value),\n          (validValue) => {\n            values[valueId] = validValue;\n            return true;\n          },\n          () => false,\n        ),\n      () => valueInvalid(),\n    );\n  const getValidatedValue = (valueId, value) =>\n    hasValuesSchema\n      ? ifNotUndefined(\n          mapGet(valuesSchemaMap, valueId),\n          (valueSchema) =>\n            getCellOrValueType(value) != valueSchema[TYPE]\n              ? valueInvalid(valueId, value, valueSchema[DEFAULT])\n              : value,\n          () => valueInvalid(valueId, value),\n        )\n      : isUndefined(getCellOrValueType(value))\n        ? valueInvalid(valueId, value)\n        : value;\n  const addDefaultsToRow = (row, tableId, rowId) => {\n    ifNotUndefined(\n      mapGet(tablesSchemaRowCache, tableId),\n      ([rowDefaulted, rowNonDefaulted]) => {\n        collForEach(rowDefaulted, (cell, cellId) => {\n          if (!objHas(row, cellId)) {\n            row[cellId] = cell;\n          }\n        });\n        collForEach(rowNonDefaulted, (cellId) => {\n          if (!objHas(row, cellId)) {\n            cellInvalid(tableId, rowId, cellId);\n          }\n        });\n      },\n    );\n    return row;\n  };\n  const addDefaultsToValues = (values) => {\n    if (hasValuesSchema) {\n      collForEach(valuesDefaulted, (value, valueId) => {\n        if (!objHas(values, valueId)) {\n          values[valueId] = value;\n        }\n      });\n      collForEach(valuesNonDefaulted, (valueId) => {\n        if (!objHas(values, valueId)) {\n          valueInvalid(valueId);\n        }\n      });\n    }\n    return values;\n  };\n  const setValidTablesSchema = (tablesSchema) =>\n    mapMatch(\n      tablesSchemaMap,\n      tablesSchema,\n      (_tablesSchema, tableId, tableSchema) => {\n        const rowDefaulted = mapNew();\n        const rowNonDefaulted = setNew();\n        mapMatch(\n          mapEnsure(tablesSchemaMap, tableId, mapNew),\n          tableSchema,\n          (tableSchemaMap, cellId, cellSchema) => {\n            mapSet(tableSchemaMap, cellId, cellSchema);\n            ifNotUndefined(\n              cellSchema[DEFAULT],\n              (def) => mapSet(rowDefaulted, cellId, def),\n              () => setAdd(rowNonDefaulted, cellId),\n            );\n          },\n        );\n        mapSet(tablesSchemaRowCache, tableId, [rowDefaulted, rowNonDefaulted]);\n      },\n      (_tablesSchema, tableId) => {\n        mapSet(tablesSchemaMap, tableId);\n        mapSet(tablesSchemaRowCache, tableId);\n      },\n    );\n  const setValidValuesSchema = (valuesSchema) =>\n    mapMatch(\n      valuesSchemaMap,\n      valuesSchema,\n      (_valuesSchema, valueId, valueSchema) => {\n        mapSet(valuesSchemaMap, valueId, valueSchema);\n        ifNotUndefined(\n          valueSchema[DEFAULT],\n          (def) => mapSet(valuesDefaulted, valueId, def),\n          () => setAdd(valuesNonDefaulted, valueId),\n        );\n      },\n      (_valuesSchema, valueId) => {\n        mapSet(valuesSchemaMap, valueId);\n        mapSet(valuesDefaulted, valueId);\n        collDel(valuesNonDefaulted, valueId);\n      },\n    );\n  const setOrDelTables = (tables) =>\n    objIsEmpty(tables) ? delTables() : setTables(tables);\n  const setValidContent = ([tables, values]) => {\n    (objIsEmpty(tables) ? delTables : setTables)(tables);\n    (objIsEmpty(values) ? delValues : setValues)(values);\n  };\n  const setValidTables = (tables) =>\n    mapMatch(\n      tablesMap,\n      tables,\n      (_tables, tableId, table) => setValidTable(tableId, table),\n      (_tables, tableId) => delValidTable(tableId),\n    );\n  const setValidTable = (tableId, table) =>\n    mapMatch(\n      mapEnsure(tablesMap, tableId, () => {\n        tableIdsChanged(tableId, 1);\n        mapSet(tablePoolFunctions, tableId, getPoolFunctions());\n        mapSet(tableCellIds, tableId, mapNew());\n        return mapNew();\n      }),\n      table,\n      (tableMap, rowId, row) => setValidRow(tableId, tableMap, rowId, row),\n      (tableMap, rowId) => delValidRow(tableId, tableMap, rowId),\n    );\n  const setValidRow = (tableId, tableMap, rowId, row, forceDel) =>\n    mapMatch(\n      mapEnsure(tableMap, rowId, () => {\n        rowIdsChanged(tableId, rowId, 1);\n        return mapNew();\n      }),\n      row,\n      (rowMap, cellId, cell) =>\n        setValidCell(tableId, rowId, rowMap, cellId, cell),\n      (rowMap, cellId) =>\n        delValidCell(tableId, tableMap, rowId, rowMap, cellId, forceDel),\n    );\n  const setValidCell = (tableId, rowId, rowMap, cellId, cell) => {\n    if (!collHas(rowMap, cellId)) {\n      cellIdsChanged(tableId, rowId, cellId, 1);\n    }\n    const oldCell = mapGet(rowMap, cellId);\n    if (cell !== oldCell) {\n      cellChanged(tableId, rowId, cellId, oldCell, cell);\n      mapSet(rowMap, cellId, cell);\n    }\n  };\n  const setCellIntoDefaultRow = (tableId, tableMap, rowId, cellId, validCell) =>\n    ifNotUndefined(\n      mapGet(tableMap, rowId),\n      (rowMap) => setValidCell(tableId, rowId, rowMap, cellId, validCell),\n      () =>\n        setValidRow(\n          tableId,\n          tableMap,\n          rowId,\n          addDefaultsToRow({[cellId]: validCell}, tableId, rowId),\n        ),\n    );\n  const setOrDelValues = (values) =>\n    objIsEmpty(values) ? delValues() : setValues(values);\n  const setValidValues = (values) =>\n    mapMatch(\n      valuesMap,\n      values,\n      (_valuesMap, valueId, value) => setValidValue(valueId, value),\n      (_valuesMap, valueId) => delValidValue(valueId),\n    );\n  const setValidValue = (valueId, value) => {\n    if (!collHas(valuesMap, valueId)) {\n      valueIdsChanged(valueId, 1);\n    }\n    const oldValue = mapGet(valuesMap, valueId);\n    if (value !== oldValue) {\n      valueChanged(valueId, oldValue, value);\n      mapSet(valuesMap, valueId, value);\n    }\n  };\n  const getNewRowId = (tableId, reuse) => {\n    const [getId] = mapGet(tablePoolFunctions, tableId);\n    let rowId;\n    do {\n      rowId = getId(reuse);\n    } while (collHas(mapGet(tablesMap, tableId), rowId));\n    return rowId;\n  };\n  const getOrCreateTable = (tableId) =>\n    mapGet(tablesMap, tableId) ?? setValidTable(tableId, {});\n  const delValidTable = (tableId) => setValidTable(tableId, {});\n  const delValidRow = (tableId, tableMap, rowId) => {\n    const [, releaseId] = mapGet(tablePoolFunctions, tableId);\n    releaseId(rowId);\n    setValidRow(tableId, tableMap, rowId, {}, true);\n  };\n  const delValidCell = (tableId, table, rowId, row, cellId, forceDel) => {\n    const defaultCell = mapGet(\n      mapGet(tablesSchemaRowCache, tableId)?.[0],\n      cellId,\n    );\n    if (!isUndefined(defaultCell) && !forceDel) {\n      return setValidCell(tableId, rowId, row, cellId, defaultCell);\n    }\n    const delCell2 = (cellId2) => {\n      cellChanged(tableId, rowId, cellId2, mapGet(row, cellId2));\n      cellIdsChanged(tableId, rowId, cellId2, -1);\n      mapSet(row, cellId2);\n    };\n    if (isUndefined(defaultCell)) {\n      delCell2(cellId);\n    } else {\n      mapForEach(row, delCell2);\n    }\n    if (collIsEmpty(row)) {\n      rowIdsChanged(tableId, rowId, -1);\n      if (collIsEmpty(mapSet(table, rowId))) {\n        tableIdsChanged(tableId, -1);\n        mapSet(tablesMap, tableId);\n        mapSet(tablePoolFunctions, tableId);\n        mapSet(tableCellIds, tableId);\n      }\n    }\n  };\n  const delValidValue = (valueId) => {\n    const defaultValue = mapGet(valuesDefaulted, valueId);\n    if (!isUndefined(defaultValue)) {\n      return setValidValue(valueId, defaultValue);\n    }\n    valueChanged(valueId, mapGet(valuesMap, valueId));\n    valueIdsChanged(valueId, -1);\n    mapSet(valuesMap, valueId);\n  };\n  const tableIdsChanged = (tableId, addedOrRemoved) =>\n    idsChanged(changedTableIds, tableId, addedOrRemoved);\n  const rowIdsChanged = (tableId, rowId, addedOrRemoved) =>\n    idsChanged(\n      mapEnsure(changedRowIds, tableId, mapNew),\n      rowId,\n      addedOrRemoved,\n    ) &&\n    mapSet(\n      changedRowCount,\n      tableId,\n      mapEnsure(changedRowCount, tableId, () => 0) + addedOrRemoved,\n    );\n  const cellIdsChanged = (tableId, rowId, cellId, addedOrRemoved) => {\n    const cellIds = mapGet(tableCellIds, tableId);\n    const count = mapGet(cellIds, cellId) ?? 0;\n    if (\n      (count == 0 && addedOrRemoved == 1) ||\n      (count == 1 && addedOrRemoved == -1)\n    ) {\n      idsChanged(\n        mapEnsure(changedTableCellIds, tableId, mapNew),\n        cellId,\n        addedOrRemoved,\n      );\n    }\n    mapSet(\n      cellIds,\n      cellId,\n      count != -addedOrRemoved ? count + addedOrRemoved : null,\n    );\n    idsChanged(\n      mapEnsure(mapEnsure(changedCellIds, tableId, mapNew), rowId, mapNew),\n      cellId,\n      addedOrRemoved,\n    );\n  };\n  const cellChanged = (tableId, rowId, cellId, oldCell, newCell) => {\n    mapEnsure(\n      mapEnsure(mapEnsure(changedCells, tableId, mapNew), rowId, mapNew),\n      cellId,\n      () => [oldCell, 0],\n    )[1] = newCell;\n    internalListeners[3]?.(tableId, rowId, cellId, newCell);\n  };\n  const valueIdsChanged = (valueId, addedOrRemoved) =>\n    idsChanged(changedValueIds, valueId, addedOrRemoved);\n  const valueChanged = (valueId, oldValue, newValue) => {\n    mapEnsure(changedValues, valueId, () => [oldValue, 0])[1] = newValue;\n    internalListeners[4]?.(valueId, newValue);\n  };\n  const cellInvalid = (tableId, rowId, cellId, invalidCell, defaultedCell) => {\n    arrayPush(\n      mapEnsure(\n        mapEnsure(mapEnsure(invalidCells, tableId, mapNew), rowId, mapNew),\n        cellId,\n        () => [],\n      ),\n      invalidCell,\n    );\n    return defaultedCell;\n  };\n  const valueInvalid = (valueId, invalidValue, defaultedValue) => {\n    arrayPush(\n      mapEnsure(invalidValues, valueId, () => []),\n      invalidValue,\n    );\n    return defaultedValue;\n  };\n  const getCellChange = (tableId, rowId, cellId) =>\n    ifNotUndefined(\n      mapGet(mapGet(mapGet(changedCells, tableId), rowId), cellId),\n      ([oldCell, newCell]) => [true, oldCell, newCell],\n      () => [false, ...pairNew(getCell(tableId, rowId, cellId))],\n    );\n  const getValueChange = (valueId) =>\n    ifNotUndefined(\n      mapGet(changedValues, valueId),\n      ([oldValue, newValue]) => [true, oldValue, newValue],\n      () => [false, ...pairNew(getValue(valueId))],\n    );\n  const callInvalidCellListeners = (mutator) =>\n    !collIsEmpty(invalidCells) && !collIsEmpty(invalidCellListeners[mutator])\n      ? collForEach(\n          mutator ? mapClone3(invalidCells) : invalidCells,\n          (rows, tableId) =>\n            collForEach(rows, (cells, rowId) =>\n              collForEach(cells, (invalidCell, cellId) =>\n                callListeners(\n                  invalidCellListeners[mutator],\n                  [tableId, rowId, cellId],\n                  invalidCell,\n                ),\n              ),\n            ),\n        )\n      : 0;\n  const callInvalidValueListeners = (mutator) =>\n    !collIsEmpty(invalidValues) && !collIsEmpty(invalidValueListeners[mutator])\n      ? collForEach(\n          mutator ? mapClone(invalidValues) : invalidValues,\n          (invalidValue, valueId) =>\n            callListeners(\n              invalidValueListeners[mutator],\n              [valueId],\n              invalidValue,\n            ),\n        )\n      : 0;\n  const callIdsAndHasListenersIfChanged = (\n    changedIds,\n    idListeners,\n    hasListeners,\n    ids,\n  ) => {\n    if (!collIsEmpty(changedIds)) {\n      callListeners(idListeners, ids, () => mapToObj(changedIds));\n      mapForEach(changedIds, (changedId, changed) =>\n        callListeners(hasListeners, [...(ids ?? []), changedId], changed == 1),\n      );\n      return 1;\n    }\n  };\n  const callTabularListenersForChanges = (mutator) => {\n    const hasTablesNow = hasTables();\n    if (hasTablesNow != hadTables) {\n      callListeners(hasTablesListeners[mutator], void 0, hasTablesNow);\n    }\n    const emptySortedRowIdListeners = collIsEmpty(\n      sortedRowIdsListeners[mutator],\n    );\n    const emptyIdAndHasListeners =\n      collIsEmpty(cellIdsListeners[mutator]) &&\n      collIsEmpty(hasCellListeners[mutator]) &&\n      collIsEmpty(rowIdsListeners[mutator]) &&\n      collIsEmpty(hasRowListeners[mutator]) &&\n      collIsEmpty(tableCellIdsListeners[mutator]) &&\n      collIsEmpty(hasTableCellListeners[mutator]) &&\n      collIsEmpty(rowCountListeners[mutator]) &&\n      emptySortedRowIdListeners &&\n      collIsEmpty(tableIdsListeners[mutator]) &&\n      collIsEmpty(hasTableListeners[mutator]);\n    const emptyOtherListeners =\n      collIsEmpty(cellListeners[mutator]) &&\n      collIsEmpty(rowListeners[mutator]) &&\n      collIsEmpty(tableListeners[mutator]) &&\n      collIsEmpty(tablesListeners[mutator]);\n    if (!emptyIdAndHasListeners || !emptyOtherListeners) {\n      const changes = mutator\n        ? [\n            mapClone(changedTableIds),\n            mapClone2(changedTableCellIds),\n            mapClone(changedRowCount),\n            mapClone2(changedRowIds),\n            mapClone3(changedCellIds),\n            mapClone3(changedCells),\n          ]\n        : [\n            changedTableIds,\n            changedTableCellIds,\n            changedRowCount,\n            changedRowIds,\n            changedCellIds,\n            changedCells,\n          ];\n      if (!emptyIdAndHasListeners) {\n        callIdsAndHasListenersIfChanged(\n          changes[0],\n          tableIdsListeners[mutator],\n          hasTableListeners[mutator],\n        );\n        collForEach(changes[1], (changedIds, tableId) =>\n          callIdsAndHasListenersIfChanged(\n            changedIds,\n            tableCellIdsListeners[mutator],\n            hasTableCellListeners[mutator],\n            [tableId],\n          ),\n        );\n        collForEach(changes[2], (changedCount, tableId) => {\n          if (changedCount != 0) {\n            callListeners(\n              rowCountListeners[mutator],\n              [tableId],\n              getRowCount(tableId),\n            );\n          }\n        });\n        const calledSortableTableIds = setNew();\n        collForEach(changes[3], (changedIds, tableId) => {\n          if (\n            callIdsAndHasListenersIfChanged(\n              changedIds,\n              rowIdsListeners[mutator],\n              hasRowListeners[mutator],\n              [tableId],\n            ) &&\n            !emptySortedRowIdListeners\n          ) {\n            callListeners(sortedRowIdsListeners[mutator], [tableId, null]);\n            setAdd(calledSortableTableIds, tableId);\n          }\n        });\n        if (!emptySortedRowIdListeners) {\n          collForEach(changes[5], (rows, tableId) => {\n            if (!collHas(calledSortableTableIds, tableId)) {\n              const sortableCellIds = setNew();\n              collForEach(rows, (cells) =>\n                collForEach(cells, ([oldCell, newCell], cellId) =>\n                  newCell !== oldCell\n                    ? setAdd(sortableCellIds, cellId)\n                    : collDel(cells, cellId),\n                ),\n              );\n              collForEach(sortableCellIds, (cellId) =>\n                callListeners(sortedRowIdsListeners[mutator], [\n                  tableId,\n                  cellId,\n                ]),\n              );\n            }\n          });\n        }\n        collForEach(changes[4], (rowCellIds, tableId) =>\n          collForEach(rowCellIds, (changedIds, rowId) =>\n            callIdsAndHasListenersIfChanged(\n              changedIds,\n              cellIdsListeners[mutator],\n              hasCellListeners[mutator],\n              [tableId, rowId],\n            ),\n          ),\n        );\n      }\n      if (!emptyOtherListeners) {\n        let tablesChanged;\n        collForEach(changes[5], (rows, tableId) => {\n          let tableChanged;\n          collForEach(rows, (cells, rowId) => {\n            let rowChanged;\n            collForEach(cells, ([oldCell, newCell], cellId) => {\n              if (newCell !== oldCell) {\n                callListeners(\n                  cellListeners[mutator],\n                  [tableId, rowId, cellId],\n                  newCell,\n                  oldCell,\n                  getCellChange,\n                );\n                tablesChanged = tableChanged = rowChanged = 1;\n              }\n            });\n            if (rowChanged) {\n              callListeners(\n                rowListeners[mutator],\n                [tableId, rowId],\n                getCellChange,\n              );\n            }\n          });\n          if (tableChanged) {\n            callListeners(tableListeners[mutator], [tableId], getCellChange);\n          }\n        });\n        if (tablesChanged) {\n          callListeners(tablesListeners[mutator], void 0, getCellChange);\n        }\n      }\n    }\n  };\n  const callValuesListenersForChanges = (mutator) => {\n    const hasValuesNow = hasValues();\n    if (hasValuesNow != hadValues) {\n      callListeners(hasValuesListeners[mutator], void 0, hasValuesNow);\n    }\n    const emptyIdAndHasListeners =\n      collIsEmpty(valueIdsListeners[mutator]) &&\n      collIsEmpty(hasValueListeners[mutator]);\n    const emptyOtherListeners =\n      collIsEmpty(valueListeners[mutator]) &&\n      collIsEmpty(valuesListeners[mutator]);\n    if (!emptyIdAndHasListeners || !emptyOtherListeners) {\n      const changes = mutator\n        ? [mapClone(changedValueIds), mapClone(changedValues)]\n        : [changedValueIds, changedValues];\n      if (!emptyIdAndHasListeners) {\n        callIdsAndHasListenersIfChanged(\n          changes[0],\n          valueIdsListeners[mutator],\n          hasValueListeners[mutator],\n        );\n      }\n      if (!emptyOtherListeners) {\n        let valuesChanged;\n        collForEach(changes[1], ([oldValue, newValue], valueId) => {\n          if (newValue !== oldValue) {\n            callListeners(\n              valueListeners[mutator],\n              [valueId],\n              newValue,\n              oldValue,\n              getValueChange,\n            );\n            valuesChanged = 1;\n          }\n        });\n        if (valuesChanged) {\n          callListeners(valuesListeners[mutator], void 0, getValueChange);\n        }\n      }\n    }\n  };\n  const fluentTransaction = (actions, ...args) => {\n    transaction(() => actions(...arrayMap(args, id)));\n    return store;\n  };\n  const getContent = () => [getTables(), getValues()];\n  const getTables = () => mapToObj3(tablesMap);\n  const getTableIds = () => mapKeys(tablesMap);\n  const getTable = (tableId) => mapToObj2(mapGet(tablesMap, id(tableId)));\n  const getTableCellIds = (tableId) =>\n    mapKeys(mapGet(tableCellIds, id(tableId)));\n  const getRowCount = (tableId) => collSize(mapGet(tablesMap, id(tableId)));\n  const getRowIds = (tableId) => mapKeys(mapGet(tablesMap, id(tableId)));\n  const getSortedRowIds = (tableId, cellId, descending, offset = 0, limit) =>\n    arrayMap(\n      slice(\n        arraySort(\n          mapMap(mapGet(tablesMap, id(tableId)), (row, rowId) => [\n            isUndefined(cellId) ? rowId : mapGet(row, id(cellId)),\n            rowId,\n          ]),\n          ([cell1], [cell2]) =>\n            defaultSorter(cell1, cell2) * (descending ? -1 : 1),\n        ),\n        offset,\n        isUndefined(limit) ? limit : offset + limit,\n      ),\n      ([, rowId]) => rowId,\n    );\n  const getRow = (tableId, rowId) =>\n    mapToObj(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)));\n  const getCellIds = (tableId, rowId) =>\n    mapKeys(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)));\n  const getCell = (tableId, rowId, cellId) =>\n    mapGet(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), id(cellId));\n  const getValues = () => mapToObj(valuesMap);\n  const getValueIds = () => mapKeys(valuesMap);\n  const getValue = (valueId) => mapGet(valuesMap, id(valueId));\n  const hasTables = () => !collIsEmpty(tablesMap);\n  const hasTable = (tableId) => collHas(tablesMap, id(tableId));\n  const hasTableCell = (tableId, cellId) =>\n    collHas(mapGet(tableCellIds, id(tableId)), id(cellId));\n  const hasRow = (tableId, rowId) =>\n    collHas(mapGet(tablesMap, id(tableId)), id(rowId));\n  const hasCell = (tableId, rowId, cellId) =>\n    collHas(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), id(cellId));\n  const hasValues = () => !collIsEmpty(valuesMap);\n  const hasValue = (valueId) => collHas(valuesMap, id(valueId));\n  const getTablesJson = () => jsonStringWithMap(tablesMap);\n  const getValuesJson = () => jsonStringWithMap(valuesMap);\n  const getJson = () => jsonStringWithMap([tablesMap, valuesMap]);\n  const getTablesSchemaJson = () => jsonStringWithMap(tablesSchemaMap);\n  const getValuesSchemaJson = () => jsonStringWithMap(valuesSchemaMap);\n  const getSchemaJson = () =>\n    jsonStringWithMap([tablesSchemaMap, valuesSchemaMap]);\n  const setContent = (content) =>\n    fluentTransaction(() => {\n      const content2 = isFunction(content) ? content() : content;\n      if (validateContent(content2)) {\n        setValidContent(content2);\n      }\n    });\n  const setTables = (tables) =>\n    fluentTransaction(() =>\n      validateTables(tables) ? setValidTables(tables) : 0,\n    );\n  const setTable = (tableId, table) =>\n    fluentTransaction(\n      (tableId2) =>\n        validateTable(table, tableId2) ? setValidTable(tableId2, table) : 0,\n      tableId,\n    );\n  const setRow = (tableId, rowId, row) =>\n    fluentTransaction(\n      (tableId2, rowId2) =>\n        validateRow(tableId2, rowId2, row)\n          ? setValidRow(tableId2, getOrCreateTable(tableId2), rowId2, row)\n          : 0,\n      tableId,\n      rowId,\n    );\n  const addRow = (tableId, row, reuseRowIds = true) =>\n    transaction(() => {\n      let rowId = void 0;\n      if (validateRow(tableId, rowId, row)) {\n        tableId = id(tableId);\n        setValidRow(\n          tableId,\n          getOrCreateTable(tableId),\n          (rowId = getNewRowId(tableId, reuseRowIds ? 1 : 0)),\n          row,\n        );\n      }\n      return rowId;\n    });\n  const setPartialRow = (tableId, rowId, partialRow) =>\n    fluentTransaction(\n      (tableId2, rowId2) => {\n        if (validateRow(tableId2, rowId2, partialRow, 1)) {\n          const table = getOrCreateTable(tableId2);\n          objMap(partialRow, (cell, cellId) =>\n            setCellIntoDefaultRow(tableId2, table, rowId2, cellId, cell),\n          );\n        }\n      },\n      tableId,\n      rowId,\n    );\n  const setCell = (tableId, rowId, cellId, cell) =>\n    fluentTransaction(\n      (tableId2, rowId2, cellId2) =>\n        ifNotUndefined(\n          getValidatedCell(\n            tableId2,\n            rowId2,\n            cellId2,\n            isFunction(cell) ? cell(getCell(tableId2, rowId2, cellId2)) : cell,\n          ),\n          (validCell) =>\n            setCellIntoDefaultRow(\n              tableId2,\n              getOrCreateTable(tableId2),\n              rowId2,\n              cellId2,\n              validCell,\n            ),\n        ),\n      tableId,\n      rowId,\n      cellId,\n    );\n  const setValues = (values) =>\n    fluentTransaction(() =>\n      validateValues(values) ? setValidValues(values) : 0,\n    );\n  const setPartialValues = (partialValues) =>\n    fluentTransaction(() =>\n      validateValues(partialValues, 1)\n        ? objMap(partialValues, (value, valueId) =>\n            setValidValue(valueId, value),\n          )\n        : 0,\n    );\n  const setValue = (valueId, value) =>\n    fluentTransaction(\n      (valueId2) =>\n        ifNotUndefined(\n          getValidatedValue(\n            valueId2,\n            isFunction(value) ? value(getValue(valueId2)) : value,\n          ),\n          (validValue) => setValidValue(valueId2, validValue),\n        ),\n      valueId,\n    );\n  const applyChanges = (changes) =>\n    fluentTransaction(() => {\n      objMap(changes[0], (table, tableId) =>\n        isUndefined(table)\n          ? delTable(tableId)\n          : objMap(table, (row, rowId) =>\n              isUndefined(row)\n                ? delRow(tableId, rowId)\n                : objMap(row, (cell, cellId) =>\n                    setOrDelCell(store, tableId, rowId, cellId, cell),\n                  ),\n            ),\n      );\n      objMap(changes[1], (value, valueId) =>\n        setOrDelValue(store, valueId, value),\n      );\n    });\n  const setTablesJson = (tablesJson) => {\n    try {\n      setOrDelTables(jsonParse(tablesJson));\n    } catch {}\n    return store;\n  };\n  const setValuesJson = (valuesJson) => {\n    try {\n      setOrDelValues(jsonParse(valuesJson));\n    } catch {}\n    return store;\n  };\n  const setJson = (tablesAndValuesJson) =>\n    fluentTransaction(() => {\n      try {\n        const [tables, values] = jsonParse(tablesAndValuesJson);\n        setOrDelTables(tables);\n        setOrDelValues(values);\n      } catch {\n        setTablesJson(tablesAndValuesJson);\n      }\n    });\n  const setTablesSchema = (tablesSchema) =>\n    fluentTransaction(() => {\n      if ((hasTablesSchema = validateTablesSchema(tablesSchema))) {\n        setValidTablesSchema(tablesSchema);\n        if (!collIsEmpty(tablesMap)) {\n          const tables = getTables();\n          delTables();\n          setTables(tables);\n        }\n      }\n    });\n  const setValuesSchema = (valuesSchema) =>\n    fluentTransaction(() => {\n      if ((hasValuesSchema = validateValuesSchema(valuesSchema))) {\n        const values = getValues();\n        delValuesSchema();\n        delValues();\n        hasValuesSchema = true;\n        setValidValuesSchema(valuesSchema);\n        setValues(values);\n      }\n    });\n  const setSchema = (tablesSchema, valuesSchema) =>\n    fluentTransaction(() => {\n      setTablesSchema(tablesSchema);\n      setValuesSchema(valuesSchema);\n    });\n  const delTables = () => fluentTransaction(() => setValidTables({}));\n  const delTable = (tableId) =>\n    fluentTransaction(\n      (tableId2) =>\n        collHas(tablesMap, tableId2) ? delValidTable(tableId2) : 0,\n      tableId,\n    );\n  const delRow = (tableId, rowId) =>\n    fluentTransaction(\n      (tableId2, rowId2) =>\n        ifNotUndefined(mapGet(tablesMap, tableId2), (tableMap) =>\n          collHas(tableMap, rowId2)\n            ? delValidRow(tableId2, tableMap, rowId2)\n            : 0,\n        ),\n      tableId,\n      rowId,\n    );\n  const delCell = (tableId, rowId, cellId, forceDel) =>\n    fluentTransaction(\n      (tableId2, rowId2, cellId2) =>\n        ifNotUndefined(mapGet(tablesMap, tableId2), (tableMap) =>\n          ifNotUndefined(mapGet(tableMap, rowId2), (rowMap) =>\n            collHas(rowMap, cellId2)\n              ? delValidCell(\n                  tableId2,\n                  tableMap,\n                  rowId2,\n                  rowMap,\n                  cellId2,\n                  forceDel,\n                )\n              : 0,\n          ),\n        ),\n      tableId,\n      rowId,\n      cellId,\n    );\n  const delValues = () => fluentTransaction(() => setValidValues({}));\n  const delValue = (valueId) =>\n    fluentTransaction(\n      (valueId2) =>\n        collHas(valuesMap, valueId2) ? delValidValue(valueId2) : 0,\n      valueId,\n    );\n  const delTablesSchema = () =>\n    fluentTransaction(() => {\n      setValidTablesSchema({});\n      hasTablesSchema = false;\n    });\n  const delValuesSchema = () =>\n    fluentTransaction(() => {\n      setValidValuesSchema({});\n      hasValuesSchema = false;\n    });\n  const delSchema = () =>\n    fluentTransaction(() => {\n      delTablesSchema();\n      delValuesSchema();\n    });\n  const transaction = (actions, doRollback) => {\n    if (transactions != -1) {\n      startTransaction();\n      const result = actions();\n      finishTransaction(doRollback);\n      return result;\n    }\n  };\n  const startTransaction = () => {\n    if (transactions != -1) {\n      transactions++;\n    }\n    if (transactions == 1) {\n      internalListeners[0]?.();\n      callListeners(startTransactionListeners);\n    }\n    return store;\n  };\n  const getTransactionChanges = () => [\n    mapToObj(\n      changedCells,\n      (table, tableId) =>\n        mapGet(changedTableIds, tableId) === -1\n          ? void 0\n          : mapToObj(\n              table,\n              (row, rowId) =>\n                mapGet(mapGet(changedRowIds, tableId), rowId) === -1\n                  ? void 0\n                  : mapToObj(\n                      row,\n                      ([, newCell]) => newCell,\n                      (changedCell) => pairIsEqual(changedCell),\n                    ),\n              collIsEmpty,\n              objIsEmpty,\n            ),\n      collIsEmpty,\n      objIsEmpty,\n    ),\n    mapToObj(\n      changedValues,\n      ([, newValue]) => newValue,\n      (changedValue) => pairIsEqual(changedValue),\n    ),\n    1,\n  ];\n  const getTransactionLog = () => [\n    !collIsEmpty(changedCells),\n    !collIsEmpty(changedValues),\n    mapToObj3(changedCells, pairClone, pairIsEqual),\n    mapToObj3(invalidCells),\n    mapToObj(changedValues, pairClone, pairIsEqual),\n    mapToObj(invalidValues),\n    mapToObj(changedTableIds),\n    mapToObj2(changedRowIds),\n    mapToObj3(changedCellIds),\n    mapToObj(changedValueIds),\n  ];\n  const finishTransaction = (doRollback) => {\n    if (transactions > 0) {\n      transactions--;\n      if (transactions == 0) {\n        transactions = 1;\n        callInvalidCellListeners(1);\n        if (!collIsEmpty(changedCells)) {\n          callTabularListenersForChanges(1);\n        }\n        callInvalidValueListeners(1);\n        if (!collIsEmpty(changedValues)) {\n          callValuesListenersForChanges(1);\n        }\n        if (doRollback?.(store)) {\n          collForEach(changedCells, (table, tableId) =>\n            collForEach(table, (row, rowId) =>\n              collForEach(row, ([oldCell], cellId) =>\n                setOrDelCell(store, tableId, rowId, cellId, oldCell),\n              ),\n            ),\n          );\n          collClear(changedCells);\n          collForEach(changedValues, ([oldValue], valueId) =>\n            setOrDelValue(store, valueId, oldValue),\n          );\n          collClear(changedValues);\n        }\n        callListeners(finishTransactionListeners[0], void 0);\n        transactions = -1;\n        callInvalidCellListeners(0);\n        if (!collIsEmpty(changedCells)) {\n          callTabularListenersForChanges(0);\n        }\n        callInvalidValueListeners(0);\n        if (!collIsEmpty(changedValues)) {\n          callValuesListenersForChanges(0);\n        }\n        internalListeners[1]?.();\n        callListeners(finishTransactionListeners[1], void 0);\n        internalListeners[2]?.();\n        transactions = 0;\n        hadTables = hasTables();\n        hadValues = hasValues();\n        arrayForEach(\n          [\n            changedTableIds,\n            changedTableCellIds,\n            changedRowCount,\n            changedRowIds,\n            changedCellIds,\n            changedCells,\n            invalidCells,\n            changedValueIds,\n            changedValues,\n            invalidValues,\n          ],\n          collClear,\n        );\n      }\n    }\n    return store;\n  };\n  const forEachTable = (tableCallback) =>\n    collForEach(tablesMap, (tableMap, tableId) =>\n      tableCallback(tableId, (rowCallback) =>\n        collForEach(tableMap, (rowMap, rowId) =>\n          rowCallback(rowId, (cellCallback) =>\n            mapForEach(rowMap, cellCallback),\n          ),\n        ),\n      ),\n    );\n  const forEachTableCell = (tableId, tableCellCallback) =>\n    mapForEach(mapGet(tableCellIds, id(tableId)), tableCellCallback);\n  const forEachRow = (tableId, rowCallback) =>\n    collForEach(mapGet(tablesMap, id(tableId)), (rowMap, rowId) =>\n      rowCallback(rowId, (cellCallback) => mapForEach(rowMap, cellCallback)),\n    );\n  const forEachCell = (tableId, rowId, cellCallback) =>\n    mapForEach(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), cellCallback);\n  const forEachValue = (valueCallback) => mapForEach(valuesMap, valueCallback);\n  const addSortedRowIdsListener = (\n    tableId,\n    cellId,\n    descending,\n    offset,\n    limit,\n    listener,\n    mutator,\n  ) => {\n    let sortedRowIds = getSortedRowIds(\n      tableId,\n      cellId,\n      descending,\n      offset,\n      limit,\n    );\n    return addListener(\n      () => {\n        const newSortedRowIds = getSortedRowIds(\n          tableId,\n          cellId,\n          descending,\n          offset,\n          limit,\n        );\n        if (!arrayIsEqual(newSortedRowIds, sortedRowIds)) {\n          sortedRowIds = newSortedRowIds;\n          listener(\n            store,\n            tableId,\n            cellId,\n            descending,\n            offset,\n            limit,\n            sortedRowIds,\n          );\n        }\n      },\n      sortedRowIdsListeners[mutator ? 1 : 0],\n      [tableId, cellId],\n      [getTableIds],\n    );\n  };\n  const addStartTransactionListener = (listener) =>\n    addListener(listener, startTransactionListeners);\n  const addWillFinishTransactionListener = (listener) =>\n    addListener(listener, finishTransactionListeners[0]);\n  const addDidFinishTransactionListener = (listener) =>\n    addListener(listener, finishTransactionListeners[1]);\n  const callListener = (listenerId) => {\n    callListenerImpl(listenerId);\n    return store;\n  };\n  const delListener = (listenerId) => {\n    delListenerImpl(listenerId);\n    return store;\n  };\n  const getListenerStats = () => ({\n    hasTables: pairCollSize2(hasTablesListeners),\n    tables: pairCollSize2(tablesListeners),\n    tableIds: pairCollSize2(tableIdsListeners),\n    hasTable: pairCollSize2(hasTableListeners),\n    table: pairCollSize2(tableListeners),\n    tableCellIds: pairCollSize2(tableCellIdsListeners),\n    hasTableCell: pairCollSize2(hasTableCellListeners, collSize3),\n    rowCount: pairCollSize2(rowCountListeners),\n    rowIds: pairCollSize2(rowIdsListeners),\n    sortedRowIds: pairCollSize2(sortedRowIdsListeners),\n    hasRow: pairCollSize2(hasRowListeners, collSize3),\n    row: pairCollSize2(rowListeners, collSize3),\n    cellIds: pairCollSize2(cellIdsListeners, collSize3),\n    hasCell: pairCollSize2(hasCellListeners, collSize4),\n    cell: pairCollSize2(cellListeners, collSize4),\n    invalidCell: pairCollSize2(invalidCellListeners, collSize4),\n    hasValues: pairCollSize2(hasValuesListeners),\n    values: pairCollSize2(valuesListeners),\n    valueIds: pairCollSize2(valueIdsListeners),\n    hasValue: pairCollSize2(hasValueListeners),\n    value: pairCollSize2(valueListeners),\n    invalidValue: pairCollSize2(invalidValueListeners),\n    transaction:\n      collSize2(startTransactionListeners) +\n      pairCollSize2(finishTransactionListeners),\n  });\n  const setInternalListeners = (\n    preStartTransaction,\n    preFinishTransaction,\n    postFinishTransaction,\n    cellChanged2,\n    valueChanged2,\n  ) =>\n    (internalListeners = [\n      preStartTransaction,\n      preFinishTransaction,\n      postFinishTransaction,\n      cellChanged2,\n      valueChanged2,\n    ]);\n  const store = {\n    getContent,\n    getTables,\n    getTableIds,\n    getTable,\n    getTableCellIds,\n    getRowCount,\n    getRowIds,\n    getSortedRowIds,\n    getRow,\n    getCellIds,\n    getCell,\n    getValues,\n    getValueIds,\n    getValue,\n    hasTables,\n    hasTable,\n    hasTableCell,\n    hasRow,\n    hasCell,\n    hasValues,\n    hasValue,\n    getTablesJson,\n    getValuesJson,\n    getJson,\n    getTablesSchemaJson,\n    getValuesSchemaJson,\n    getSchemaJson,\n    hasTablesSchema: () => hasTablesSchema,\n    hasValuesSchema: () => hasValuesSchema,\n    setContent,\n    setTables,\n    setTable,\n    setRow,\n    addRow,\n    setPartialRow,\n    setCell,\n    setValues,\n    setPartialValues,\n    setValue,\n    applyChanges,\n    setTablesJson,\n    setValuesJson,\n    setJson,\n    setTablesSchema,\n    setValuesSchema,\n    setSchema,\n    delTables,\n    delTable,\n    delRow,\n    delCell,\n    delValues,\n    delValue,\n    delTablesSchema,\n    delValuesSchema,\n    delSchema,\n    transaction,\n    startTransaction,\n    getTransactionChanges,\n    getTransactionLog,\n    finishTransaction,\n    forEachTable,\n    forEachTableCell,\n    forEachRow,\n    forEachCell,\n    forEachValue,\n    addSortedRowIdsListener,\n    addStartTransactionListener,\n    addWillFinishTransactionListener,\n    addDidFinishTransactionListener,\n    callListener,\n    delListener,\n    getListenerStats,\n    isMergeable: () => false,\n    // only used internally by other modules\n    createStore,\n    addListener,\n    callListeners,\n    setInternalListeners,\n  };\n  objMap(\n    {\n      [HAS + TABLES]: [0, hasTablesListeners, [], () => [hasTables()]],\n      [TABLES]: [0, tablesListeners],\n      [TABLE_IDS]: [0, tableIdsListeners],\n      [HAS + TABLE]: [\n        1,\n        hasTableListeners,\n        [getTableIds],\n        (ids) => [hasTable(...ids)],\n      ],\n      [TABLE]: [1, tableListeners, [getTableIds]],\n      [TABLE + CELL_IDS]: [1, tableCellIdsListeners, [getTableIds]],\n      [HAS + TABLE + CELL]: [\n        2,\n        hasTableCellListeners,\n        [getTableIds, getTableCellIds],\n        (ids) => [hasTableCell(...ids)],\n      ],\n      [ROW_COUNT]: [1, rowCountListeners, [getTableIds]],\n      [ROW_IDS]: [1, rowIdsListeners, [getTableIds]],\n      [HAS + ROW]: [\n        2,\n        hasRowListeners,\n        [getTableIds, getRowIds],\n        (ids) => [hasRow(...ids)],\n      ],\n      [ROW]: [2, rowListeners, [getTableIds, getRowIds]],\n      [CELL_IDS]: [2, cellIdsListeners, [getTableIds, getRowIds]],\n      [HAS + CELL]: [\n        3,\n        hasCellListeners,\n        [getTableIds, getRowIds, getCellIds],\n        (ids) => [hasCell(...ids)],\n      ],\n      [CELL]: [\n        3,\n        cellListeners,\n        [getTableIds, getRowIds, getCellIds],\n        (ids) => pairNew(getCell(...ids)),\n      ],\n      InvalidCell: [3, invalidCellListeners],\n      [HAS + VALUES]: [0, hasValuesListeners, [], () => [hasValues()]],\n      [VALUES]: [0, valuesListeners],\n      [VALUE_IDS]: [0, valueIdsListeners],\n      [HAS + VALUE]: [\n        1,\n        hasValueListeners,\n        [getValueIds],\n        (ids) => [hasValue(...ids)],\n      ],\n      [VALUE]: [\n        1,\n        valueListeners,\n        [getValueIds],\n        (ids) => pairNew(getValue(ids[0])),\n      ],\n      InvalidValue: [1, invalidValueListeners],\n    },\n    ([argumentCount, idSetNode, pathGetters, extraArgsGetter], listenable) => {\n      store[ADD + listenable + LISTENER] = (...args) =>\n        addListener(\n          args[argumentCount],\n          idSetNode[args[argumentCount + 1] ? 1 : 0],\n          argumentCount > 0 ? slice(args, 0, argumentCount) : void 0,\n          pathGetters,\n          extraArgsGetter,\n        );\n    },\n  );\n  return objFreeze(store);\n};\n\nconst SHIFT36 = 2 ** 36;\nconst SHIFT30 = 2 ** 30;\nconst SHIFT24 = 2 ** 24;\nconst SHIFT18 = 2 ** 18;\nconst SHIFT12 = 2 ** 12;\nconst SHIFT6 = 2 ** 6;\nconst encodeTimeAndCounter = (logicalTime42, counter24) =>\n  encode(logicalTime42 / SHIFT36) +\n  encode(logicalTime42 / SHIFT30) +\n  encode(logicalTime42 / SHIFT24) +\n  encode(logicalTime42 / SHIFT18) +\n  encode(logicalTime42 / SHIFT12) +\n  encode(logicalTime42 / SHIFT6) +\n  encode(logicalTime42) +\n  encode(counter24 / SHIFT18) +\n  encode(counter24 / SHIFT12) +\n  encode(counter24 / SHIFT6) +\n  encode(counter24);\nconst decodeTimeAndCounter = (hlc16) => [\n  decode(hlc16, 0) * SHIFT36 +\n    decode(hlc16, 1) * SHIFT30 +\n    decode(hlc16, 2) * SHIFT24 +\n    decode(hlc16, 3) * SHIFT18 +\n    decode(hlc16, 4) * SHIFT12 +\n    decode(hlc16, 5) * SHIFT6 +\n    decode(hlc16, 6),\n  decode(hlc16, 7) * SHIFT18 +\n    decode(hlc16, 8) * SHIFT12 +\n    decode(hlc16, 9) * SHIFT6 +\n    decode(hlc16, 10),\n];\nconst getHlcFunctions = (uniqueId) => {\n  let logicalTime = 0;\n  let lastCounter = -1;\n  const clientPart = ifNotUndefined(\n    uniqueId,\n    (uniqueId2) => {\n      const clientHash30 = getHash(uniqueId2);\n      return (\n        encode(clientHash30 / SHIFT24) +\n        encode(clientHash30 / SHIFT18) +\n        encode(clientHash30 / SHIFT12) +\n        encode(clientHash30 / SHIFT6) +\n        encode(clientHash30)\n      );\n    },\n    () => getUniqueId(5),\n  );\n  const getHlc = () => {\n    seenHlc();\n    return encodeTimeAndCounter(logicalTime, ++lastCounter) + clientPart;\n  };\n  const seenHlc = (hlc) => {\n    const previousLogicalTime = logicalTime;\n    const [remoteLogicalTime, remoteCounter] =\n      isUndefined(hlc) || hlc == '' ? [0, 0] : decodeTimeAndCounter(hlc);\n    logicalTime = mathMax(\n      previousLogicalTime,\n      remoteLogicalTime,\n      GLOBAL.HLC_TIME ?? Date.now(),\n    );\n    lastCounter =\n      logicalTime == previousLogicalTime\n        ? logicalTime == remoteLogicalTime\n          ? mathMax(lastCounter, remoteCounter)\n          : lastCounter\n        : logicalTime == remoteLogicalTime\n          ? remoteCounter\n          : -1;\n  };\n  return [getHlc, seenHlc];\n};\n\nconst LISTENER_ARGS = {\n  HasTable: 1,\n  Table: 1,\n  TableCellIds: 1,\n  HasTableCell: 2,\n  RowCount: 1,\n  RowIds: 1,\n  SortedRowIds: 5,\n  HasRow: 2,\n  Row: 2,\n  CellIds: 2,\n  HasCell: 3,\n  Cell: 3,\n  HasValue: 1,\n  Value: 1,\n  InvalidCell: 3,\n  InvalidValue: 1,\n};\nconst newContentStampMap = (time = EMPTY_STRING) => [\n  stampNewMap(time),\n  stampNewMap(time),\n];\nconst validateMergeableContent = (mergeableContent) =>\n  isArray(mergeableContent) &&\n  size(mergeableContent) == 2 &&\n  stampValidate(mergeableContent[0], (tableStamps) =>\n    objValidate(\n      tableStamps,\n      (tableStamp) =>\n        stampValidate(tableStamp, (rowStamps) =>\n          objValidate(\n            rowStamps,\n            (rowStamp) =>\n              stampValidate(rowStamp, (cellStamps) =>\n                objValidate(\n                  cellStamps,\n                  (cellStamp) =>\n                    stampValidate(cellStamp, isCellOrValueOrNullOrUndefined),\n                  void 0,\n                  1,\n                ),\n              ),\n            void 0,\n            1,\n          ),\n        ),\n      void 0,\n      1,\n    ),\n  ) &&\n  stampValidate(mergeableContent[1], (values) =>\n    objValidate(\n      values,\n      (value) => stampValidate(value, isCellOrValueOrNullOrUndefined),\n      void 0,\n      1,\n    ),\n  );\nconst createMergeableStore = (uniqueId) => {\n  let listeningToRawStoreChanges = 1;\n  let contentStampMap = newContentStampMap();\n  let defaultingContent = 0;\n  const touchedCells = mapNew();\n  const touchedValues = setNew();\n  const [getHlc, seenHlc] = getHlcFunctions(uniqueId);\n  const store = createStore();\n  const disableListeningToRawStoreChanges = (actions) => {\n    const wasListening = listeningToRawStoreChanges;\n    listeningToRawStoreChanges = 0;\n    actions();\n    listeningToRawStoreChanges = wasListening;\n    return mergeableStore;\n  };\n  const mergeContentOrChanges = (contentOrChanges, isContent = 0) => {\n    const tablesChanges = {};\n    const valuesChanges = {};\n    const [\n      [tablesObj, incomingTablesTime = EMPTY_STRING, incomingTablesHash = 0],\n      values,\n    ] = contentOrChanges;\n    const [tablesStampMap, valuesStampMap] = contentStampMap;\n    const [tableStampMaps, oldTablesTime, oldTablesHash] = tablesStampMap;\n    let tablesHash = isContent ? incomingTablesHash : oldTablesHash;\n    let tablesTime = incomingTablesTime;\n    objForEach(\n      tablesObj,\n      (\n        [rowsObj, incomingTableTime = EMPTY_STRING, incomingTableHash = 0],\n        tableId,\n      ) => {\n        const tableStampMap = mapEnsure(tableStampMaps, tableId, stampNewMap);\n        const [rowStampMaps, oldTableTime, oldTableHash] = tableStampMap;\n        let tableHash = isContent ? incomingTableHash : oldTableHash;\n        let tableTime = incomingTableTime;\n        objForEach(rowsObj, (row, rowId) => {\n          const [rowTime, oldRowHash, rowHash] = mergeCellsOrValues(\n            row,\n            mapEnsure(rowStampMaps, rowId, stampNewMap),\n            objEnsure(objEnsure(tablesChanges, tableId, objNew), rowId, objNew),\n            isContent,\n          );\n          tableHash ^= isContent\n            ? 0\n            : (oldRowHash ? hashIdAndHash(rowId, oldRowHash) : 0) ^\n              hashIdAndHash(rowId, rowHash);\n          tableTime = getLatestTime(tableTime, rowTime);\n        });\n        tableHash ^= isContent\n          ? 0\n          : replaceTimeHash(oldTableTime, incomingTableTime);\n        stampUpdate(tableStampMap, incomingTableTime, tableHash);\n        tablesHash ^= isContent\n          ? 0\n          : (oldTableHash ? hashIdAndHash(tableId, oldTableHash) : 0) ^\n            hashIdAndHash(tableId, tableStampMap[2]);\n        tablesTime = getLatestTime(tablesTime, tableTime);\n      },\n    );\n    tablesHash ^= isContent\n      ? 0\n      : replaceTimeHash(oldTablesTime, incomingTablesTime);\n    stampUpdate(tablesStampMap, incomingTablesTime, tablesHash);\n    const [valuesTime] = mergeCellsOrValues(\n      values,\n      valuesStampMap,\n      valuesChanges,\n      isContent,\n    );\n    seenHlc(getLatestTime(tablesTime, valuesTime));\n    return [tablesChanges, valuesChanges, 1];\n  };\n  const mergeCellsOrValues = (\n    things,\n    thingsStampMap,\n    thingsChanges,\n    isContent,\n  ) => {\n    const [\n      thingsObj,\n      incomingThingsTime = EMPTY_STRING,\n      incomingThingsHash = 0,\n    ] = things;\n    const [thingStampMaps, oldThingsTime, oldThingsHash] = thingsStampMap;\n    let thingsTime = incomingThingsTime;\n    let thingsHash = isContent ? incomingThingsHash : oldThingsHash;\n    objForEach(\n      thingsObj,\n      ([thing, thingTime, incomingThingHash = 0], thingId) => {\n        const thingStampMap = mapEnsure(thingStampMaps, thingId, () => [\n          void 0,\n          EMPTY_STRING,\n          0,\n        ]);\n        const [, oldThingTime, oldThingHash] = thingStampMap;\n        if (!oldThingTime || thingTime > oldThingTime) {\n          stampUpdate(\n            thingStampMap,\n            thingTime,\n            isContent\n              ? incomingThingHash\n              : getHash(jsonStringWithMap(thing ?? null) + ':' + thingTime),\n          );\n          thingStampMap[0] = thing;\n          thingsChanges[thingId] = thing;\n          thingsHash ^= isContent\n            ? 0\n            : hashIdAndHash(thingId, oldThingHash) ^\n              hashIdAndHash(thingId, thingStampMap[2]);\n          thingsTime = getLatestTime(thingsTime, thingTime);\n        }\n      },\n    );\n    thingsHash ^= isContent\n      ? 0\n      : replaceTimeHash(oldThingsTime, incomingThingsTime);\n    stampUpdate(thingsStampMap, incomingThingsTime, thingsHash);\n    return [thingsTime, oldThingsHash, thingsStampMap[2]];\n  };\n  const preStartTransaction = () => {};\n  const preFinishTransaction = () => {};\n  const postFinishTransaction = () => {\n    collClear(touchedCells);\n    collClear(touchedValues);\n  };\n  const cellChanged = (tableId, rowId, cellId, newCell) => {\n    setAdd(\n      mapEnsure(mapEnsure(touchedCells, tableId, mapNew), rowId, setNew),\n      cellId,\n    );\n    if (listeningToRawStoreChanges) {\n      mergeContentOrChanges([\n        [\n          {\n            [tableId]: [\n              {\n                [rowId]: [\n                  {\n                    [cellId]: [\n                      newCell,\n                      defaultingContent ? EMPTY_STRING : getHlc(),\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n        [{}],\n        1,\n      ]);\n    }\n  };\n  const valueChanged = (valueId, newValue) => {\n    setAdd(touchedValues, valueId);\n    if (listeningToRawStoreChanges) {\n      mergeContentOrChanges([\n        [{}],\n        [{[valueId]: [newValue, defaultingContent ? EMPTY_STRING : getHlc()]}],\n        1,\n      ]);\n    }\n  };\n  const getMergeableContent = () => [\n    stampMapToObjWithHash(contentStampMap[0], (tableStampMap) =>\n      stampMapToObjWithHash(tableStampMap, (rowStampMap) =>\n        stampMapToObjWithHash(rowStampMap),\n      ),\n    ),\n    stampMapToObjWithHash(contentStampMap[1]),\n  ];\n  const getMergeableContentHashes = () => [\n    contentStampMap[0][2],\n    contentStampMap[1][2],\n  ];\n  const getMergeableTableHashes = () =>\n    mapToObj(contentStampMap[0][0], getStampHash);\n  const getMergeableTableDiff = (otherTableHashes) => {\n    const newTables = stampNewObj(contentStampMap[0][1]);\n    const differingTableHashes = {};\n    mapForEach(\n      contentStampMap[0][0],\n      (tableId, [tableStampMap, tableTime, hash]) =>\n        objHas(otherTableHashes, tableId)\n          ? hash != otherTableHashes[tableId]\n            ? (differingTableHashes[tableId] = hash)\n            : 0\n          : (newTables[0][tableId] = stampMapToObjWithoutHash(\n              [tableStampMap, tableTime],\n              (rowStampMap) => stampMapToObjWithoutHash(rowStampMap),\n            )),\n    );\n    return [newTables, differingTableHashes];\n  };\n  const getMergeableRowHashes = (otherTableHashes) => {\n    const rowHashes = {};\n    objForEach(otherTableHashes, (otherTableHash, tableId) =>\n      ifNotUndefined(\n        mapGet(contentStampMap[0][0], tableId),\n        ([rowStampMaps, , tableHash]) =>\n          tableHash != otherTableHash\n            ? mapForEach(\n                rowStampMaps,\n                (rowId, [, , rowHash]) =>\n                  (objEnsure(rowHashes, tableId, objNew)[rowId] = rowHash),\n              )\n            : 0,\n      ),\n    );\n    return rowHashes;\n  };\n  const getMergeableRowDiff = (otherTableRowHashes) => {\n    const newRows = stampNewObj(contentStampMap[0][1]);\n    const differingRowHashes = {};\n    objForEach(otherTableRowHashes, (otherRowHashes, tableId) =>\n      mapForEach(\n        mapGet(contentStampMap[0][0], tableId)?.[0],\n        (rowId, [rowStampMap, rowTime, hash]) =>\n          objHas(otherRowHashes, rowId)\n            ? hash !== otherRowHashes[rowId]\n              ? (objEnsure(differingRowHashes, tableId, objNew)[rowId] = hash)\n              : 0\n            : (objEnsure(newRows[0], tableId, stampNewObj)[0][rowId] =\n                stampMapToObjWithoutHash([rowStampMap, rowTime])),\n      ),\n    );\n    return [newRows, differingRowHashes];\n  };\n  const getMergeableCellHashes = (otherTableRowHashes) => {\n    const cellHashes = {};\n    objForEach(otherTableRowHashes, (otherRowHashes, tableId) =>\n      ifNotUndefined(mapGet(contentStampMap[0][0], tableId), ([rowStampMaps]) =>\n        objForEach(otherRowHashes, (otherRowHash, rowId) =>\n          ifNotUndefined(\n            mapGet(rowStampMaps, rowId),\n            ([cellStampMaps, , rowHash]) =>\n              rowHash !== otherRowHash\n                ? mapForEach(\n                    cellStampMaps,\n                    (cellId, [, , cellHash]) =>\n                      (objEnsure(\n                        objEnsure(cellHashes, tableId, objNew),\n                        rowId,\n                        objNew,\n                      )[cellId] = cellHash),\n                  )\n                : 0,\n          ),\n        ),\n      ),\n    );\n    return cellHashes;\n  };\n  const getMergeableCellDiff = (otherTableRowCellHashes) => {\n    const [[tableStampMaps, tablesTime]] = contentStampMap;\n    const tablesObj = {};\n    objForEach(otherTableRowCellHashes, (otherRowCellHashes, tableId) =>\n      objForEach(otherRowCellHashes, (otherCellHashes, rowId) =>\n        ifNotUndefined(\n          mapGet(tableStampMaps, tableId),\n          ([rowStampMaps, tableTime]) =>\n            ifNotUndefined(\n              mapGet(rowStampMaps, rowId),\n              ([cellStampMaps, rowTime]) =>\n                mapForEach(cellStampMaps, (cellId, [cell, cellTime, hash]) =>\n                  hash !== otherCellHashes[cellId]\n                    ? (objEnsure(\n                        objEnsure(tablesObj, tableId, () =>\n                          stampNewObj(tableTime),\n                        )[0],\n                        rowId,\n                        () => stampNewObj(rowTime),\n                      )[0][cellId] = [cell, cellTime])\n                    : 0,\n                ),\n            ),\n        ),\n      ),\n    );\n    return stampNew(tablesObj, tablesTime);\n  };\n  const getMergeableValueHashes = () =>\n    mapToObj(contentStampMap[1][0], getStampHash);\n  const getMergeableValueDiff = (otherValueHashes) => {\n    const [, [valueStampMaps, valuesTime]] = contentStampMap;\n    const values = mapToObj(\n      valueStampMaps,\n      stampClone,\n      ([, , hash], valueId) => hash == otherValueHashes?.[valueId],\n    );\n    return stampNew(values, valuesTime);\n  };\n  const setMergeableContent = (mergeableContent) =>\n    disableListeningToRawStoreChanges(() =>\n      validateMergeableContent(mergeableContent)\n        ? store.transaction(() => {\n            store.delTables().delValues();\n            contentStampMap = newContentStampMap();\n            store.applyChanges(mergeContentOrChanges(mergeableContent, 1));\n          })\n        : 0,\n    );\n  const setDefaultContent = (content) => {\n    store.transaction(() => {\n      defaultingContent = 1;\n      store.setContent(content);\n      defaultingContent = 0;\n    });\n    return mergeableStore;\n  };\n  const getTransactionMergeableChanges = (withHashes = false) => {\n    const [\n      [tableStampMaps, tablesTime, tablesHash],\n      [valueStampMaps, valuesTime, valuesHash],\n    ] = contentStampMap;\n    const newStamp = withHashes ? stampNewWithHash : stampNew;\n    const tablesObj = {};\n    collForEach(touchedCells, (touchedTable, tableId) =>\n      ifNotUndefined(\n        mapGet(tableStampMaps, tableId),\n        ([rowStampMaps, tableTime, tableHash]) => {\n          const tableObj = {};\n          collForEach(touchedTable, (touchedRow, rowId) =>\n            ifNotUndefined(\n              mapGet(rowStampMaps, rowId),\n              ([cellStampMaps, rowTime, rowHash]) => {\n                const rowObj = {};\n                collForEach(touchedRow, (cellId) => {\n                  ifNotUndefined(\n                    mapGet(cellStampMaps, cellId),\n                    ([cell, time, hash]) =>\n                      (rowObj[cellId] = newStamp(cell, time, hash)),\n                  );\n                });\n                tableObj[rowId] = newStamp(rowObj, rowTime, rowHash);\n              },\n            ),\n          );\n          tablesObj[tableId] = newStamp(tableObj, tableTime, tableHash);\n        },\n      ),\n    );\n    const valuesObj = {};\n    collForEach(touchedValues, (valueId) =>\n      ifNotUndefined(\n        mapGet(valueStampMaps, valueId),\n        ([value, time, hash]) =>\n          (valuesObj[valueId] = newStamp(value, time, hash)),\n      ),\n    );\n    return [\n      newStamp(tablesObj, tablesTime, tablesHash),\n      newStamp(valuesObj, valuesTime, valuesHash),\n      1,\n    ];\n  };\n  const applyMergeableChanges = (mergeableChanges) =>\n    disableListeningToRawStoreChanges(() =>\n      store.applyChanges(mergeContentOrChanges(mergeableChanges)),\n    );\n  const merge = (mergeableStore2) => {\n    const mergeableChanges = getMergeableContent();\n    const mergeableChanges2 = mergeableStore2.getMergeableContent();\n    mergeableStore2.applyMergeableChanges(mergeableChanges);\n    return applyMergeableChanges(mergeableChanges2);\n  };\n  const mergeableStore = {\n    getMergeableContent,\n    getMergeableContentHashes,\n    getMergeableTableHashes,\n    getMergeableTableDiff,\n    getMergeableRowHashes,\n    getMergeableRowDiff,\n    getMergeableCellHashes,\n    getMergeableCellDiff,\n    getMergeableValueHashes,\n    getMergeableValueDiff,\n    setMergeableContent,\n    setDefaultContent,\n    getTransactionMergeableChanges,\n    applyMergeableChanges,\n    merge,\n  };\n  store.setInternalListeners(\n    preStartTransaction,\n    preFinishTransaction,\n    postFinishTransaction,\n    cellChanged,\n    valueChanged,\n  );\n  objMap(\n    store,\n    (method, name) =>\n      (mergeableStore[name] = // fluent methods\n        strStartsWith(name, SET) ||\n        strStartsWith(name, DEL) ||\n        strStartsWith(name, 'apply') ||\n        strEndsWith(name, TRANSACTION) ||\n        name == 'call' + LISTENER\n          ? (...args) => {\n              method(...args);\n              return mergeableStore;\n            }\n          : strStartsWith(name, ADD) && strEndsWith(name, LISTENER)\n            ? (...args) => {\n                const listenerArg = LISTENER_ARGS[slice(name, 3, -8)] ?? 0;\n                const listener = args[listenerArg];\n                args[listenerArg] = (_store, ...args2) =>\n                  listener(mergeableStore, ...args2);\n                return method(...args);\n              }\n            : name == 'isMergeable'\n              ? () => true\n              : method),\n  );\n  return objFreeze(mergeableStore);\n};\n\nexport {\n  createCheckpoints,\n  createIndexes,\n  createMergeableStore,\n  createMetrics,\n  createQueries,\n  createRelationships,\n  createStore,\n  defaultSorter,\n  getUniqueId,\n};\n"],"names":[],"mappings":"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QAAQ,cAAc;YACtB,UAAU,cAAc;YACxB,UAAU,cAAc;YACxB,OAAO,cAAc;YACrB,cAAc,cAAc;YAC5B,cAAc,cAAc,uBAAuB;YACnD,UAAU,cAAc;YACxB,QAAQ,cAAc;YACtB,cAAc,cAAc;YAC5B,QAAQ,cAAc,iBAAiB;YACvC,KAAK,cAAc,cAAc;YACjC,SAAS,cAAc,kBAAkB;YACzC,SAAS,cAAc,kBAAkB;YACzC,MAAM,cAAc,eAAe;YACnC,aAAa,cAAc,sBAAsB;YACjD,WAAW,cAAc;YACzB,QAAQ,cAAc;YACtB,UAAU,cAAc;YACxB,UAAU,cAAc;YACxB,OAAO,cAAc;YACrB,cAAc,cAAc;YAC5B,aACE,UAAU,6BACV,cAAc;QAClB,CAAC;IACD,MAAM,uBAAuB,CAC3B,qBACA,sBACA,uBACA,cACA,gBAEC,oBAAoB;YACnB;YACA;YACA;YACA;YACA;SACD;IACH,MAAM,QAAQ;QACZ;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,iBAAiB,IAAM;QACvB,iBAAiB,IAAM;QACvB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,aAAa,IAAM;QACnB,wCAAwC;QACxC;QACA;QACA;QACA;IACF;IACA,OACE;QACE,CAAC,MAAM,OAAO,EAAE;YAAC;YAAG;YAAoB,EAAE;YAAE,IAAM;oBAAC;iBAAY;SAAC;QAChE,CAAC,OAAO,EAAE;YAAC;YAAG;SAAgB;QAC9B,CAAC,UAAU,EAAE;YAAC;YAAG;SAAkB;QACnC,CAAC,MAAM,MAAM,EAAE;YACb;YACA;YACA;gBAAC;aAAY;YACb,CAAC,MAAQ;oBAAC,YAAY;iBAAK;S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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2673, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2679, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/tinybase%405.4.8_%40cloudflare%2Bworkers-types%404.20250224.0_prettier%403.5.2_react-dom%4019.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/persisters/persister-browser/index.js"],"sourcesContent":["const EMPTY_STRING = '';\nconst UNDEFINED = '\\uFFFC';\n\nconst GLOBAL = globalThis;\nconst WINDOW = GLOBAL.window;\nconst isUndefined = (thing) => thing == void 0;\nconst ifNotUndefined = (value, then, otherwise) =>\n  isUndefined(value) ? otherwise?.() : then(value);\nconst isArray = (thing) => Array.isArray(thing);\nconst size = (arrayOrString) => arrayOrString.length;\nconst test = (regex, subject) => regex.test(subject);\nconst errorNew = (message) => {\n  throw new Error(message);\n};\n\nconst arrayForEach = (array, cb) => array.forEach(cb);\nconst arrayClear = (array, to) => array.splice(0, to);\nconst arrayPush = (array, ...values) => array.push(...values);\nconst arrayShift = (array) => array.shift();\n\nconst object = Object;\nconst getPrototypeOf = (obj) => object.getPrototypeOf(obj);\nconst isObject = (obj) =>\n  !isUndefined(obj) &&\n  ifNotUndefined(\n    getPrototypeOf(obj),\n    (objPrototype) =>\n      objPrototype == object.prototype ||\n      isUndefined(getPrototypeOf(objPrototype)),\n\n    /* istanbul ignore next */\n    () => true,\n  );\nconst objIds = object.keys;\nconst objFreeze = object.freeze;\nconst objSize = (obj) => size(objIds(obj));\nconst objIsEmpty = (obj) => isObject(obj) && objSize(obj) == 0;\n\nconst jsonString = JSON.stringify;\nconst jsonParse = JSON.parse;\nconst jsonStringWithUndefined = (obj) =>\n  jsonString(obj, (_key, value) => (value === void 0 ? UNDEFINED : value));\nconst jsonParseWithUndefined = (str) =>\n  jsonParse(str, (_key, value) => (value === UNDEFINED ? void 0 : value));\n\nconst collSize = (coll) => coll?.size ?? 0;\nconst collHas = (coll, keyOrValue) => coll?.has(keyOrValue) ?? false;\nconst collIsEmpty = (coll) => isUndefined(coll) || collSize(coll) == 0;\nconst collForEach = (coll, cb) => coll?.forEach(cb);\nconst collDel = (coll, keyOrValue) => coll?.delete(keyOrValue);\n\nconst mapNew = (entries) => new Map(entries);\nconst mapGet = (map, key) => map?.get(key);\nconst mapSet = (map, key, value) =>\n  isUndefined(value) ? (collDel(map, key), map) : map?.set(key, value);\nconst mapEnsure = (map, key, getDefaultValue, hadExistingValue) => {\n  if (!collHas(map, key)) {\n    mapSet(map, key, getDefaultValue());\n  } else {\n    hadExistingValue?.(mapGet(map, key));\n  }\n  return mapGet(map, key);\n};\nconst visitTree = (node, path, ensureLeaf, pruneLeaf, p = 0) =>\n  ifNotUndefined(\n    (ensureLeaf ? mapEnsure : mapGet)(\n      node,\n      path[p],\n      p > size(path) - 2 ? ensureLeaf : mapNew,\n    ),\n    (nodeOrLeaf) => {\n      if (p > size(path) - 2) {\n        if (pruneLeaf?.(nodeOrLeaf)) {\n          mapSet(node, path[p]);\n        }\n        return nodeOrLeaf;\n      }\n      const leaf = visitTree(nodeOrLeaf, path, ensureLeaf, pruneLeaf, p + 1);\n      if (collIsEmpty(nodeOrLeaf)) {\n        mapSet(node, path[p]);\n      }\n      return leaf;\n    },\n  );\n\nconst setNew = (entryOrEntries) =>\n  new Set(\n    isArray(entryOrEntries) || isUndefined(entryOrEntries)\n      ? entryOrEntries\n      : [entryOrEntries],\n  );\nconst setAdd = (set, value) => set?.add(value);\n\nconst INTEGER = /^\\d+$/;\nconst getPoolFunctions = () => {\n  const pool = [];\n  let nextId = 0;\n  return [\n    (reuse) => (reuse ? arrayShift(pool) : null) ?? EMPTY_STRING + nextId++,\n    (id) => {\n      if (test(INTEGER, id) && size(pool) < 1e3) {\n        arrayPush(pool, id);\n      }\n    },\n  ];\n};\n\nconst getWildcardedLeaves = (deepIdSet, path = [EMPTY_STRING]) => {\n  const leaves = [];\n  const deep = (node, p) =>\n    p == size(path)\n      ? arrayPush(leaves, node)\n      : path[p] === null\n        ? collForEach(node, (node2) => deep(node2, p + 1))\n        : arrayForEach([path[p], null], (id) => deep(mapGet(node, id), p + 1));\n  deep(deepIdSet, 0);\n  return leaves;\n};\nconst getListenerFunctions = (getThing) => {\n  let thing;\n  const [getId, releaseId] = getPoolFunctions();\n  const allListeners = mapNew();\n  const addListener = (\n    listener,\n    idSetNode,\n    path,\n    pathGetters = [],\n    extraArgsGetter = () => [],\n  ) => {\n    thing ??= getThing();\n    const id = getId(1);\n    mapSet(allListeners, id, [\n      listener,\n      idSetNode,\n      path,\n      pathGetters,\n      extraArgsGetter,\n    ]);\n    setAdd(visitTree(idSetNode, path ?? [EMPTY_STRING], setNew), id);\n    return id;\n  };\n  const callListeners = (idSetNode, ids, ...extraArgs) =>\n    arrayForEach(getWildcardedLeaves(idSetNode, ids), (set) =>\n      collForEach(set, (id) =>\n        mapGet(allListeners, id)[0](thing, ...(ids ?? []), ...extraArgs),\n      ),\n    );\n  const delListener = (id) =>\n    ifNotUndefined(mapGet(allListeners, id), ([, idSetNode, idOrNulls]) => {\n      visitTree(idSetNode, idOrNulls ?? [EMPTY_STRING], void 0, (idSet) => {\n        collDel(idSet, id);\n        return collIsEmpty(idSet) ? 1 : 0;\n      });\n      mapSet(allListeners, id);\n      releaseId(id);\n      return idOrNulls;\n    });\n  const callListener = (id) =>\n    ifNotUndefined(\n      mapGet(allListeners, id),\n      ([listener, , path = [], pathGetters, extraArgsGetter]) => {\n        const callWithIds = (...ids) => {\n          const index = size(ids);\n          if (index == size(path)) {\n            listener(thing, ...ids, ...extraArgsGetter(ids));\n          } else if (isUndefined(path[index])) {\n            arrayForEach(pathGetters[index]?.(...ids) ?? [], (id2) =>\n              callWithIds(...ids, id2),\n            );\n          } else {\n            callWithIds(...ids, path[index]);\n          }\n        };\n        callWithIds();\n      },\n    );\n  return [addListener, callListeners, delListener, callListener];\n};\n\nconst scheduleRunning = mapNew();\nconst scheduleActions = mapNew();\nconst getStoreFunctions = (\n  persist = 1 /* StoreOnly */,\n  store,\n  isSynchronizer,\n) =>\n  persist != 1 /* StoreOnly */ && store.isMergeable()\n    ? [\n        1,\n        store.getMergeableContent,\n        () => store.getTransactionMergeableChanges(!isSynchronizer),\n        ([[changedTables], [changedValues]]) =>\n          !objIsEmpty(changedTables) || !objIsEmpty(changedValues),\n        store.setDefaultContent,\n      ]\n    : persist != 2 /* MergeableStoreOnly */\n      ? [\n          0,\n          store.getContent,\n          store.getTransactionChanges,\n          ([changedTables, changedValues]) =>\n            !objIsEmpty(changedTables) || !objIsEmpty(changedValues),\n          store.setContent,\n        ]\n      : errorNew('Store type not supported by this Persister');\nconst createCustomPersister = (\n  store,\n  getPersisted,\n  setPersisted,\n  addPersisterListener,\n  delPersisterListener,\n  onIgnoredError,\n  persist,\n  extra = {},\n  isSynchronizer = 0,\n  scheduleId = [],\n) => {\n  let status = 0; /* Idle */\n  let loads = 0;\n  let saves = 0;\n  let action;\n  let autoLoadHandle;\n  let autoSaveListenerId;\n  mapEnsure(scheduleRunning, scheduleId, () => 0);\n  mapEnsure(scheduleActions, scheduleId, () => []);\n  const statusListeners = mapNew();\n  const [\n    isMergeableStore,\n    getContent,\n    getChanges,\n    hasChanges,\n    setDefaultContent,\n  ] = getStoreFunctions(persist, store, isSynchronizer);\n  const [addListener, callListeners, delListenerImpl] = getListenerFunctions(\n    () => persister,\n  );\n  const setStatus = (newStatus) => {\n    if (newStatus != status) {\n      status = newStatus;\n      callListeners(statusListeners, void 0, status);\n    }\n  };\n  const run = async () => {\n    /* istanbul ignore else */\n    if (!mapGet(scheduleRunning, scheduleId)) {\n      mapSet(scheduleRunning, scheduleId, 1);\n      while (\n        !isUndefined((action = arrayShift(mapGet(scheduleActions, scheduleId))))\n      ) {\n        try {\n          await action();\n        } catch (error) {\n          /* istanbul ignore next */\n          onIgnoredError?.(error);\n        }\n      }\n      mapSet(scheduleRunning, scheduleId, 0);\n    }\n  };\n  const setContentOrChanges = (contentOrChanges) => {\n    (isMergeableStore && isArray(contentOrChanges?.[0])\n      ? contentOrChanges?.[2] === 1\n        ? store.applyMergeableChanges\n        : store.setMergeableContent\n      : contentOrChanges?.[2] === 1\n        ? store.applyChanges\n        : store.setContent)(contentOrChanges);\n  };\n  const load = async (initialContent) => {\n    /* istanbul ignore else */\n    if (status != 2 /* Saving */) {\n      setStatus(1 /* Loading */);\n      loads++;\n      await schedule(async () => {\n        try {\n          const content = await getPersisted();\n          if (isArray(content)) {\n            setContentOrChanges(content);\n          } else if (initialContent) {\n            setDefaultContent(initialContent);\n          } else {\n            errorNew(`Content is not an array: ${content}`);\n          }\n        } catch (error) {\n          onIgnoredError?.(error);\n          if (initialContent) {\n            setDefaultContent(initialContent);\n          }\n        }\n        setStatus(0 /* Idle */);\n      });\n    }\n    return persister;\n  };\n  const startAutoLoad = async (initialContent) => {\n    stopAutoLoad();\n    await load(initialContent);\n    try {\n      autoLoadHandle = await addPersisterListener(async (content, changes) => {\n        if (changes || content) {\n          /* istanbul ignore else */\n          if (status != 2 /* Saving */) {\n            setStatus(1 /* Loading */);\n            loads++;\n            setContentOrChanges(changes ?? content);\n            setStatus(0 /* Idle */);\n          }\n        } else {\n          await load();\n        }\n      });\n    } catch (error) {\n      /* istanbul ignore next */\n      onIgnoredError?.(error);\n    }\n    return persister;\n  };\n  const stopAutoLoad = () => {\n    if (autoLoadHandle) {\n      delPersisterListener(autoLoadHandle);\n      autoLoadHandle = void 0;\n    }\n    return persister;\n  };\n  const isAutoLoading = () => !isUndefined(autoLoadHandle);\n  const save = async (changes) => {\n    /* istanbul ignore else */\n    if (status != 1 /* Loading */) {\n      setStatus(2 /* Saving */);\n      saves++;\n      await schedule(async () => {\n        try {\n          await setPersisted(getContent, changes);\n        } catch (error) {\n          /* istanbul ignore next */\n          onIgnoredError?.(error);\n        }\n        setStatus(0 /* Idle */);\n      });\n    }\n    return persister;\n  };\n  const startAutoSave = async () => {\n    stopAutoSave();\n    await save();\n    autoSaveListenerId = store.addDidFinishTransactionListener(() => {\n      const changes = getChanges();\n      if (hasChanges(changes)) {\n        save(changes);\n      }\n    });\n    return persister;\n  };\n  const stopAutoSave = () => {\n    if (autoSaveListenerId) {\n      store.delListener(autoSaveListenerId);\n      autoSaveListenerId = void 0;\n    }\n    return persister;\n  };\n  const isAutoSaving = () => !isUndefined(autoSaveListenerId);\n  const getStatus = () => status;\n  const addStatusListener = (listener) =>\n    addListener(listener, statusListeners);\n  const delListener = (listenerId) => {\n    delListenerImpl(listenerId);\n    return store;\n  };\n  const schedule = async (...actions) => {\n    arrayPush(mapGet(scheduleActions, scheduleId), ...actions);\n    await run();\n    return persister;\n  };\n  const getStore = () => store;\n  const destroy = () => {\n    arrayClear(mapGet(scheduleActions, scheduleId));\n    return stopAutoLoad().stopAutoSave();\n  };\n  const getStats = () => ({loads, saves});\n  const persister = {\n    load,\n    startAutoLoad,\n    stopAutoLoad,\n    isAutoLoading,\n    save,\n    startAutoSave,\n    stopAutoSave,\n    isAutoSaving,\n    getStatus,\n    addStatusListener,\n    delListener,\n    schedule,\n    getStore,\n    destroy,\n    getStats,\n    ...extra,\n  };\n  return objFreeze(persister);\n};\n\nconst STORAGE = 'storage';\nconst createStoragePersister = (\n  store,\n  storageName,\n  storage,\n  onIgnoredError,\n) => {\n  const getPersisted = async () =>\n    jsonParseWithUndefined(storage.getItem(storageName));\n  const setPersisted = async (getContent) =>\n    storage.setItem(storageName, jsonStringWithUndefined(getContent()));\n  const addPersisterListener = (listener) => {\n    const storageListener = (event) => {\n      if (event.storageArea === storage && event.key === storageName) {\n        try {\n          listener(jsonParse(event.newValue));\n        } catch {\n          listener();\n        }\n      }\n    };\n    WINDOW.addEventListener(STORAGE, storageListener);\n    return storageListener;\n  };\n  const delPersisterListener = (storageListener) =>\n    WINDOW.removeEventListener(STORAGE, storageListener);\n  return createCustomPersister(\n    store,\n    getPersisted,\n    setPersisted,\n    addPersisterListener,\n    delPersisterListener,\n    onIgnoredError,\n    3,\n    // StoreOrMergeableStore,\n    {getStorageName: () => storageName},\n  );\n};\nconst createLocalPersister = (store, storageName, onIgnoredError) =>\n  createStoragePersister(store, storageName, localStorage, onIgnoredError);\nconst createSessionPersister = (store, storageName, onIgnoredError) =>\n  createStoragePersister(store, storageName, sessionStorage, onIgnoredError);\n\nexport {createLocalPersister, createSessionPersister};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3021, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3027, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/tinybase%405.4.8_%40cloudflare%2Bworkers-types%404.20250224.0_prettier%403.5.2_react-dom%4019.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/ui-react/index.js"],"sourcesContent":["import React from 'react';\n\nconst getTypeOf = (thing) => typeof thing;\nconst TINYBASE = 'tinybase';\nconst EMPTY_STRING = '';\nconst STRING = getTypeOf(EMPTY_STRING);\nconst FUNCTION = getTypeOf(getTypeOf);\nconst LISTENER = 'Listener';\nconst RESULT = 'Result';\nconst GET = 'get';\nconst SET = 'set';\nconst ADD = 'add';\nconst DEL = 'del';\nconst HAS = 'Has';\nconst _HAS = 'has';\nconst IDS = 'Ids';\nconst TABLE = 'Table';\nconst TABLES = TABLE + 's';\nconst TABLE_IDS = TABLE + IDS;\nconst ROW = 'Row';\nconst ROW_COUNT = ROW + 'Count';\nconst ROW_IDS = ROW + IDS;\nconst SORTED_ROW_IDS = 'Sorted' + ROW + IDS;\nconst CELL = 'Cell';\nconst CELL_IDS = CELL + IDS;\nconst VALUE = 'Value';\nconst VALUES = VALUE + 's';\nconst VALUE_IDS = VALUE + IDS;\nconst TRANSACTION = 'Transaction';\nconst PARTIAL = 'Partial';\nconst FINISH = 'Finish';\nconst STATUS = 'Status';\nconst METRIC = 'Metric';\nconst INDEX = 'Index';\nconst SLICE = 'Slice';\nconst RELATIONSHIP = 'Relationship';\nconst REMOTE_ROW_ID = 'Remote' + ROW + 'Id';\nconst LOCAL = 'Local';\nconst LINKED = 'Linked';\nconst QUERY = 'Query';\nconst CHECKPOINT = 'Checkpoint';\n\nconst GLOBAL = globalThis;\nconst isUndefined = (thing) => thing == void 0;\nconst ifNotUndefined = (value, then, otherwise) =>\n  isUndefined(value) ? otherwise?.() : then(value);\nconst isString = (thing) => getTypeOf(thing) == STRING;\nconst isFunction = (thing) => getTypeOf(thing) == FUNCTION;\nconst isArray = (thing) => Array.isArray(thing);\nconst size = (arrayOrString) => arrayOrString.length;\nconst getUndefined = () => void 0;\n\nconst arrayNew = (size2, cb) =>\n  arrayMap(new Array(size2).fill(0), (_, index) => cb(index));\nconst arrayEvery = (array, cb) => array.every(cb);\nconst arrayIsEqual = (array1, array2) =>\n  size(array1) === size(array2) &&\n  arrayEvery(array1, (value1, index) => array2[index] === value1);\nconst arrayMap = (array, cb) => array.map(cb);\nconst arrayIsEmpty = (array) => size(array) == 0;\nconst arrayFilter = (array, cb) => array.filter(cb);\nconst arrayWith = (array, index, value) => array.with(index, value);\n\nconst {\n  PureComponent,\n  Fragment,\n  createContext,\n  createElement,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n  useSyncExternalStore,\n} = React;\nconst getProps = (getProps2, ...ids) =>\n  isUndefined(getProps2) ? {} : getProps2(...ids);\nconst getRelationshipsStoreTableIds = (relationships, relationshipId) => [\n  relationships,\n  relationships?.getStore(),\n  relationships?.getLocalTableId(relationshipId),\n  relationships?.getRemoteTableId(relationshipId),\n];\nconst getIndexStoreTableId = (indexes, indexId) => [\n  indexes,\n  indexes?.getStore(),\n  indexes?.getTableId(indexId),\n];\n\nconst object = Object;\nconst getPrototypeOf = (obj) => object.getPrototypeOf(obj);\nconst objEntries = object.entries;\nconst isObject = (obj) =>\n  !isUndefined(obj) &&\n  ifNotUndefined(\n    getPrototypeOf(obj),\n    (objPrototype) =>\n      objPrototype == object.prototype ||\n      isUndefined(getPrototypeOf(objPrototype)),\n\n    /* istanbul ignore next */\n    () => true,\n  );\nconst objIds = object.keys;\nconst objGet = (obj, id) => ifNotUndefined(obj, (obj2) => obj2[id]);\nconst objHas = (obj, id) => id in obj;\nconst objDel = (obj, id) => {\n  delete obj[id];\n  return obj;\n};\nconst objSize = (obj) => size(objIds(obj));\nconst objIsEqual = (obj1, obj2) => {\n  const entries1 = objEntries(obj1);\n  return (\n    size(entries1) === objSize(obj2) &&\n    arrayEvery(entries1, ([index, value1]) =>\n      isObject(value1)\n        ? isObject(obj2[index])\n          ? objIsEqual(obj2[index], value1)\n          : false\n        : obj2[index] === value1,\n    )\n  );\n};\nconst objEnsure = (obj, id, getDefaultValue) => {\n  if (!objHas(obj, id)) {\n    obj[id] = getDefaultValue();\n  }\n  return obj[id];\n};\n\nconst Context = objEnsure(GLOBAL, TINYBASE + '_uirc', () => createContext([]));\nconst useThing = (id, offset) => {\n  const contextValue = useContext(Context);\n  return isUndefined(id)\n    ? contextValue[offset * 2]\n    : isString(id)\n      ? objGet(contextValue[offset * 2 + 1] ?? {}, id)\n      : id;\n};\nconst useThings = (offset) => ({...useContext(Context)[offset * 2 + 1]});\nconst useThingOrThingById = (thingOrThingId, offset) => {\n  const thing = useThing(thingOrThingId, offset);\n  return isUndefined(thingOrThingId) || isString(thingOrThingId)\n    ? thing\n    : thingOrThingId;\n};\nconst useProvideThing = (thingId, thing, offset) => {\n  const {16: addExtraThingById, 17: delExtraThingById} = useContext(Context);\n  useEffect(() => {\n    addExtraThingById?.(offset, thingId, thing);\n    return () => delExtraThingById?.(offset, thingId);\n  }, [addExtraThingById, thingId, thing, offset, delExtraThingById]);\n};\nconst useThingIds = (offset) =>\n  objIds(useContext(Context)[offset * 2 + 1] ?? {});\nconst useStoreIds = () => useThingIds(0 /* Store */);\nconst useStore = (id) => useThing(id, 0 /* Store */);\nconst useStores = () => useThings(0 /* Store */);\nconst useStoreOrStoreById = (storeOrStoreId) =>\n  useThingOrThingById(storeOrStoreId, 0 /* Store */);\nconst useProvideStore = (storeId, store) =>\n  useProvideThing(storeId, store, 0 /* Store */);\nconst useMetricsIds = () => useThingIds(1 /* Metrics */);\nconst useMetrics = (id) => useThing(id, 1 /* Metrics */);\nconst useMetricsOrMetricsById = (metricsOrMetricsId) =>\n  useThingOrThingById(metricsOrMetricsId, 1 /* Metrics */);\nconst useProvideMetrics = (metricsId, metrics) =>\n  useProvideThing(metricsId, metrics, 1 /* Metrics */);\nconst useIndexesIds = () => useThingIds(2 /* Indexes */);\nconst useIndexes = (id) => useThing(id, 2 /* Indexes */);\nconst useIndexesOrIndexesById = (indexesOrIndexesId) =>\n  useThingOrThingById(indexesOrIndexesId, 2 /* Indexes */);\nconst useProvideIndexes = (indexesId, indexes) =>\n  useProvideThing(indexesId, indexes, 2 /* Indexes */);\nconst useRelationshipsIds = () => useThingIds(3 /* Relationships */);\nconst useRelationships = (id) => useThing(id, 3 /* Relationships */);\nconst useRelationshipsOrRelationshipsById = (relationshipsOrRelationshipsId) =>\n  useThingOrThingById(relationshipsOrRelationshipsId, 3 /* Relationships */);\nconst useProvideRelationships = (relationshipsId, relationships) =>\n  useProvideThing(relationshipsId, relationships, 3 /* Relationships */);\nconst useQueriesIds = () => useThingIds(4 /* Queries */);\nconst useQueries = (id) => useThing(id, 4 /* Queries */);\nconst useQueriesOrQueriesById = (queriesOrQueriesId) =>\n  useThingOrThingById(queriesOrQueriesId, 4 /* Queries */);\nconst useProvideQueries = (queriesId, queries) =>\n  useProvideThing(queriesId, queries, 4 /* Queries */);\nconst useCheckpointsIds = () => useThingIds(5 /* Checkpoints */);\nconst useCheckpoints = (id) => useThing(id, 5 /* Checkpoints */);\nconst useCheckpointsOrCheckpointsById = (checkpointsOrCheckpointsId) =>\n  useThingOrThingById(checkpointsOrCheckpointsId, 5 /* Checkpoints */);\nconst useProvideCheckpoints = (checkpointsId, checkpoints) =>\n  useProvideThing(checkpointsId, checkpoints, 5 /* Checkpoints */);\nconst usePersisterIds = () => useThingIds(6 /* Persister */);\nconst usePersister = (id) => useThing(id, 6 /* Persister */);\nconst usePersisterOrPersisterById = (persisterOrPersisterId) =>\n  useThingOrThingById(persisterOrPersisterId, 6 /* Persister */);\nconst useProvidePersister = (persisterId, persister) =>\n  useProvideThing(persisterId, persister, 6 /* Persister */);\nconst useSynchronizerIds = () => useThingIds(7 /* Synchronizer */);\nconst useSynchronizer = (id) => useThing(id, 7 /* Synchronizer */);\nconst useSynchronizerOrSynchronizerById = (synchronizerOrSynchronizerId) =>\n  useThingOrThingById(synchronizerOrSynchronizerId, 7 /* Synchronizer */);\nconst useProvideSynchronizer = (persisterId, persister) =>\n  useProvideThing(persisterId, persister, 7 /* Synchronizer */);\n\nconst EMPTY_ARRAY = [];\nconst DEFAULTS = [{}, [], [EMPTY_ARRAY, void 0, EMPTY_ARRAY], void 0, false, 0];\nconst IS_EQUALS = [\n  objIsEqual,\n  arrayIsEqual,\n  (\n    [backwardIds1, currentId1, forwardIds1],\n    [backwardIds2, currentId2, forwardIds2],\n  ) =>\n    currentId1 === currentId2 &&\n    arrayIsEqual(backwardIds1, backwardIds2) &&\n    arrayIsEqual(forwardIds1, forwardIds2),\n];\nconst isEqual = (thing1, thing2) => thing1 === thing2;\nconst useCreate = (store, create, createDeps = EMPTY_ARRAY) => {\n  const [, rerender] = useState();\n  const [thing, setThing] = useState();\n  useEffect(\n    () => {\n      const newThing = store ? create(store) : void 0;\n      setThing(newThing);\n      rerender([]);\n      return newThing?.destroy;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [store, ...createDeps],\n  );\n  return thing;\n};\nconst addAndDelListener = (thing, listenable, ...args) => {\n  const listenerId = thing?.[ADD + listenable + LISTENER]?.(...args);\n  return () => thing?.delListener(listenerId);\n};\nconst useListenable = (listenable, thing, returnType, args = EMPTY_ARRAY) => {\n  const lastResult = useRef(DEFAULTS[returnType]);\n  const getResult = useCallback(\n    () => {\n      const nextResult =\n        thing?.[(returnType == 4 /* Boolean */ ? _HAS : GET) + listenable]?.(\n          ...args,\n        ) ?? DEFAULTS[returnType];\n      return !(IS_EQUALS[returnType] ?? isEqual)(nextResult, lastResult.current)\n        ? (lastResult.current = nextResult)\n        : lastResult.current;\n    },\n    /* eslint-disable-next-line react-hooks/exhaustive-deps */\n    [thing, returnType, listenable, ...args],\n  );\n  const subscribe = useCallback(\n    (listener) =>\n      addAndDelListener(\n        thing,\n        (returnType == 4 /* Boolean */ ? HAS : EMPTY_STRING) + listenable,\n        ...args,\n        listener,\n      ),\n    /* eslint-disable-next-line react-hooks/exhaustive-deps */\n    [thing, returnType, listenable, ...args],\n  );\n  return useSyncExternalStore(subscribe, getResult, getResult);\n};\nconst useListener = (\n  listenable,\n  thing,\n  listener,\n  listenerDeps = EMPTY_ARRAY,\n  preArgs = EMPTY_ARRAY,\n  ...postArgs\n) =>\n  useLayoutEffect(\n    () =>\n      addAndDelListener(thing, listenable, ...preArgs, listener, ...postArgs),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [thing, listenable, ...preArgs, ...listenerDeps, ...postArgs],\n  );\nconst useSetCallback = (\n  storeOrStoreId,\n  settable,\n  get,\n  getDeps = EMPTY_ARRAY,\n  then = getUndefined,\n  thenDeps = EMPTY_ARRAY,\n  ...args\n) => {\n  const store = useStoreOrStoreById(storeOrStoreId);\n  return useCallback(\n    (parameter) =>\n      ifNotUndefined(store, (store2) =>\n        ifNotUndefined(get(parameter, store2), (thing) =>\n          then(\n            store2[SET + settable](\n              ...argsOrGetArgs(args, store2, parameter),\n              thing,\n            ),\n            thing,\n          ),\n        ),\n      ),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [store, settable, ...getDeps, ...thenDeps, ...nonFunctionDeps(args)],\n  );\n};\nconst argsOrGetArgs = (args, store, parameter) =>\n  arrayMap(args, (arg) => (isFunction(arg) ? arg(parameter, store) : arg));\nconst nonFunctionDeps = (args) => arrayFilter(args, (arg) => !isFunction(arg));\nconst useDel = (\n  storeOrStoreId,\n  deletable,\n  then = getUndefined,\n  thenDeps = EMPTY_ARRAY,\n  ...args\n) => {\n  const store = useStoreOrStoreById(storeOrStoreId);\n  return useCallback(\n    (parameter) =>\n      then(store?.[DEL + deletable](...argsOrGetArgs(args, store, parameter))),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [store, deletable, ...thenDeps, ...nonFunctionDeps(args)],\n  );\n};\nconst useCheckpointAction = (checkpointsOrCheckpointsId, action, arg) => {\n  const checkpoints = useCheckpointsOrCheckpointsById(\n    checkpointsOrCheckpointsId,\n  );\n  return useCallback(\n    () => checkpoints?.[action](arg),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [checkpoints, action, arg],\n  );\n};\nconst useCreateStore = (create, createDeps = EMPTY_ARRAY) =>\n  useMemo(create, createDeps);\nconst useCreateMergeableStore = (create, createDeps = EMPTY_ARRAY) =>\n  useMemo(create, createDeps);\nconst useHasTables = (storeOrStoreId) =>\n  useListenable(\n    TABLES,\n    useStoreOrStoreById(storeOrStoreId),\n    4 /* Boolean */,\n    [],\n  );\nconst useTables = (storeOrStoreId) =>\n  useListenable(TABLES, useStoreOrStoreById(storeOrStoreId), 0 /* Object */);\nconst useTableIds = (storeOrStoreId) =>\n  useListenable(TABLE_IDS, useStoreOrStoreById(storeOrStoreId), 1 /* Array */);\nconst useHasTable = (tableId, storeOrStoreId) =>\n  useListenable(TABLE, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */, [\n    tableId,\n  ]);\nconst useTable = (tableId, storeOrStoreId) =>\n  useListenable(TABLE, useStoreOrStoreById(storeOrStoreId), 0 /* Object */, [\n    tableId,\n  ]);\nconst useTableCellIds = (tableId, storeOrStoreId) =>\n  useListenable(\n    TABLE + CELL_IDS,\n    useStoreOrStoreById(storeOrStoreId),\n    1 /* Array */,\n    [tableId],\n  );\nconst useHasTableCell = (tableId, cellId, storeOrStoreId) =>\n  useListenable(\n    TABLE + CELL,\n    useStoreOrStoreById(storeOrStoreId),\n    4 /* Boolean */,\n    [tableId, cellId],\n  );\nconst useRowCount = (tableId, storeOrStoreId) =>\n  useListenable(\n    ROW_COUNT,\n    useStoreOrStoreById(storeOrStoreId),\n    5 /* Number */,\n    [tableId],\n  );\nconst useRowIds = (tableId, storeOrStoreId) =>\n  useListenable(ROW_IDS, useStoreOrStoreById(storeOrStoreId), 1 /* Array */, [\n    tableId,\n  ]);\nconst useSortedRowIds = (\n  tableId,\n  cellId,\n  descending,\n  offset = 0,\n  limit,\n  storeOrStoreId,\n) =>\n  useListenable(\n    SORTED_ROW_IDS,\n    useStoreOrStoreById(storeOrStoreId),\n    1 /* Array */,\n    [tableId, cellId, descending, offset, limit],\n  );\nconst useHasRow = (tableId, rowId, storeOrStoreId) =>\n  useListenable(ROW, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */, [\n    tableId,\n    rowId,\n  ]);\nconst useRow = (tableId, rowId, storeOrStoreId) =>\n  useListenable(ROW, useStoreOrStoreById(storeOrStoreId), 0 /* Object */, [\n    tableId,\n    rowId,\n  ]);\nconst useCellIds = (tableId, rowId, storeOrStoreId) =>\n  useListenable(CELL_IDS, useStoreOrStoreById(storeOrStoreId), 1 /* Array */, [\n    tableId,\n    rowId,\n  ]);\nconst useHasCell = (tableId, rowId, cellId, storeOrStoreId) =>\n  useListenable(CELL, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */, [\n    tableId,\n    rowId,\n    cellId,\n  ]);\nconst useCell = (tableId, rowId, cellId, storeOrStoreId) =>\n  useListenable(\n    CELL,\n    useStoreOrStoreById(storeOrStoreId),\n    3 /* CellOrValue */,\n    [tableId, rowId, cellId],\n  );\nconst useHasValues = (storeOrStoreId) =>\n  useListenable(\n    VALUES,\n    useStoreOrStoreById(storeOrStoreId),\n    4 /* Boolean */,\n    [],\n  );\nconst useValues = (storeOrStoreId) =>\n  useListenable(VALUES, useStoreOrStoreById(storeOrStoreId), 0 /* Object */);\nconst useValueIds = (storeOrStoreId) =>\n  useListenable(VALUE_IDS, useStoreOrStoreById(storeOrStoreId), 1 /* Array */);\nconst useHasValue = (valueId, storeOrStoreId) =>\n  useListenable(VALUE, useStoreOrStoreById(storeOrStoreId), 4 /* Boolean */, [\n    valueId,\n  ]);\nconst useValue = (valueId, storeOrStoreId) =>\n  useListenable(\n    VALUE,\n    useStoreOrStoreById(storeOrStoreId),\n    3 /* CellOrValue */,\n    [valueId],\n  );\nconst useSetTablesCallback = (\n  getTables,\n  getTablesDeps,\n  storeOrStoreId,\n  then,\n  thenDeps,\n) =>\n  useSetCallback(\n    storeOrStoreId,\n    TABLES,\n    getTables,\n    getTablesDeps,\n    then,\n    thenDeps,\n  );\nconst useSetTableCallback = (\n  tableId,\n  getTable,\n  getTableDeps,\n  storeOrStoreId,\n  then,\n  thenDeps,\n) =>\n  useSetCallback(\n    storeOrStoreId,\n    TABLE,\n    getTable,\n    getTableDeps,\n    then,\n    thenDeps,\n    tableId,\n  );\nconst useSetRowCallback = (\n  tableId,\n  rowId,\n  getRow,\n  getRowDeps,\n  storeOrStoreId,\n  then,\n  thenDeps,\n) =>\n  useSetCallback(\n    storeOrStoreId,\n    ROW,\n    getRow,\n    getRowDeps,\n    then,\n    thenDeps,\n    tableId,\n    rowId,\n  );\nconst useAddRowCallback = (\n  tableId,\n  getRow,\n  getRowDeps = EMPTY_ARRAY,\n  storeOrStoreId,\n  then = getUndefined,\n  thenDeps = EMPTY_ARRAY,\n  reuseRowIds = true,\n) => {\n  const store = useStoreOrStoreById(storeOrStoreId);\n  return useCallback(\n    (parameter) =>\n      ifNotUndefined(store, (store2) =>\n        ifNotUndefined(getRow(parameter, store2), (row) =>\n          then(\n            store2.addRow(\n              isFunction(tableId) ? tableId(parameter, store2) : tableId,\n              row,\n              reuseRowIds,\n            ),\n            store2,\n            row,\n          ),\n        ),\n      ),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [store, tableId, ...getRowDeps, ...thenDeps, reuseRowIds],\n  );\n};\nconst useSetPartialRowCallback = (\n  tableId,\n  rowId,\n  getPartialRow,\n  getPartialRowDeps,\n  storeOrStoreId,\n  then,\n  thenDeps,\n) =>\n  useSetCallback(\n    storeOrStoreId,\n    PARTIAL + ROW,\n    getPartialRow,\n    getPartialRowDeps,\n    then,\n    thenDeps,\n    tableId,\n    rowId,\n  );\nconst useSetCellCallback = (\n  tableId,\n  rowId,\n  cellId,\n  getCell,\n  getCellDeps,\n  storeOrStoreId,\n  then,\n  thenDeps,\n) =>\n  useSetCallback(\n    storeOrStoreId,\n    CELL,\n    getCell,\n    getCellDeps,\n    then,\n    thenDeps,\n    tableId,\n    rowId,\n    cellId,\n  );\nconst useSetValuesCallback = (\n  getValues,\n  getValuesDeps,\n  storeOrStoreId,\n  then,\n  thenDeps,\n) =>\n  useSetCallback(\n    storeOrStoreId,\n    VALUES,\n    getValues,\n    getValuesDeps,\n    then,\n    thenDeps,\n  );\nconst useSetPartialValuesCallback = (\n  getPartialValues,\n  getPartialValuesDeps,\n  storeOrStoreId,\n  then,\n  thenDeps,\n) =>\n  useSetCallback(\n    storeOrStoreId,\n    PARTIAL + VALUES,\n    getPartialValues,\n    getPartialValuesDeps,\n    then,\n    thenDeps,\n  );\nconst useSetValueCallback = (\n  valueId,\n  getValue,\n  getValueDeps,\n  storeOrStoreId,\n  then,\n  thenDeps,\n) =>\n  useSetCallback(\n    storeOrStoreId,\n    VALUE,\n    getValue,\n    getValueDeps,\n    then,\n    thenDeps,\n    valueId,\n  );\nconst useDelTablesCallback = (storeOrStoreId, then, thenDeps) =>\n  useDel(storeOrStoreId, TABLES, then, thenDeps);\nconst useDelTableCallback = (tableId, storeOrStoreId, then, thenDeps) =>\n  useDel(storeOrStoreId, TABLE, then, thenDeps, tableId);\nconst useDelRowCallback = (tableId, rowId, storeOrStoreId, then, thenDeps) =>\n  useDel(storeOrStoreId, ROW, then, thenDeps, tableId, rowId);\nconst useDelCellCallback = (\n  tableId,\n  rowId,\n  cellId,\n  forceDel,\n  storeOrStoreId,\n  then,\n  thenDeps,\n) =>\n  useDel(\n    storeOrStoreId,\n    CELL,\n    then,\n    thenDeps,\n    tableId,\n    rowId,\n    cellId,\n    forceDel,\n  );\nconst useDelValuesCallback = (storeOrStoreId, then, thenDeps) =>\n  useDel(storeOrStoreId, VALUES, then, thenDeps);\nconst useDelValueCallback = (valueId, storeOrStoreId, then, thenDeps) =>\n  useDel(storeOrStoreId, VALUE, then, thenDeps, valueId);\nconst useHasTablesListener = (\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    HAS + TABLES,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [],\n    mutator,\n  );\nconst useTablesListener = (listener, listenerDeps, mutator, storeOrStoreId) =>\n  useListener(\n    TABLES,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    EMPTY_ARRAY,\n    mutator,\n  );\nconst useTableIdsListener = (listener, listenerDeps, mutator, storeOrStoreId) =>\n  useListener(\n    TABLE_IDS,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    EMPTY_ARRAY,\n    mutator,\n  );\nconst useHasTableListener = (\n  tableId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    HAS + TABLE,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId],\n    mutator,\n  );\nconst useTableListener = (\n  tableId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    TABLE,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId],\n    mutator,\n  );\nconst useTableCellIdsListener = (\n  tableId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    TABLE + CELL_IDS,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId],\n    mutator,\n  );\nconst useHasTableCellListener = (\n  tableId,\n  cellId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    HAS + TABLE + CELL,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId, cellId],\n    mutator,\n  );\nconst useRowCountListener = (\n  tableId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    ROW_COUNT,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId],\n    mutator,\n  );\nconst useRowIdsListener = (\n  tableId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    ROW_IDS,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId],\n    mutator,\n  );\nconst useSortedRowIdsListener = (\n  tableId,\n  cellId,\n  descending,\n  offset,\n  limit,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    SORTED_ROW_IDS,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId, cellId, descending, offset, limit],\n    mutator,\n  );\nconst useHasRowListener = (\n  tableId,\n  rowId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    HAS + ROW,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId, rowId],\n    mutator,\n  );\nconst useRowListener = (\n  tableId,\n  rowId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    ROW,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId, rowId],\n    mutator,\n  );\nconst useCellIdsListener = (\n  tableId,\n  rowId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    CELL_IDS,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId, rowId],\n    mutator,\n  );\nconst useHasCellListener = (\n  tableId,\n  rowId,\n  cellId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    HAS + CELL,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId, rowId, cellId],\n    mutator,\n  );\nconst useCellListener = (\n  tableId,\n  rowId,\n  cellId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    CELL,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [tableId, rowId, cellId],\n    mutator,\n  );\nconst useHasValuesListener = (\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    HAS + VALUES,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [],\n    mutator,\n  );\nconst useValuesListener = (listener, listenerDeps, mutator, storeOrStoreId) =>\n  useListener(\n    VALUES,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    EMPTY_ARRAY,\n    mutator,\n  );\nconst useValueIdsListener = (listener, listenerDeps, mutator, storeOrStoreId) =>\n  useListener(\n    VALUE_IDS,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    EMPTY_ARRAY,\n    mutator,\n  );\nconst useHasValueListener = (\n  valueId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    HAS + VALUE,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [valueId],\n    mutator,\n  );\nconst useValueListener = (\n  valueId,\n  listener,\n  listenerDeps,\n  mutator,\n  storeOrStoreId,\n) =>\n  useListener(\n    VALUE,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n    [valueId],\n    mutator,\n  );\nconst useStartTransactionListener = (listener, listenerDeps, storeOrStoreId) =>\n  useListener(\n    'Start' + TRANSACTION,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n  );\nconst useWillFinishTransactionListener = (\n  listener,\n  listenerDeps,\n  storeOrStoreId,\n) =>\n  useListener(\n    'Will' + FINISH + TRANSACTION,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n  );\nconst useDidFinishTransactionListener = (\n  listener,\n  listenerDeps,\n  storeOrStoreId,\n) =>\n  useListener(\n    'Did' + FINISH + TRANSACTION,\n    useStoreOrStoreById(storeOrStoreId),\n    listener,\n    listenerDeps,\n  );\nconst useCreateMetrics = (store, create, createDeps) =>\n  useCreate(store, create, createDeps);\nconst useMetricIds = (metricsOrMetricsId) =>\n  useListenable(\n    METRIC + IDS,\n    useMetricsOrMetricsById(metricsOrMetricsId),\n    1 /* Array */,\n  );\nconst useMetric = (metricId, metricsOrMetricsId) =>\n  useListenable(\n    METRIC,\n    useMetricsOrMetricsById(metricsOrMetricsId),\n    3 /* CellOrValue */,\n    [metricId],\n  );\nconst useMetricListener = (\n  metricId,\n  listener,\n  listenerDeps,\n  metricsOrMetricsId,\n) =>\n  useListener(\n    METRIC,\n    useMetricsOrMetricsById(metricsOrMetricsId),\n    listener,\n    listenerDeps,\n    [metricId],\n  );\nconst useCreateIndexes = (store, create, createDeps) =>\n  useCreate(store, create, createDeps);\nconst useSliceIds = (indexId, indexesOrIndexesId) =>\n  useListenable(\n    SLICE + IDS,\n    useIndexesOrIndexesById(indexesOrIndexesId),\n    1 /* Array */,\n    [indexId],\n  );\nconst useIndexIds = (indexesOrIndexesId) =>\n  useListenable(\n    INDEX + IDS,\n    useIndexesOrIndexesById(indexesOrIndexesId),\n    1 /* Array */,\n  );\nconst useSliceRowIds = (indexId, sliceId, indexesOrIndexesId) =>\n  useListenable(\n    SLICE + ROW_IDS,\n    useIndexesOrIndexesById(indexesOrIndexesId),\n    1 /* Array */,\n    [indexId, sliceId],\n  );\nconst useSliceIdsListener = (\n  indexId,\n  listener,\n  listenerDeps,\n  indexesOrIndexesId,\n) =>\n  useListener(\n    SLICE + IDS,\n    useIndexesOrIndexesById(indexesOrIndexesId),\n    listener,\n    listenerDeps,\n    [indexId],\n  );\nconst useSliceRowIdsListener = (\n  indexId,\n  sliceId,\n  listener,\n  listenerDeps,\n  indexesOrIndexesId,\n) =>\n  useListener(\n    SLICE + ROW_IDS,\n    useIndexesOrIndexesById(indexesOrIndexesId),\n    listener,\n    listenerDeps,\n    [indexId, sliceId],\n  );\nconst useCreateRelationships = (store, create, createDeps) =>\n  useCreate(store, create, createDeps);\nconst useRelationshipIds = (relationshipsOrRelationshipsId) =>\n  useListenable(\n    RELATIONSHIP + IDS,\n    useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId),\n    1 /* Array */,\n  );\nconst useRemoteRowId = (\n  relationshipId,\n  localRowId,\n  relationshipsOrRelationshipsId,\n) =>\n  useListenable(\n    REMOTE_ROW_ID,\n    useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId),\n    3 /* CellOrValue */,\n    [relationshipId, localRowId],\n  );\nconst useLocalRowIds = (\n  relationshipId,\n  remoteRowId,\n  relationshipsOrRelationshipsId,\n) =>\n  useListenable(\n    LOCAL + ROW_IDS,\n    useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId),\n    1 /* Array */,\n    [relationshipId, remoteRowId],\n  );\nconst useLinkedRowIds = (\n  relationshipId,\n  firstRowId,\n  relationshipsOrRelationshipsId,\n) =>\n  useListenable(\n    LINKED + ROW_IDS,\n    useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId),\n    1 /* Array */,\n    [relationshipId, firstRowId],\n  );\nconst useRemoteRowIdListener = (\n  relationshipId,\n  localRowId,\n  listener,\n  listenerDeps,\n  relationshipsOrRelationshipsId,\n) =>\n  useListener(\n    REMOTE_ROW_ID,\n    useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId),\n    listener,\n    listenerDeps,\n    [relationshipId, localRowId],\n  );\nconst useLocalRowIdsListener = (\n  relationshipId,\n  remoteRowId,\n  listener,\n  listenerDeps,\n  relationshipsOrRelationshipsId,\n) =>\n  useListener(\n    LOCAL + ROW_IDS,\n    useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId),\n    listener,\n    listenerDeps,\n    [relationshipId, remoteRowId],\n  );\nconst useLinkedRowIdsListener = (\n  relationshipId,\n  firstRowId,\n  listener,\n  listenerDeps,\n  relationshipsOrRelationshipsId,\n) =>\n  useListener(\n    LINKED + ROW_IDS,\n    useRelationshipsOrRelationshipsById(relationshipsOrRelationshipsId),\n    listener,\n    listenerDeps,\n    [relationshipId, firstRowId],\n  );\nconst useCreateQueries = (store, create, createDeps) =>\n  useCreate(store, create, createDeps);\nconst useQueryIds = (queriesOrQueriesId) =>\n  useListenable(\n    QUERY + IDS,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    1 /* Array */,\n  );\nconst useResultTable = (queryId, queriesOrQueriesId) =>\n  useListenable(\n    RESULT + TABLE,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    0 /* Object */,\n    [queryId],\n  );\nconst useResultTableCellIds = (queryId, queriesOrQueriesId) =>\n  useListenable(\n    RESULT + TABLE + CELL_IDS,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    1 /* Array */,\n    [queryId],\n  );\nconst useResultRowCount = (queryId, queriesOrQueriesId) =>\n  useListenable(\n    RESULT + ROW_COUNT,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    5 /* Number */,\n    [queryId],\n  );\nconst useResultRowIds = (queryId, queriesOrQueriesId) =>\n  useListenable(\n    RESULT + ROW_IDS,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    1 /* Array */,\n    [queryId],\n  );\nconst useResultSortedRowIds = (\n  queryId,\n  cellId,\n  descending,\n  offset = 0,\n  limit,\n  queriesOrQueriesId,\n) =>\n  useListenable(\n    RESULT + SORTED_ROW_IDS,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    1 /* Array */,\n    [queryId, cellId, descending, offset, limit],\n  );\nconst useResultRow = (queryId, rowId, queriesOrQueriesId) =>\n  useListenable(\n    RESULT + ROW,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    0 /* Object */,\n    [queryId, rowId],\n  );\nconst useResultCellIds = (queryId, rowId, queriesOrQueriesId) =>\n  useListenable(\n    RESULT + CELL_IDS,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    1 /* Array */,\n    [queryId, rowId],\n  );\nconst useResultCell = (queryId, rowId, cellId, queriesOrQueriesId) =>\n  useListenable(\n    RESULT + CELL,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    3 /* CellOrValue */,\n    [queryId, rowId, cellId],\n  );\nconst useResultTableListener = (\n  queryId,\n  listener,\n  listenerDeps,\n  queriesOrQueriesId,\n) =>\n  useListener(\n    RESULT + TABLE,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    listener,\n    listenerDeps,\n    [queryId],\n  );\nconst useResultTableCellIdsListener = (\n  queryId,\n  listener,\n  listenerDeps,\n  queriesOrQueriesId,\n) =>\n  useListener(\n    RESULT + TABLE + CELL_IDS,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    listener,\n    listenerDeps,\n    [queryId],\n  );\nconst useResultRowCountListener = (\n  queryId,\n  listener,\n  listenerDeps,\n  queriesOrQueriesId,\n) =>\n  useListener(\n    RESULT + ROW_COUNT,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    listener,\n    listenerDeps,\n    [queryId],\n  );\nconst useResultRowIdsListener = (\n  queryId,\n  listener,\n  listenerDeps,\n  queriesOrQueriesId,\n) =>\n  useListener(\n    RESULT + ROW_IDS,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    listener,\n    listenerDeps,\n    [queryId],\n  );\nconst useResultSortedRowIdsListener = (\n  queryId,\n  cellId,\n  descending,\n  offset,\n  limit,\n  listener,\n  listenerDeps,\n  queriesOrQueriesId,\n) =>\n  useListener(\n    RESULT + SORTED_ROW_IDS,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    listener,\n    listenerDeps,\n    [queryId, cellId, descending, offset, limit],\n  );\nconst useResultRowListener = (\n  queryId,\n  rowId,\n  listener,\n  listenerDeps,\n  queriesOrQueriesId,\n) =>\n  useListener(\n    RESULT + ROW,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    listener,\n    listenerDeps,\n    [queryId, rowId],\n  );\nconst useResultCellIdsListener = (\n  queryId,\n  rowId,\n  listener,\n  listenerDeps,\n  queriesOrQueriesId,\n) =>\n  useListener(\n    RESULT + CELL_IDS,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    listener,\n    listenerDeps,\n    [queryId, rowId],\n  );\nconst useResultCellListener = (\n  queryId,\n  rowId,\n  cellId,\n  listener,\n  listenerDeps,\n  queriesOrQueriesId,\n) =>\n  useListener(\n    RESULT + CELL,\n    useQueriesOrQueriesById(queriesOrQueriesId),\n    listener,\n    listenerDeps,\n    [queryId, rowId, cellId],\n  );\nconst useCreateCheckpoints = (store, create, createDeps) =>\n  useCreate(store, create, createDeps);\nconst useCheckpointIds = (checkpointsOrCheckpointsId) =>\n  useListenable(\n    CHECKPOINT + IDS,\n    useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId),\n    2 /* Checkpoints */,\n  );\nconst useCheckpoint = (checkpointId, checkpointsOrCheckpointsId) =>\n  useListenable(\n    CHECKPOINT,\n    useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId),\n    3 /* CellOrValue */,\n    [checkpointId],\n  );\nconst useSetCheckpointCallback = (\n  getCheckpoint = getUndefined,\n  getCheckpointDeps = EMPTY_ARRAY,\n  checkpointsOrCheckpointsId,\n  then = getUndefined,\n  thenDeps = EMPTY_ARRAY,\n) => {\n  const checkpoints = useCheckpointsOrCheckpointsById(\n    checkpointsOrCheckpointsId,\n  );\n  return useCallback(\n    (parameter) =>\n      ifNotUndefined(checkpoints, (checkpoints2) => {\n        const label = getCheckpoint(parameter);\n        then(checkpoints2.addCheckpoint(label), checkpoints2, label);\n      }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [checkpoints, ...getCheckpointDeps, ...thenDeps],\n  );\n};\nconst useGoBackwardCallback = (checkpointsOrCheckpointsId) =>\n  useCheckpointAction(checkpointsOrCheckpointsId, 'goBackward');\nconst useGoForwardCallback = (checkpointsOrCheckpointsId) =>\n  useCheckpointAction(checkpointsOrCheckpointsId, 'goForward');\nconst useGoToCallback = (\n  getCheckpointId,\n  getCheckpointIdDeps = EMPTY_ARRAY,\n  checkpointsOrCheckpointsId,\n  then = getUndefined,\n  thenDeps = EMPTY_ARRAY,\n) => {\n  const checkpoints = useCheckpointsOrCheckpointsById(\n    checkpointsOrCheckpointsId,\n  );\n  return useCallback(\n    (parameter) =>\n      ifNotUndefined(checkpoints, (checkpoints2) =>\n        ifNotUndefined(getCheckpointId(parameter), (checkpointId) =>\n          then(checkpoints2.goTo(checkpointId), checkpointId),\n        ),\n      ),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [checkpoints, ...getCheckpointIdDeps, ...thenDeps],\n  );\n};\nconst useUndoInformation = (checkpointsOrCheckpointsId) => {\n  const checkpoints = useCheckpointsOrCheckpointsById(\n    checkpointsOrCheckpointsId,\n  );\n  const [backwardIds, currentId] = useCheckpointIds(checkpoints);\n  return [\n    !arrayIsEmpty(backwardIds),\n    useGoBackwardCallback(checkpoints),\n    currentId,\n    ifNotUndefined(currentId, (id) => checkpoints?.getCheckpoint(id)) ??\n      EMPTY_STRING,\n  ];\n};\nconst useRedoInformation = (checkpointsOrCheckpointsId) => {\n  const checkpoints = useCheckpointsOrCheckpointsById(\n    checkpointsOrCheckpointsId,\n  );\n  const [, , [forwardId]] = useCheckpointIds(checkpoints);\n  return [\n    !isUndefined(forwardId),\n    useGoForwardCallback(checkpoints),\n    forwardId,\n    ifNotUndefined(forwardId, (id) => checkpoints?.getCheckpoint(id)) ??\n      EMPTY_STRING,\n  ];\n};\nconst useCheckpointIdsListener = (\n  listener,\n  listenerDeps,\n  checkpointsOrCheckpointsId,\n) =>\n  useListener(\n    CHECKPOINT + IDS,\n    useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId),\n    listener,\n    listenerDeps,\n  );\nconst useCheckpointListener = (\n  checkpointId,\n  listener,\n  listenerDeps,\n  checkpointsOrCheckpointsId,\n) =>\n  useListener(\n    CHECKPOINT,\n    useCheckpointsOrCheckpointsById(checkpointsOrCheckpointsId),\n    listener,\n    listenerDeps,\n    [checkpointId],\n  );\nconst useCreatePersister = (\n  store,\n  create,\n  createDeps = EMPTY_ARRAY,\n  then,\n  thenDeps = EMPTY_ARRAY,\n  destroy,\n  destroyDeps = EMPTY_ARRAY,\n) => {\n  const [, rerender] = useState();\n  const [persister, setPersister] = useState();\n  useEffect(\n    () => {\n      (async () => {\n        const persister2 = store ? await create(store) : void 0;\n        setPersister(persister2);\n        if (persister2 && then) {\n          (async () => {\n            await then(persister2);\n            rerender([]);\n          })();\n        }\n      })();\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [store, ...createDeps, ...thenDeps],\n  );\n  useEffect(\n    () => () => {\n      if (persister) {\n        persister.destroy();\n        destroy?.(persister);\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [persister, ...destroyDeps],\n  );\n  return persister;\n};\nconst usePersisterStatus = (persisterOrPersisterId) =>\n  useListenable(\n    STATUS,\n    usePersisterOrPersisterById(persisterOrPersisterId),\n    5 /* Number */,\n    [],\n  );\nconst usePersisterStatusListener = (\n  listener,\n  listenerDeps,\n  persisterOrPersisterId,\n) =>\n  useListener(\n    STATUS,\n    usePersisterOrPersisterById(persisterOrPersisterId),\n    listener,\n    listenerDeps,\n    [],\n  );\nconst useCreateSynchronizer = (\n  store,\n  create,\n  createDeps = EMPTY_ARRAY,\n  destroy,\n  destroyDeps = EMPTY_ARRAY,\n) => {\n  const [synchronizer, setSynchronizer] = useState();\n  useEffect(\n    () => {\n      (async () => {\n        const synchronizer2 = store ? await create(store) : void 0;\n        setSynchronizer(synchronizer2);\n      })();\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [store, ...createDeps],\n  );\n  useEffect(\n    () => () => {\n      if (synchronizer) {\n        synchronizer.destroy();\n        destroy?.(synchronizer);\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [synchronizer, ...destroyDeps],\n  );\n  return synchronizer;\n};\nconst useSynchronizerStatus = (synchronizerOrSynchronizerId) =>\n  useListenable(\n    STATUS,\n    useSynchronizerOrSynchronizerById(synchronizerOrSynchronizerId),\n    5 /* Number */,\n    [],\n  );\nconst useSynchronizerStatusListener = (\n  listener,\n  listenerDeps,\n  synchronizerOrSynchronizerId,\n) =>\n  useListener(\n    STATUS,\n    useSynchronizerOrSynchronizerById(synchronizerOrSynchronizerId),\n    listener,\n    listenerDeps,\n    [],\n  );\n\nconst mergeParentThings = (\n  offset,\n  parentValue,\n  defaultThing,\n  thingsById,\n  extraThingsById,\n) => [\n  defaultThing ?? parentValue[offset * 2],\n  {\n    ...parentValue[offset * 2 + 1],\n    ...thingsById,\n    ...extraThingsById[offset],\n  },\n];\nconst tableView = (\n  {\n    tableId,\n    store,\n    rowComponent: Row = RowView,\n    getRowComponentProps,\n    customCellIds,\n    separator,\n    debugIds,\n  },\n  rowIds,\n) =>\n  wrap(\n    arrayMap(rowIds, (rowId) =>\n      /* @__PURE__ */ createElement(Row, {\n        ...getProps(getRowComponentProps, rowId),\n        key: rowId,\n        tableId,\n        rowId,\n        customCellIds,\n        store,\n        debugIds,\n      }),\n    ),\n    separator,\n    debugIds,\n    tableId,\n  );\nconst resultTableView = (\n  {\n    queryId,\n    queries,\n    resultRowComponent: ResultRow = ResultRowView,\n    getResultRowComponentProps,\n    separator,\n    debugIds,\n  },\n  rowIds,\n) =>\n  wrap(\n    arrayMap(rowIds, (rowId) =>\n      /* @__PURE__ */ createElement(ResultRow, {\n        ...getProps(getResultRowComponentProps, rowId),\n        key: rowId,\n        queryId,\n        rowId,\n        queries,\n        debugIds,\n      }),\n    ),\n    separator,\n    debugIds,\n    queryId,\n  );\nconst useComponentPerRow = (\n  {\n    relationshipId,\n    relationships,\n    rowComponent: Row = RowView,\n    getRowComponentProps,\n    separator,\n    debugIds,\n  },\n  getRowIdsHook,\n  rowId,\n) => {\n  const [resolvedRelationships, store, localTableId] =\n    getRelationshipsStoreTableIds(\n      useRelationshipsOrRelationshipsById(relationships),\n      relationshipId,\n    );\n  const rowIds = getRowIdsHook(relationshipId, rowId, resolvedRelationships);\n  return wrap(\n    arrayMap(rowIds, (rowId2) =>\n      /* @__PURE__ */ createElement(Row, {\n        ...getProps(getRowComponentProps, rowId2),\n        key: rowId2,\n        tableId: localTableId,\n        rowId: rowId2,\n        store,\n        debugIds,\n      }),\n    ),\n    separator,\n    debugIds,\n    rowId,\n  );\n};\nconst getUseCheckpointView =\n  (getCheckpoints) =>\n  ({\n    checkpoints,\n    checkpointComponent: Checkpoint = CheckpointView,\n    getCheckpointComponentProps,\n    separator,\n    debugIds,\n  }) => {\n    const resolvedCheckpoints = useCheckpointsOrCheckpointsById(checkpoints);\n    return wrap(\n      arrayMap(\n        getCheckpoints(useCheckpointIds(resolvedCheckpoints)),\n        (checkpointId) =>\n          /* @__PURE__ */ createElement(Checkpoint, {\n            ...getProps(getCheckpointComponentProps, checkpointId),\n            key: checkpointId,\n            checkpoints: resolvedCheckpoints,\n            checkpointId,\n            debugIds,\n          }),\n      ),\n      separator,\n    );\n  };\nconst Provider = ({\n  store,\n  storesById,\n  metrics,\n  metricsById,\n  indexes,\n  indexesById,\n  relationships,\n  relationshipsById,\n  queries,\n  queriesById,\n  checkpoints,\n  checkpointsById,\n  persister,\n  persistersById,\n  synchronizer,\n  synchronizersById,\n  children,\n}) => {\n  const parentValue = useContext(Context);\n  const [extraThingsById, setExtraThingsById] = useState(() =>\n    arrayNew(8, () => ({})),\n  );\n  const addExtraThingById = useCallback(\n    (thingOffset, id, thing) =>\n      setExtraThingsById((extraThingsById2) =>\n        objGet(extraThingsById2[thingOffset], id) == thing\n          ? extraThingsById2\n          : arrayWith(extraThingsById2, thingOffset, {\n              ...extraThingsById2[thingOffset],\n              [id]: thing,\n            }),\n      ),\n    [],\n  );\n  const delExtraThingById = useCallback(\n    (thingOffset, id) =>\n      setExtraThingsById((extraThingsById2) =>\n        !objHas(extraThingsById2[thingOffset], id)\n          ? extraThingsById2\n          : arrayWith(\n              extraThingsById2,\n              thingOffset,\n              objDel(extraThingsById2[thingOffset], id),\n            ),\n      ),\n    [],\n  );\n  return /* @__PURE__ */ createElement(\n    Context.Provider,\n    {\n      value: useMemo(\n        () => [\n          ...mergeParentThings(\n            0 /* Store */,\n            parentValue,\n            store,\n            storesById,\n            extraThingsById,\n          ),\n          ...mergeParentThings(\n            1 /* Metrics */,\n            parentValue,\n            metrics,\n            metricsById,\n            extraThingsById,\n          ),\n          ...mergeParentThings(\n            2 /* Indexes */,\n            parentValue,\n            indexes,\n            indexesById,\n            extraThingsById,\n          ),\n          ...mergeParentThings(\n            3 /* Relationships */,\n            parentValue,\n            relationships,\n            relationshipsById,\n            extraThingsById,\n          ),\n          ...mergeParentThings(\n            4 /* Queries */,\n            parentValue,\n            queries,\n            queriesById,\n            extraThingsById,\n          ),\n          ...mergeParentThings(\n            5 /* Checkpoints */,\n            parentValue,\n            checkpoints,\n            checkpointsById,\n            extraThingsById,\n          ),\n          ...mergeParentThings(\n            6 /* Persister */,\n            parentValue,\n            persister,\n            persistersById,\n            extraThingsById,\n          ),\n          ...mergeParentThings(\n            7 /* Synchronizer */,\n            parentValue,\n            synchronizer,\n            synchronizersById,\n            extraThingsById,\n          ),\n          addExtraThingById,\n          delExtraThingById,\n        ],\n        [\n          extraThingsById,\n          store,\n          storesById,\n          metrics,\n          metricsById,\n          indexes,\n          indexesById,\n          relationships,\n          relationshipsById,\n          queries,\n          queriesById,\n          checkpoints,\n          checkpointsById,\n          persister,\n          persistersById,\n          synchronizer,\n          synchronizersById,\n          parentValue,\n          addExtraThingById,\n          delExtraThingById,\n        ],\n      ),\n    },\n    children,\n  );\n};\nconst wrap = (children, separator, encloseWithId, id) => {\n  const separated =\n    isUndefined(separator) || !isArray(children)\n      ? children\n      : arrayMap(children, (child, c) => (c > 0 ? [separator, child] : child));\n  return encloseWithId ? [id, ':{', separated, '}'] : separated;\n};\nconst useCustomOrDefaultCellIds = (customCellIds, tableId, rowId, store) => {\n  const defaultCellIds = useCellIds(tableId, rowId, store);\n  return customCellIds ?? defaultCellIds;\n};\nconst CellView = ({tableId, rowId, cellId, store, debugIds}) =>\n  wrap(\n    EMPTY_STRING + (useCell(tableId, rowId, cellId, store) ?? EMPTY_STRING),\n    void 0,\n    debugIds,\n    cellId,\n  );\nconst RowView = ({\n  tableId,\n  rowId,\n  store,\n  cellComponent: Cell = CellView,\n  getCellComponentProps,\n  customCellIds,\n  separator,\n  debugIds,\n}) =>\n  wrap(\n    arrayMap(\n      useCustomOrDefaultCellIds(customCellIds, tableId, rowId, store),\n      (cellId) =>\n        /* @__PURE__ */ createElement(Cell, {\n          ...getProps(getCellComponentProps, cellId),\n          key: cellId,\n          tableId,\n          rowId,\n          cellId,\n          store,\n          debugIds,\n        }),\n    ),\n    separator,\n    debugIds,\n    rowId,\n  );\nconst TableView = (props) =>\n  tableView(props, useRowIds(props.tableId, props.store));\nconst SortedTableView = ({cellId, descending, offset, limit, ...props}) =>\n  tableView(\n    props,\n    useSortedRowIds(\n      props.tableId,\n      cellId,\n      descending,\n      offset,\n      limit,\n      props.store,\n    ),\n  );\nconst TablesView = ({\n  store,\n  tableComponent: Table = TableView,\n  getTableComponentProps,\n  separator,\n  debugIds,\n}) =>\n  wrap(\n    arrayMap(useTableIds(store), (tableId) =>\n      /* @__PURE__ */ createElement(Table, {\n        ...getProps(getTableComponentProps, tableId),\n        key: tableId,\n        tableId,\n        store,\n        debugIds,\n      }),\n    ),\n    separator,\n  );\nconst ValueView = ({valueId, store, debugIds}) =>\n  wrap(\n    EMPTY_STRING + (useValue(valueId, store) ?? EMPTY_STRING),\n    void 0,\n    debugIds,\n    valueId,\n  );\nconst ValuesView = ({\n  store,\n  valueComponent: Value = ValueView,\n  getValueComponentProps,\n  separator,\n  debugIds,\n}) =>\n  wrap(\n    arrayMap(useValueIds(store), (valueId) =>\n      /* @__PURE__ */ createElement(Value, {\n        ...getProps(getValueComponentProps, valueId),\n        key: valueId,\n        valueId,\n        store,\n        debugIds,\n      }),\n    ),\n    separator,\n  );\nconst MetricView = ({metricId, metrics, debugIds}) =>\n  wrap(\n    useMetric(metricId, metrics) ?? EMPTY_STRING,\n    void 0,\n    debugIds,\n    metricId,\n  );\nconst SliceView = ({\n  indexId,\n  sliceId,\n  indexes,\n  rowComponent: Row = RowView,\n  getRowComponentProps,\n  separator,\n  debugIds,\n}) => {\n  const [resolvedIndexes, store, tableId] = getIndexStoreTableId(\n    useIndexesOrIndexesById(indexes),\n    indexId,\n  );\n  const rowIds = useSliceRowIds(indexId, sliceId, resolvedIndexes);\n  return wrap(\n    arrayMap(rowIds, (rowId) =>\n      /* @__PURE__ */ createElement(Row, {\n        ...getProps(getRowComponentProps, rowId),\n        key: rowId,\n        tableId,\n        rowId,\n        store,\n        debugIds,\n      }),\n    ),\n    separator,\n    debugIds,\n    sliceId,\n  );\n};\nconst IndexView = ({\n  indexId,\n  indexes,\n  sliceComponent: Slice = SliceView,\n  getSliceComponentProps,\n  separator,\n  debugIds,\n}) =>\n  wrap(\n    arrayMap(useSliceIds(indexId, indexes), (sliceId) =>\n      /* @__PURE__ */ createElement(Slice, {\n        ...getProps(getSliceComponentProps, sliceId),\n        key: sliceId,\n        indexId,\n        sliceId,\n        indexes,\n        debugIds,\n      }),\n    ),\n    separator,\n    debugIds,\n    indexId,\n  );\nconst RemoteRowView = ({\n  relationshipId,\n  localRowId,\n  relationships,\n  rowComponent: Row = RowView,\n  getRowComponentProps,\n  debugIds,\n}) => {\n  const [resolvedRelationships, store, , remoteTableId] =\n    getRelationshipsStoreTableIds(\n      useRelationshipsOrRelationshipsById(relationships),\n      relationshipId,\n    );\n  const rowId = useRemoteRowId(\n    relationshipId,\n    localRowId,\n    resolvedRelationships,\n  );\n  return wrap(\n    isUndefined(remoteTableId) || isUndefined(rowId)\n      ? null\n      : /* @__PURE__ */ createElement(Row, {\n          ...getProps(getRowComponentProps, rowId),\n          key: rowId,\n          tableId: remoteTableId,\n          rowId,\n          store,\n          debugIds,\n        }),\n    void 0,\n    debugIds,\n    localRowId,\n  );\n};\nconst LocalRowsView = (props) =>\n  useComponentPerRow(props, useLocalRowIds, props.remoteRowId);\nconst LinkedRowsView = (props) =>\n  useComponentPerRow(props, useLinkedRowIds, props.firstRowId);\nconst ResultCellView = ({queryId, rowId, cellId, queries, debugIds}) =>\n  wrap(\n    EMPTY_STRING +\n      (useResultCell(queryId, rowId, cellId, queries) ?? EMPTY_STRING),\n    void 0,\n    debugIds,\n    cellId,\n  );\nconst ResultRowView = ({\n  queryId,\n  rowId,\n  queries,\n  resultCellComponent: ResultCell = ResultCellView,\n  getResultCellComponentProps,\n  separator,\n  debugIds,\n}) =>\n  wrap(\n    arrayMap(useResultCellIds(queryId, rowId, queries), (cellId) =>\n      /* @__PURE__ */ createElement(ResultCell, {\n        ...getProps(getResultCellComponentProps, cellId),\n        key: cellId,\n        queryId,\n        rowId,\n        cellId,\n        queries,\n        debugIds,\n      }),\n    ),\n    separator,\n    debugIds,\n    rowId,\n  );\nconst ResultTableView = (props) =>\n  resultTableView(props, useResultRowIds(props.queryId, props.queries));\nconst ResultSortedTableView = ({cellId, descending, offset, limit, ...props}) =>\n  resultTableView(\n    props,\n    useResultSortedRowIds(\n      props.queryId,\n      cellId,\n      descending,\n      offset,\n      limit,\n      props.queries,\n    ),\n  );\nconst CheckpointView = ({checkpoints, checkpointId, debugIds}) =>\n  wrap(\n    useCheckpoint(checkpointId, checkpoints) ?? EMPTY_STRING,\n    void 0,\n    debugIds,\n    checkpointId,\n  );\nconst BackwardCheckpointsView = getUseCheckpointView(\n  (checkpointIds) => checkpointIds[0],\n);\nconst CurrentCheckpointView = getUseCheckpointView((checkpointIds) =>\n  isUndefined(checkpointIds[1]) ? [] : [checkpointIds[1]],\n);\nconst ForwardCheckpointsView = getUseCheckpointView(\n  (checkpointIds) => checkpointIds[2],\n);\n\nexport {\n  BackwardCheckpointsView,\n  CellView,\n  CheckpointView,\n  CurrentCheckpointView,\n  ForwardCheckpointsView,\n  IndexView,\n  LinkedRowsView,\n  LocalRowsView,\n  MetricView,\n  Provider,\n  RemoteRowView,\n  ResultCellView,\n  ResultRowView,\n  ResultSortedTableView,\n  ResultTableView,\n  RowView,\n  SliceView,\n  SortedTableView,\n  TableView,\n  TablesView,\n  ValueView,\n  ValuesView,\n  useAddRowCallback,\n  useCell,\n  useCellIds,\n  useCellIdsListener,\n  useCellListener,\n  useCheckpoint,\n  useCheckpointIds,\n  useCheckpointIdsListener,\n  useCheckpointListener,\n  useCheckpoints,\n  useCheckpointsIds,\n  useCheckpointsOrCheckpointsById,\n  useCreateCheckpoints,\n  useCreateIndexes,\n  useCreateMergeableStore,\n  useCreateMetrics,\n  useCreatePersister,\n  useCreateQueries,\n  useCreateRelationships,\n  useCreateStore,\n  useCreateSynchronizer,\n  useDelCellCallback,\n  useDelRowCallback,\n  useDelTableCallback,\n  useDelTablesCallback,\n  useDelValueCallback,\n  useDelValuesCallback,\n  useDidFinishTransactionListener,\n  useGoBackwardCallback,\n  useGoForwardCallback,\n  useGoToCallback,\n  useHasCell,\n  useHasCellListener,\n  useHasRow,\n  useHasRowListener,\n  useHasTable,\n  useHasTableCell,\n  useHasTableCellListener,\n  useHasTableListener,\n  useHasTables,\n  useHasTablesListener,\n  useHasValue,\n  useHasValueListener,\n  useHasValues,\n  useHasValuesListener,\n  useIndexIds,\n  useIndexes,\n  useIndexesIds,\n  useIndexesOrIndexesById,\n  useLinkedRowIds,\n  useLinkedRowIdsListener,\n  useLocalRowIds,\n  useLocalRowIdsListener,\n  useMetric,\n  useMetricIds,\n  useMetricListener,\n  useMetrics,\n  useMetricsIds,\n  useMetricsOrMetricsById,\n  usePersister,\n  usePersisterIds,\n  usePersisterOrPersisterById,\n  usePersisterStatus,\n  usePersisterStatusListener,\n  useProvideCheckpoints,\n  useProvideIndexes,\n  useProvideMetrics,\n  useProvidePersister,\n  useProvideQueries,\n  useProvideRelationships,\n  useProvideStore,\n  useProvideSynchronizer,\n  useQueries,\n  useQueriesIds,\n  useQueriesOrQueriesById,\n  useQueryIds,\n  useRedoInformation,\n  useRelationshipIds,\n  useRelationships,\n  useRelationshipsIds,\n  useRelationshipsOrRelationshipsById,\n  useRemoteRowId,\n  useRemoteRowIdListener,\n  useResultCell,\n  useResultCellIds,\n  useResultCellIdsListener,\n  useResultCellListener,\n  useResultRow,\n  useResultRowCount,\n  useResultRowCountListener,\n  useResultRowIds,\n  useResultRowIdsListener,\n  useResultRowListener,\n  useResultSortedRowIds,\n  useResultSortedRowIdsListener,\n  useResultTable,\n  useResultTableCellIds,\n  useResultTableCellIdsListener,\n  useResultTableListener,\n  useRow,\n  useRowCount,\n  useRowCountListener,\n  useRowIds,\n  useRowIdsListener,\n  useRowListener,\n  useSetCellCallback,\n  useSetCheckpointCallback,\n  useSetPartialRowCallback,\n  useSetPartialValuesCallback,\n  useSetRowCallback,\n  useSetTableCallback,\n  useSetTablesCallback,\n  useSetValueCallback,\n  useSetValuesCallback,\n  useSliceIds,\n  useSliceIdsListener,\n  useSliceRowIds,\n  useSliceRowIdsListener,\n  useSortedRowIds,\n  useSortedRowIdsListener,\n  useStartTransactionListener,\n  useStore,\n  useStoreIds,\n  useStoreOrStoreById,\n  useStores,\n  useSynchronizer,\n  useSynchronizerIds,\n  useSynchronizerOrSynchronizerById,\n  useSynchronizerStatus,\n  useSynchronizerStatusListener,\n  useTable,\n  useTableCellIds,\n  useTableCellIdsListener,\n  useTableIds,\n  useTableIdsListener,\n  useTableListener,\n  useTables,\n  useTablesListener,\n  useUndoInformation,\n  useValue,\n  useValueIds,\n  useValueIdsListener,\n  useValueListener,\n  useValues,\n  useValuesListener,\n  useWillFinishTransactionListener,\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4010, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4015, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/router-reducer/reducers/get-segment-value.ts"],"sourcesContent":["import type { Segment } from '../../../../server/app-render/types'\n\nexport function getSegmentValue(segment: Segment) {\n  return Array.isArray(segment) ? segment[1] : segment\n}\n"],"names":["getSegmentValue","segment","Array","isArray"],"mappings":";;;;+BAEgBA,mBAAAA;;;eAAAA;;;AAAT,SAASA,gBAAgBC,OAAgB;IAC9C,OAAOC,MAAMC,OAAO,CAACF,WAAWA,OAAO,CAAC,EAAE,GAAGA;AAC/C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4035, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4040, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/shared/lib/segment.ts"],"sourcesContent":["import type { Segment } from '../../server/app-render/types'\n\nexport function isGroupSegment(segment: string) {\n  // Use array[0] for performant purpose\n  return segment[0] === '(' && segment.endsWith(')')\n}\n\nexport function isParallelRouteSegment(segment: string) {\n  return segment.startsWith('@') && segment !== '@children'\n}\n\nexport function addSearchParamsIfPageSegment(\n  segment: Segment,\n  searchParams: Record<string, string | string[] | undefined>\n) {\n  const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)\n\n  if (isPageSegment) {\n    const stringifiedQuery = JSON.stringify(searchParams)\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n\nexport const PAGE_SEGMENT_KEY = '__PAGE__'\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__'\n"],"names":["DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","addSearchParamsIfPageSegment","isGroupSegment","isParallelRouteSegment","segment","endsWith","startsWith","searchParams","isPageSegment","includes","stringifiedQuery","JSON","stringify"],"mappings":";;;;;;;;;;;;;;;;;;IA4BaA,mBAAmB,EAAA;eAAnBA;;IADAC,gBAAgB,EAAA;eAAhBA;;IAhBGC,4BAA4B,EAAA;eAA5BA;;IATAC,cAAc,EAAA;eAAdA;;IAKAC,sBAAsB,EAAA;eAAtBA;;;AALT,SAASD,eAAeE,OAAe;IAC5C,sCAAsC;IACtC,OAAOA,OAAO,CAAC,EAAE,KAAK,OAAOA,QAAQC,QAAQ,CAAC;AAChD;AAEO,SAASF,uBAAuBC,OAAe;IACpD,OAAOA,QAAQE,UAAU,CAAC,QAAQF,YAAY;AAChD;AAEO,SAASH,6BACdG,OAAgB,EAChBG,YAA2D;IAE3D,MAAMC,gBAAgBJ,QAAQK,QAAQ,CAACT;IAEvC,IAAIQ,eAAe;QACjB,MAAME,mBAAmBC,KAAKC,SAAS,CAACL;QACxC,OAAOG,qBAAqB,OACxBV,mBAAmB,MAAMU,mBACzBV;IACN;IAEA,OAAOI;AACT;AAEO,MAAMJ,mBAAmB;AACzB,MAAMD,sBAAsB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4091, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4096, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/redirect.ts"],"sourcesContent":["import { actionAsyncStorage } from '../../server/app-render/action-async-storage.external'\nimport { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  const actionStore = actionAsyncStorage.getStore()\n  const redirectType =\n    type || (actionStore?.isAction ? RedirectType.push : RedirectType.replace)\n  throw getRedirectError(\n    url,\n    redirectType,\n    RedirectStatusCode.TemporaryRedirect\n  )\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n"],"names":["getRedirectError","getRedirectStatusCodeFromError","getRedirectTypeFromError","getURLFromRedirectError","permanentRedirect","redirect","url","type","statusCode","RedirectStatusCode","TemporaryRedirect","error","Error","REDIRECT_ERROR_CODE","digest","actionStore","actionAsyncStorage","getStore","redirectType","isAction","RedirectType","push","replace","PermanentRedirect","isRedirectError","split","slice","join","Number","at"],"mappings":";;;;;;;;;;;;;;;;;;;IASgBA,gBAAgB,EAAA;eAAhBA;;IAgFAC,8BAA8B,EAAA;eAA9BA;;IARAC,wBAAwB,EAAA;eAAxBA;;IARAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,iBAAiB,EAAA;eAAjBA;;IA1BAC,QAAQ,EAAA;eAARA;;;4CA/BmB;oCACA;+BAM5B;AAEA,SAASL,iBACdM,GAAW,EACXC,IAAkB,EAClBC,UAAqE;IAArEA,IAAAA,eAAAA,KAAAA,GAAAA,aAAiCC,oBAAAA,kBAAkB,CAACC,iBAAiB;IAErE,MAAMC,QAAQ,OAAA,cAA8B,CAA9B,IAAIC,MAAMC,eAAAA,mBAAmB,GAA7B,qBAAA;eAAA;oBAAA;sBAAA;IAA6B;IAC3CF,MAAMG,MAAM,GAAMD,eAAAA,mBAAmB,GAAC,MAAGN,OAAK,MAAGD,MAAI,MAAGE,aAAW;IACnE,OAAOG;AACT;AAcO,SAASN,SACd,2BAA2B,GAC3BC,GAAW,EACXC,IAAmB;IAEnB,MAAMQ,cAAcC,4BAAAA,kBAAkB,CAACC,QAAQ;IAC/C,MAAMC,eACJX,QAASQ,CAAAA,CAAAA,eAAAA,OAAAA,KAAAA,IAAAA,YAAaI,QAAQ,IAAGC,eAAAA,YAAY,CAACC,IAAI,GAAGD,eAAAA,YAAY,CAACE,OAAM;IAC1E,MAAMtB,iBACJM,KACAY,cACAT,oBAAAA,kBAAkB,CAACC,iBAAiB;AAExC;AAaO,SAASN,kBACd,2BAA2B,GAC3BE,GAAW,EACXC,IAAyC;IAAzCA,IAAAA,SAAAA,KAAAA,GAAAA,OAAqBa,eAAAA,YAAY,CAACE,OAAO;IAEzC,MAAMtB,iBAAiBM,KAAKC,MAAME,oBAAAA,kBAAkB,CAACc,iBAAiB;AACxE;AAUO,SAASpB,wBAAwBQ,KAAc;IACpD,IAAI,CAACa,CAAAA,GAAAA,eAAAA,eAAe,EAACb,QAAQ,OAAO;IAEpC,wEAAwE;IACxE,kBAAkB;IAClB,OAAOA,MAAMG,MAAM,CAACW,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;AACnD;AAEO,SAASzB,yBAAyBS,KAAoB;IAC3D,IAAI,CAACa,CAAAA,GAAAA,eAAAA,eAAe,EAACb,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOD,MAAMG,MAAM,CAACW,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;AACtC;AAEO,SAASxB,+BAA+BU,KAAoB;IACjE,IAAI,CAACa,CAAAA,GAAAA,eAAAA,eAAe,EAACb,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOgB,OAAOjB,MAAMG,MAAM,CAACW,KAAK,CAAC,KAAKI,EAAE,CAAC,CAAC;AAC5C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4189, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4194, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/not-found.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n"],"names":["notFound","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","error","Error","digest"],"mappings":";;;;+BAsBgBA,YAAAA;;;eAAAA;;;oCAnBT;AAEP;;;;;;;;;;;;;CAaC,GAED,MAAMC,SAAU,KAAEC,oBAAAA,8BAA8B,GAAC;AAE1C,SAASF;IACd,4CAA4C;IAC5C,MAAMG,QAAQ,OAAA,cAAiB,CAAjB,IAAIC,MAAMH,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BE,MAAkCE,MAAM,GAAGJ;IAE7C,MAAME;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4236, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4241, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/forbidden.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["forbidden","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":";;;;+BAqBgBA,aAAAA;;;eAAAA;;;oCAlBT;AAEP,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAED,MAAMC,SAAU,KAAEC,oBAAAA,8BAA8B,GAAC;AAE1C,SAASF;IACd,IAAI,CAACG,QAAQC,GAAG,CAACC,uBAAqC,YAAF;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACP,gHADG,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,4CAA4C;IAC5C,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4289, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4294, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/unauthorized.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["unauthorized","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":";;;;+BAsBgBA,gBAAAA;;;eAAAA;;;oCAnBT;AAEP,gCAAgC;AAChC;;;;;;;;;;;;CAYC,GAED,MAAMC,SAAU,KAAEC,oBAAAA,8BAA8B,GAAC;AAE1C,SAASF;IACd,IAAI,CAACG,QAAQC,GAAG,CAACC,uBAAqC,YAAF;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACP,gHADG,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,4CAA4C;IAC5C,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4343, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4348, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/hooks-server-context.ts"],"sourcesContent":["const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n"],"names":["DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","Error","constructor","description","digest","err"],"mappings":";;;;;;;;;;;;;;;IAEaA,kBAAkB,EAAA;eAAlBA;;IAQGC,oBAAoB,EAAA;eAApBA;;;AAVhB,MAAMC,qBAAqB;AAEpB,MAAMF,2BAA2BG;IAGtCC,YAA4BC,WAAmB,CAAE;QAC/C,KAAK,CAAE,2BAAwBA,cAAAA,IAAAA,CADLA,WAAAA,GAAAA,aAAAA,IAAAA,CAF5BC,MAAAA,GAAoCJ;IAIpC;AACF;AAEO,SAASD,qBAAqBM,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAID,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOC,IAAID,MAAM,KAAKJ;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4389, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4394, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts"],"sourcesContent":["// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n"],"names":["BailoutToCSRError","isBailoutToCSRError","BAILOUT_TO_CSR","Error","constructor","reason","digest","err"],"mappings":"AAAA,+GAA+G;;;;;;;;;;;;;;;;IAIlGA,iBAAiB,EAAA;eAAjBA;;IASGC,mBAAmB,EAAA;eAAnBA;;;AAZhB,MAAMC,iBAAiB;AAGhB,MAAMF,0BAA0BG;IAGrCC,YAA4BC,MAAc,CAAE;QAC1C,KAAK,CAAE,wCAAqCA,SAAAA,IAAAA,CADlBA,MAAAA,GAAAA,QAAAA,IAAAA,CAFZC,MAAAA,GAASJ;IAIzB;AACF;AAGO,SAASD,oBAAoBM,GAAY;IAC9C,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAID,MAAM,KAAKJ;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4429, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4434, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/static-generation-bailout.ts"],"sourcesContent":["const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n"],"names":["StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","Error","code","error"],"mappings":";;;;;;;;;;;;;;;IAEaA,qBAAqB,EAAA;eAArBA;;IAIGC,uBAAuB,EAAA;eAAvBA;;;AANhB,MAAMC,0BAA0B;AAEzB,MAAMF,8BAA8BG;;QAApC,KAAA,IAAA,OAAA,IAAA,CACWC,IAAAA,GAAOF;;AACzB;AAEO,SAASD,wBACdI,KAAc;IAEd,IAAI,OAAOA,UAAU,YAAYA,UAAU,QAAQ,CAAE,CAAA,UAAUA,KAAI,GAAI;QACrE,OAAO;IACT;IAEA,OAAOA,MAAMD,IAAI,KAAKF;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4475, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4480, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/server/dynamic-rendering-utils.ts"],"sourcesContent":["export function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(public readonly expression: string) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context.`\n    )\n  }\n}\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  expression: string\n): Promise<T> {\n  const hangingPromise = new Promise<T>((_, reject) => {\n    signal.addEventListener(\n      'abort',\n      () => {\n        reject(new HangingPromiseRejectionError(expression))\n      },\n      { once: true }\n    )\n  })\n  // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n  // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n  // your own promise out of it you'll need to ensure you handle the error when it rejects.\n  hangingPromise.catch(ignoreReject)\n  return hangingPromise\n}\n\nfunction ignoreReject() {}\n"],"names":["isHangingPromiseRejectionError","makeHangingPromise","err","digest","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","Error","constructor","expression","signal","hangingPromise","Promise","_","reject","addEventListener","once","catch","ignoreReject"],"mappings":";;;;;;;;;;;;;;;IAAgBA,8BAA8B,EAAA;eAA9BA;;IA6BAC,kBAAkB,EAAA;eAAlBA;;;AA7BT,SAASD,+BACdE,GAAY;IAEZ,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAIC,MAAM,KAAKC;AACxB;AAEA,MAAMA,4BAA4B;AAElC,MAAMC,qCAAqCC;IAGzCC,YAA4BC,UAAkB,CAAE;QAC9C,KAAK,CACH,CAAC,qBAAqB,EAAEA,WAAW,qGAAqG,EAAEA,WAAW,qJAAqJ,CAAC,GAAA,IAAA,CAFnRA,UAAAA,GAAAA,YAAAA,IAAAA,CAFZL,MAAAA,GAASC;IAMzB;AACF;AASO,SAASH,mBACdQ,MAAmB,EACnBD,UAAkB;IAElB,MAAME,iBAAiB,IAAIC,QAAW,CAACC,GAAGC;QACxCJ,OAAOK,gBAAgB,CACrB,SACA;YACED,OAAO,IAAIR,6BAA6BG;QAC1C,GACA;YAAEO,MAAM;QAAK;IAEjB;IACA,2GAA2G;IAC3G,6GAA6G;IAC7G,yFAAyF;IACzFL,eAAeM,KAAK,CAACC;IACrB,OAAOP;AACT;AAEA,SAASO,gBAAgB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4529, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4534, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/lib/metadata/metadata-constants.tsx"],"sourcesContent":["export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\n"],"names":["METADATA_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME"],"mappings":";;;;;;;;;;;;;;;;IAAaA,sBAAsB,EAAA;eAAtBA;;IAEAC,oBAAoB,EAAA;eAApBA;;IADAC,sBAAsB,EAAA;eAAtBA;;;AADN,MAAMF,yBAAyB;AAC/B,MAAME,yBAAyB;AAC/B,MAAMD,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4563, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4568, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/lib/scheduler.ts"],"sourcesContent":["export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = <T = void>(cb: ScheduledFn<T>): void => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = <T = void>(cb: ScheduledFn<T>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n"],"names":["atLeastOneTask","scheduleImmediate","scheduleOnNextTick","waitAtLeastOneReactRenderTask","cb","Promise","resolve","then","process","env","NEXT_RUNTIME","setTimeout","nextTick","setImmediate","r"],"mappings":";;;;;;;;;;;;;;;;;IA4CgBA,cAAc,EAAA;eAAdA;;IAbHC,iBAAiB,EAAA;eAAjBA;;IAtBAC,kBAAkB,EAAA;eAAlBA;;IAgDGC,6BAA6B,EAAA;eAA7BA;;;AAhDT,MAAMD,qBAAqB,CAAWE;IAC3C,6EAA6E;IAC7E,4EAA4E;IAC5E,uCAAuC;IACvC,EAAE;IACF,kLAAkL;IAClL,EAAE;IACFC,QAAQC,OAAO,GAAGC,IAAI,CAAC;QACrB,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,MAAQ;;QAEzC,OAAO;YACLF,QAAQI,QAAQ,CAACR;QACnB;IACF;AACF;AAQO,MAAMH,oBAAoB,CAAWG;IAC1C,IAAII,QAAQC,GAAG,CAACC,YAAY,KAAK,MAAQ;;IAEzC,OAAO;QACLG,aAAaT;IACf;AACF;AAOO,SAASJ;IACd,OAAO,IAAIK,QAAc,CAACC,UAAYL,kBAAkBK;AAC1D;AAWO,SAASH;IACd,IAAIK,QAAQC,GAAG,CAACC,YAAY,KAAK,MAAQ;;IAEzC,OAAO;QACL,OAAO,IAAIL,QAAQ,CAACS,IAAMD,aAAaC;IACzC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4630, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4635, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n} from '../../lib/metadata/metadata-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicExpression: undefined | string\n  syncDynamicErrorWithStack: null | Error\n  // Dev only\n  syncDynamicLogged?: boolean\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspendedDynamic: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasSyncDynamicErrors: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicExpression: undefined,\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspendedDynamic: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasSyncDynamicErrors: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    if (workUnitStore.type === 'prerender-ppr') {\n      postponeWithTracking(\n        store.route,\n        expression,\n        workUnitStore.dynamicTracking\n      )\n    } else if (workUnitStore.type === 'prerender-legacy') {\n      workUnitStore.revalidate = 0\n\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    } else if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n/**\n * This function communicates that some dynamic path parameter was read. This\n * differs from the more general `trackDynamicDataAccessed` in that it is will\n * not error when `dynamic = \"error\"` is set.\n *\n * @param store The static generation store\n * @param expression The expression that was accessed dynamically\n */\nexport function trackFallbackParamAccessed(\n  store: WorkStore,\n  expression: string\n): void {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return\n\n  postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking)\n}\n\n/**\n * This function is meant to be used when prerendering without dynamicIO or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(\n  _store: WorkStore,\n  workUnitStore: void | WorkUnitStore\n) {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n    if (\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      workUnitStore.revalidate = 0\n    }\n    if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n// Despite it's name we don't actually abort unless we have a controller to call abort on\n// There are times when we let a prerender run long to discover caches where we want the semantics\n// of tracking dynamic access without terminating the prerender early\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicExpression = expression\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n  return abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of prerender mode\n  requestStore.prerenderPhase = false\n}\n\n/**\n * use this function when prerendering with dynamicIO. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in dynamicIO mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicExpression = expression\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      if (prerenderStore.validating === true) {\n        // We always log Request Access in dev at the point of calling the function\n        // So we mark the dynamic validation as not requiring it to be printed\n        dynamicTracking.syncDynamicLogged = true\n      }\n    }\n  }\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev =\n  trackSynchronousPlatformIOAccessInDev\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createPostponedAbortSignal(reason: string): AbortSignal {\n  assertPostpone()\n  const controller = new AbortController()\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    React.unstable_postpone(reason)\n  } catch (x: unknown) {\n    controller.abort(x)\n  }\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: PrerenderStoreModern\n): AbortSignal {\n  const controller = new AbortController()\n\n  if (workUnitStore.cacheSignal) {\n    // If we have a cacheSignal it means we're in a prospective render. If the input\n    // we're waiting on is coming from another cache, we do want to wait for it so that\n    // we can resolve this cache entry too.\n    workUnitStore.cacheSignal.inputReady().then(() => {\n      controller.abort()\n    })\n  } else {\n    // Otherwise we're in the final render and we should already have all our caches\n    // filled. We might still be waiting on some microtasks so we wait one tick before\n    // giving up. When we give up, we still want to render the content of this cache\n    // as deeply as we can so that we can suspend as deeply as possible in the tree\n    // or not at all if we don't end up waiting for the input.\n    scheduleOnNextTick(() => controller.abort())\n  }\n\n  return controller.signal\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  if (typeof window === 'undefined') {\n    const workStore = workAsyncStorage.getStore()\n\n    if (\n      workStore &&\n      workStore.isStaticGeneration &&\n      workStore.fallbackRouteParams &&\n      workStore.fallbackRouteParams.size > 0\n    ) {\n      // There are fallback route params, we should track these as dynamic\n      // accesses.\n      const workUnitStore = workUnitAsyncStorage.getStore()\n      if (workUnitStore) {\n        // We're prerendering with dynamicIO or PPR or both\n        if (workUnitStore.type === 'prerender') {\n          // We are in a prerender with dynamicIO semantics\n          // We are going to hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole\n          React.use(makeHangingPromise(workUnitStore.renderSignal, expression))\n        } else if (workUnitStore.type === 'prerender-ppr') {\n          // We're prerendering with PPR\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        } else if (workUnitStore.type === 'prerender-legacy') {\n          throwToInterruptStaticGeneration(expression, workStore, workUnitStore)\n        }\n      }\n    }\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  route: string,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    dynamicValidation.hasSuspendedDynamic = true\n    return\n  } else if (\n    serverDynamic.syncDynamicErrorWithStack ||\n    clientDynamic.syncDynamicErrorWithStack\n  ) {\n    dynamicValidation.hasSyncDynamicErrors = true\n    return\n  } else {\n    const message = `Route \"${route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n    const error = createErrorWithComponentStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nfunction createErrorWithComponentStack(\n  message: string,\n  componentStack: string\n) {\n  const error = new Error(message)\n  error.stack = 'Error: ' + message + componentStack\n  return error\n}\n\nexport function throwIfDisallowedDynamic(\n  route: string,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): void {\n  let syncError: null | Error\n  let syncExpression: undefined | string\n  let syncLogged: boolean\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    syncError = serverDynamic.syncDynamicErrorWithStack\n    syncExpression = serverDynamic.syncDynamicExpression!\n    syncLogged = serverDynamic.syncDynamicLogged === true\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    syncError = clientDynamic.syncDynamicErrorWithStack\n    syncExpression = clientDynamic.syncDynamicExpression!\n    syncLogged = clientDynamic.syncDynamicLogged === true\n  } else {\n    syncError = null\n    syncExpression = undefined\n    syncLogged = false\n  }\n\n  if (dynamicValidation.hasSyncDynamicErrors && syncError) {\n    if (!syncLogged) {\n      // In dev we already log errors about sync dynamic access. But during builds we need to ensure\n      // the offending sync error is logged before we exit the build\n      console.error(syncError)\n    }\n    // The actual error should have been logged when the sync access ocurred\n    throw new StaticGenBailoutError()\n  }\n\n  const dynamicErrors = dynamicValidation.dynamicErrors\n  if (dynamicErrors.length) {\n    for (let i = 0; i < dynamicErrors.length; i++) {\n      console.error(dynamicErrors[i])\n    }\n\n    throw new StaticGenBailoutError()\n  }\n\n  if (!dynamicValidation.hasSuspendedDynamic) {\n    if (dynamicValidation.hasDynamicMetadata) {\n      if (syncError) {\n        console.error(syncError)\n        throw new StaticGenBailoutError(\n          `Route \"${route}\" has a \\`generateMetadata\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`\n        )\n      }\n      throw new StaticGenBailoutError(\n        `Route \"${route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateMetadata\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`\n      )\n    } else if (dynamicValidation.hasDynamicViewport) {\n      if (syncError) {\n        console.error(syncError)\n        throw new StaticGenBailoutError(\n          `Route \"${route}\" has a \\`generateViewport\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`\n        )\n      }\n      throw new StaticGenBailoutError(\n        `Route \"${route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateViewport\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`\n      )\n    }\n  }\n}\n"],"names":["Postpone","abortAndThrowOnSynchronousRequestDataAccess","abortOnSynchronousPlatformIOAccess","accessedDynamicData","annotateDynamicAccess","consumeDynamicAccess","createDynamicTrackingState","createDynamicValidationState","createHangingInputAbortSignal","createPostponedAbortSignal","formatDynamicAPIAccesses","getFirstDynamicReason","isDynamicPostpone","isPrerenderInterruptedError","markCurrentScopeAsDynamic","postponeWithTracking","throwIfDisallowedDynamic","throwToInterruptStaticGeneration","trackAllowedDynamicAccess","trackDynamicDataInDynamicRender","trackFallbackParamAccessed","trackSynchronousPlatformIOAccessInDev","trackSynchronousRequestDataAccessInDev","useDynamicRouteParams","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","syncDynamicExpression","undefined","syncDynamicErrorWithStack","hasSuspendedDynamic","hasDynamicMetadata","hasDynamicViewport","hasSyncDynamicErrors","dynamicErrors","trackingState","expression","store","workUnitStore","type","forceDynamic","forceStatic","dynamicShouldError","StaticGenBailoutError","route","dynamicTracking","revalidate","err","DynamicServerError","dynamicUsageDescription","dynamicUsageStack","stack","process","env","NODE_ENV","usedDynamic","prerenderStore","workUnitAsyncStorage","getStore","_store","abortOnSynchronousDynamicDataAccess","reason","error","createPrerenderInterruptedError","controller","abort","push","Error","errorWithStack","requestStore","prerenderPhase","validating","syncDynamicLogged","assertPostpone","createPostponeReason","message","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","digest","length","serverDynamic","clientDynamic","filter","access","map","split","slice","line","join","AbortController","x","signal","cacheSignal","inputReady","then","scheduleOnNextTick","window","workStore","workAsyncStorage","isStaticGeneration","fallbackRouteParams","size","use","makeHangingPromise","renderSignal","hasSuspenseRegex","hasMetadataRegex","RegExp","METADATA_BOUNDARY_NAME","hasViewportRegex","VIEWPORT_BOUNDARY_NAME","hasOutletRegex","OUTLET_BOUNDARY_NAME","componentStack","dynamicValidation","test","createErrorWithComponentStack","syncError","syncExpression","syncLogged","console","i"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5176, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5181, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/export/helpers/is-dynamic-usage-error.ts"],"sourcesContent":["import { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from '../../client/components/is-next-router-error'\nimport { isDynamicPostpone } from '../../server/app-render/dynamic-rendering'\n\nexport const isDynamicUsageError = (err: unknown) =>\n  isDynamicServerError(err) ||\n  isBailoutToCSRError(err) ||\n  isNextRouterError(err) ||\n  isDynamicPostpone(err)\n"],"names":["isDynamicUsageError","err","isDynamicServerError","isBailoutToCSRError","isNextRouterError","isDynamicPostpone"],"mappings":";;;;+BAKaA,uBAAAA;;;eAAAA;;;oCALwB;8BACD;mCACF;kCACA;AAE3B,MAAMA,sBAAsB,CAACC,MAClCC,CAAAA,GAAAA,oBAAAA,oBAAoB,EAACD,QACrBE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,QACpBG,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACH,QAClBI,CAAAA,GAAAA,kBAAAA,iBAAiB,EAACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5196, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5201, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/server/lib/router-utils/is-postpone.ts"],"sourcesContent":["const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone')\n\nexport function isPostpone(error: any): boolean {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    error.$$typeof === REACT_POSTPONE_TYPE\n  )\n}\n"],"names":["isPostpone","REACT_POSTPONE_TYPE","Symbol","for","error","$$typeof"],"mappings":";;;;+BAEgBA,cAAAA;;;eAAAA;;;AAFhB,MAAMC,sBAA8BC,OAAOC,GAAG,CAAC;AAExC,SAASH,WAAWI,KAAU;IACnC,OACE,OAAOA,UAAU,YACjBA,UAAU,QACVA,MAAMC,QAAQ,KAAKJ;AAEvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5215, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5220, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/unstable-rethrow.ts"],"sourcesContent":["import { isDynamicUsageError } from '../../export/helpers/is-dynamic-usage-error'\nimport { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\n\n/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicUsageError(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","isDynamicUsageError","isPostpone","isHangingPromiseRejectionError","Error","cause"],"mappings":";;;;+BAagBA,oBAAAA;;;eAAAA;;;qCAboB;uCACW;4BACpB;8BACS;mCACF;AAS3B,SAASA,iBAAiBC,KAAc;IAC7C,IACEC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAClBE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,UACpBG,CAAAA,GAAAA,qBAAAA,mBAAmB,EAACH,UACpBI,CAAAA,GAAAA,YAAAA,UAAU,EAACJ,UACXK,CAAAA,GAAAA,uBAAAA,8BAA8B,EAACL,QAC/B;QACA,MAAMA;IACR;IAEA,IAAIA,iBAAiBM,SAAS,WAAWN,OAAO;QAC9CD,iBAAiBC,MAAMO,KAAK;IAC9B;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5250, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5255, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/navigation.react-server.ts"],"sourcesContent":["/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\nclass ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n"],"names":["ReadonlyURLSearchParams","RedirectType","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_rethrow","ReadonlyURLSearchParamsError","Error","constructor","URLSearchParams","append","delete","set","sort"],"mappings":"AAAA,cAAc,GAAA;;;;;;;;;;;;;;;;;;;;;IAkCLA,uBAAuB,EAAA;eAAvBA;;IALAC,YAAY,EAAA;eAAZA,eAAAA,YAAY;;IAEZC,SAAS,EAAA;eAATA,WAAAA,SAAS;;IADTC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAFEC,iBAAiB,EAAA;eAAjBA,UAAAA,iBAAiB;;IAA3BC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAIRC,YAAY,EAAA;eAAZA,cAAAA,YAAY;;IACZC,gBAAgB,EAAA;eAAhBA,iBAAAA,gBAAgB;;;0BALmB;+BACf;0BACJ;2BACC;8BACG;iCACI;AAhCjC,MAAMC,qCAAqCC;IACzCC,aAAc;QACZ,KAAK,CACH;IAEJ;AACF;AAEA,MAAMV,gCAAgCW;IACpC,wKAAwK,GACxKC,SAAS;QACP,MAAM,IAAIJ;IACZ;IACA,wKAAwK,GACxKK,SAAS;QACP,MAAM,IAAIL;IACZ;IACA,wKAAwK,GACxKM,MAAM;QACJ,MAAM,IAAIN;IACZ;IACA,wKAAwK,GACxKO,OAAO;QACL,MAAM,IAAIP;IACZ;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5333, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5338, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/bailout-to-client-rendering.ts"],"sourcesContent":["import { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { workAsyncStorage } from '../../server/app-render/work-async-storage.external'\n\nexport function bailoutToClientRendering(reason: string): void | never {\n  const workStore = workAsyncStorage.getStore()\n\n  if (workStore?.forceStatic) return\n\n  if (workStore?.isStaticGeneration) throw new BailoutToCSRError(reason)\n}\n"],"names":["bailoutToClientRendering","reason","workStore","workAsyncStorage","getStore","forceStatic","isStaticGeneration","BailoutToCSRError"],"mappings":";;;;+BAGgBA,4BAAAA;;;eAAAA;;;8BAHkB;0CACD;AAE1B,SAASA,yBAAyBC,MAAc;IACrD,MAAMC,YAAYC,0BAAAA,gBAAgB,CAACC,QAAQ;IAE3C,IAAIF,aAAAA,OAAAA,KAAAA,IAAAA,UAAWG,WAAW,EAAE;IAE5B,IAAIH,aAAAA,OAAAA,KAAAA,IAAAA,UAAWI,kBAAkB,EAAE,MAAM,OAAA,cAA6B,CAA7B,IAAIC,cAAAA,iBAAiB,CAACN,SAAtB,qBAAA;eAAA;oBAAA;sBAAA;IAA4B;AACvE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5366, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5371, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/src/client/components/navigation.ts"],"sourcesContent":["import type { FlightRouterState } from '../../server/app-render/types'\nimport type { Params } from '../../server/request/params'\n\nimport { useContext, useMemo } from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  type AppRouterInstance,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { getSegmentValue } from './router-reducer/reducers/get-segment-value'\nimport { PAGE_SEGMENT_KEY, DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'\nimport { ReadonlyURLSearchParams } from './navigation.react-server'\nimport { useDynamicRouteParams } from '../../server/app-render/dynamic-rendering'\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you *read* the current URL's search parameters.\n *\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useSearchParams } from 'next/navigation'\n *\n * export default function Page() {\n *   const searchParams = useSearchParams()\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\n *   // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\n */\n// Client components API\nexport function useSearchParams(): ReadonlyURLSearchParams {\n  const searchParams = useContext(SearchParamsContext)\n\n  // In the case where this is `null`, the compat types added in\n  // `next-env.d.ts` will add a new overload that changes the return type to\n  // include `null`.\n  const readonlySearchParams = useMemo(() => {\n    if (!searchParams) {\n      // When the router is not ready in pages, we won't have the search params\n      // available.\n      return null\n    }\n\n    return new ReadonlyURLSearchParams(searchParams)\n  }, [searchParams]) as ReadonlyURLSearchParams\n\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { bailoutToClientRendering } =\n      require('./bailout-to-client-rendering') as typeof import('./bailout-to-client-rendering')\n    // TODO-APP: handle dynamic = 'force-static' here and on the client\n    bailoutToClientRendering('useSearchParams()')\n  }\n\n  return readonlySearchParams\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the current URL's pathname.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { usePathname } from 'next/navigation'\n *\n * export default function Page() {\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\n *  // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\n */\n// Client components API\nexport function usePathname(): string {\n  useDynamicRouteParams('usePathname()')\n\n  // In the case where this is `null`, the compat types added in `next-env.d.ts`\n  // will add a new overload that changes the return type to include `null`.\n  return useContext(PathnameContext) as string\n}\n\n// Client components API\nexport {\n  ServerInsertedHTMLContext,\n  useServerInsertedHTML,\n} from '../../shared/lib/server-inserted-html.shared-runtime'\n\n/**\n *\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useRouter } from 'next/navigation'\n *\n * export default function Page() {\n *  const router = useRouter()\n *  // ...\n *  router.push('/dashboard') // Navigate to /dashboard\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\n */\n// Client components API\nexport function useRouter(): AppRouterInstance {\n  const router = useContext(AppRouterContext)\n  if (router === null) {\n    throw new Error('invariant expected app router to be mounted')\n  }\n\n  return router\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read a route's dynamic params filled in by the current URL.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useParams } from 'next/navigation'\n *\n * export default function Page() {\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\n *   const { team } = useParams() // team === \"nextjs\"\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\n */\n// Client components API\nexport function useParams<T extends Params = Params>(): T {\n  useDynamicRouteParams('useParams()')\n\n  return useContext(PathParamsContext) as T\n}\n\n/** Get the canonical parameters from the current level to the leaf node. */\n// Client components API\nfunction getSelectedLayoutSegmentPath(\n  tree: FlightRouterState,\n  parallelRouteKey: string,\n  first = true,\n  segmentPath: string[] = []\n): string[] {\n  let node: FlightRouterState\n  if (first) {\n    // Use the provided parallel route key on the first parallel route\n    node = tree[1][parallelRouteKey]\n  } else {\n    // After first parallel route prefer children, if there's no children pick the first parallel route.\n    const parallelRoutes = tree[1]\n    node = parallelRoutes.children ?? Object.values(parallelRoutes)[0]\n  }\n\n  if (!node) return segmentPath\n  const segment = node[0]\n\n  let segmentValue = getSegmentValue(segment)\n\n  if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {\n    return segmentPath\n  }\n\n  segmentPath.push(segmentValue)\n\n  return getSelectedLayoutSegmentPath(\n    node,\n    parallelRouteKey,\n    false,\n    segmentPath\n  )\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segments **below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n *\n * import { useSelectedLayoutSegments } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segments = useSelectedLayoutSegments()\n *\n *   return (\n *     <ul>\n *       {segments.map((segment, index) => (\n *         <li key={index}>{segment}</li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\n */\n// Client components API\nexport function useSelectedLayoutSegments(\n  parallelRouteKey: string = 'children'\n): string[] {\n  useDynamicRouteParams('useSelectedLayoutSegments()')\n\n  const context = useContext(LayoutRouterContext)\n  // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n  if (!context) return null\n\n  return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segment **one level below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n * import { useSelectedLayoutSegment } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segment = useSelectedLayoutSegment()\n *\n *   return <p>Active segment: {segment}</p>\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\n */\n// Client components API\nexport function useSelectedLayoutSegment(\n  parallelRouteKey: string = 'children'\n): string | null {\n  useDynamicRouteParams('useSelectedLayoutSegment()')\n\n  const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)\n\n  if (!selectedLayoutSegments || selectedLayoutSegments.length === 0) {\n    return null\n  }\n\n  const selectedLayoutSegment =\n    parallelRouteKey === 'children'\n      ? selectedLayoutSegments[0]\n      : selectedLayoutSegments[selectedLayoutSegments.length - 1]\n\n  // if the default slot is showing, we return null since it's not technically \"selected\" (it's a fallback)\n  // and returning an internal value like `__DEFAULT__` would be confusing.\n  return selectedLayoutSegment === DEFAULT_SEGMENT_KEY\n    ? null\n    : selectedLayoutSegment\n}\n\n// Shared components APIs\nexport {\n  notFound,\n  forbidden,\n  unauthorized,\n  redirect,\n  permanentRedirect,\n  RedirectType,\n  ReadonlyURLSearchParams,\n  unstable_rethrow,\n} from './navigation.react-server'\n"],"names":["ReadonlyURLSearchParams","RedirectType","ServerInsertedHTMLContext","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_rethrow","useParams","usePathname","useRouter","useSearchParams","useSelectedLayoutSegment","useSelectedLayoutSegments","useServerInsertedHTML","searchParams","useContext","SearchParamsContext","readonlySearchParams","useMemo","window","bailoutToClientRendering","require","useDynamicRouteParams","PathnameContext","router","AppRouterContext","Error","PathParamsContext","getSelectedLayoutSegmentPath","tree","parallelRouteKey","first","segmentPath","node","parallelRoutes","children","Object","values","segment","segmentValue","getSegmentValue","startsWith","PAGE_SEGMENT_KEY","push","context","LayoutRouterContext","parentTree","selectedLayoutSegments","length","selectedLayoutSegment","DEFAULT_SEGMENT_KEY"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5551, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5556, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/next%4015.2.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0/node_modules/next/navigation.js"],"sourcesContent":["module.exports = require('./dist/client/components/navigation')\n"],"names":[],"mappings":"AAAA,OAAO,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5557, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5563, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/tinybase%405.4.8_%40cloudflare%2Bworkers-types%404.20250224.0_prettier%403.5.2_react-dom%4019.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/synchronizers/synchronizer-ws-client/index.js"],"sourcesContent":["const EMPTY_STRING = '';\nconst UTF8 = 'utf8';\nconst OPEN = 'open';\nconst MESSAGE = 'message';\nconst ERROR = 'error';\nconst UNDEFINED = '\\uFFFC';\nconst strSplit = (str, separator = EMPTY_STRING, limit) =>\n  str.split(separator, limit);\n\nconst promise = Promise;\nconst GLOBAL = globalThis;\nconst THOUSAND = 1e3;\nconst startTimeout = (callback, sec = 0) =>\n  setTimeout(callback, sec * THOUSAND);\nconst math = Math;\nconst mathFloor = math.floor;\nconst isUndefined = (thing) => thing == void 0;\nconst ifNotUndefined = (value, then, otherwise) =>\n  isUndefined(value) ? otherwise?.() : then(value);\nconst isArray = (thing) => Array.isArray(thing);\nconst slice = (arrayOrString, start, end) => arrayOrString.slice(start, end);\nconst size = (arrayOrString) => arrayOrString.length;\nconst test = (regex, subject) => regex.test(subject);\nconst promiseNew = (resolver) => new promise(resolver);\nconst errorNew = (message) => {\n  throw new Error(message);\n};\n\nconst arrayForEach = (array, cb) => array.forEach(cb);\nconst arrayMap = (array, cb) => array.map(cb);\nconst arrayReduce = (array, cb, initial) => array.reduce(cb, initial);\nconst arrayClear = (array, to) => array.splice(0, to);\nconst arrayPush = (array, ...values) => array.push(...values);\nconst arrayShift = (array) => array.shift();\n\nconst object = Object;\nconst getPrototypeOf = (obj) => object.getPrototypeOf(obj);\nconst objEntries = object.entries;\nconst isObject = (obj) =>\n  !isUndefined(obj) &&\n  ifNotUndefined(\n    getPrototypeOf(obj),\n    (objPrototype) =>\n      objPrototype == object.prototype ||\n      isUndefined(getPrototypeOf(objPrototype)),\n\n    /* istanbul ignore next */\n    () => true,\n  );\nconst objIds = object.keys;\nconst objFreeze = object.freeze;\nconst objNew = (entries = []) => object.fromEntries(entries);\nconst objHas = (obj, id) => id in obj;\nconst objForEach = (obj, cb) =>\n  arrayForEach(objEntries(obj), ([id, value]) => cb(value, id));\nconst objSize = (obj) => size(objIds(obj));\nconst objIsEmpty = (obj) => isObject(obj) && objSize(obj) == 0;\nconst objEnsure = (obj, id, getDefaultValue) => {\n  if (!objHas(obj, id)) {\n    obj[id] = getDefaultValue();\n  }\n  return obj[id];\n};\n\nconst jsonString = JSON.stringify;\nconst jsonParse = JSON.parse;\nconst jsonStringWithUndefined = (obj) =>\n  jsonString(obj, (_key, value) => (value === void 0 ? UNDEFINED : value));\nconst jsonParseWithUndefined = (str) =>\n  jsonParse(str, (_key, value) => (value === UNDEFINED ? void 0 : value));\n\nconst MESSAGE_SEPARATOR = '\\n';\nconst ifPayloadValid = (payload, then) => {\n  const splitAt = payload.indexOf(MESSAGE_SEPARATOR);\n  if (splitAt !== -1) {\n    then(slice(payload, 0, splitAt), slice(payload, splitAt + 1));\n  }\n};\nconst receivePayload = (payload, receive) =>\n  ifPayloadValid(payload, (fromClientId, remainder) =>\n    receive(fromClientId, ...jsonParseWithUndefined(remainder)),\n  );\nconst createPayload = (toClientId, ...args) =>\n  createRawPayload(toClientId ?? EMPTY_STRING, jsonStringWithUndefined(args));\nconst createRawPayload = (clientId, remainder) =>\n  clientId + MESSAGE_SEPARATOR + remainder;\n\nconst collSize = (coll) => coll?.size ?? 0;\nconst collHas = (coll, keyOrValue) => coll?.has(keyOrValue) ?? false;\nconst collIsEmpty = (coll) => isUndefined(coll) || collSize(coll) == 0;\nconst collForEach = (coll, cb) => coll?.forEach(cb);\nconst collDel = (coll, keyOrValue) => coll?.delete(keyOrValue);\n\nconst mapNew = (entries) => new Map(entries);\nconst mapGet = (map, key) => map?.get(key);\nconst mapSet = (map, key, value) =>\n  isUndefined(value) ? (collDel(map, key), map) : map?.set(key, value);\nconst mapEnsure = (map, key, getDefaultValue, hadExistingValue) => {\n  if (!collHas(map, key)) {\n    mapSet(map, key, getDefaultValue());\n  } else {\n    hadExistingValue?.(mapGet(map, key));\n  }\n  return mapGet(map, key);\n};\nconst visitTree = (node, path, ensureLeaf, pruneLeaf, p = 0) =>\n  ifNotUndefined(\n    (ensureLeaf ? mapEnsure : mapGet)(\n      node,\n      path[p],\n      p > size(path) - 2 ? ensureLeaf : mapNew,\n    ),\n    (nodeOrLeaf) => {\n      if (p > size(path) - 2) {\n        if (pruneLeaf?.(nodeOrLeaf)) {\n          mapSet(node, path[p]);\n        }\n        return nodeOrLeaf;\n      }\n      const leaf = visitTree(nodeOrLeaf, path, ensureLeaf, pruneLeaf, p + 1);\n      if (collIsEmpty(nodeOrLeaf)) {\n        mapSet(node, path[p]);\n      }\n      return leaf;\n    },\n  );\n\nconst stampNew = (value, time) => (time ? [value, time] : [value]);\nconst getLatestTime = (time1, time2) =>\n  /* istanbul ignore next */\n  ((time1 ?? '') > (time2 ?? '') ? time1 : time2) ?? '';\nconst stampNewObj = (time = EMPTY_STRING) => stampNew(objNew(), time);\n\nconst setNew = (entryOrEntries) =>\n  new Set(\n    isArray(entryOrEntries) || isUndefined(entryOrEntries)\n      ? entryOrEntries\n      : [entryOrEntries],\n  );\nconst setAdd = (set, value) => set?.add(value);\n\nconst INTEGER = /^\\d+$/;\nconst getPoolFunctions = () => {\n  const pool = [];\n  let nextId = 0;\n  return [\n    (reuse) => (reuse ? arrayShift(pool) : null) ?? EMPTY_STRING + nextId++,\n    (id) => {\n      if (test(INTEGER, id) && size(pool) < 1e3) {\n        arrayPush(pool, id);\n      }\n    },\n  ];\n};\n\nconst getWildcardedLeaves = (deepIdSet, path = [EMPTY_STRING]) => {\n  const leaves = [];\n  const deep = (node, p) =>\n    p == size(path)\n      ? arrayPush(leaves, node)\n      : path[p] === null\n        ? collForEach(node, (node2) => deep(node2, p + 1))\n        : arrayForEach([path[p], null], (id) => deep(mapGet(node, id), p + 1));\n  deep(deepIdSet, 0);\n  return leaves;\n};\nconst getListenerFunctions = (getThing) => {\n  let thing;\n  const [getId, releaseId] = getPoolFunctions();\n  const allListeners = mapNew();\n  const addListener = (\n    listener,\n    idSetNode,\n    path,\n    pathGetters = [],\n    extraArgsGetter = () => [],\n  ) => {\n    thing ??= getThing();\n    const id = getId(1);\n    mapSet(allListeners, id, [\n      listener,\n      idSetNode,\n      path,\n      pathGetters,\n      extraArgsGetter,\n    ]);\n    setAdd(visitTree(idSetNode, path ?? [EMPTY_STRING], setNew), id);\n    return id;\n  };\n  const callListeners = (idSetNode, ids, ...extraArgs) =>\n    arrayForEach(getWildcardedLeaves(idSetNode, ids), (set) =>\n      collForEach(set, (id) =>\n        mapGet(allListeners, id)[0](thing, ...(ids ?? []), ...extraArgs),\n      ),\n    );\n  const delListener = (id) =>\n    ifNotUndefined(mapGet(allListeners, id), ([, idSetNode, idOrNulls]) => {\n      visitTree(idSetNode, idOrNulls ?? [EMPTY_STRING], void 0, (idSet) => {\n        collDel(idSet, id);\n        return collIsEmpty(idSet) ? 1 : 0;\n      });\n      mapSet(allListeners, id);\n      releaseId(id);\n      return idOrNulls;\n    });\n  const callListener = (id) =>\n    ifNotUndefined(\n      mapGet(allListeners, id),\n      ([listener, , path = [], pathGetters, extraArgsGetter]) => {\n        const callWithIds = (...ids) => {\n          const index = size(ids);\n          if (index == size(path)) {\n            listener(thing, ...ids, ...extraArgsGetter(ids));\n          } else if (isUndefined(path[index])) {\n            arrayForEach(pathGetters[index]?.(...ids) ?? [], (id2) =>\n              callWithIds(...ids, id2),\n            );\n          } else {\n            callWithIds(...ids, path[index]);\n          }\n        };\n        callWithIds();\n      },\n    );\n  return [addListener, callListeners, delListener, callListener];\n};\n\nconst scheduleRunning = mapNew();\nconst scheduleActions = mapNew();\nconst getStoreFunctions = (\n  persist = 1 /* StoreOnly */,\n  store,\n  isSynchronizer,\n) =>\n  persist != 1 /* StoreOnly */ && store.isMergeable()\n    ? [\n        1,\n        store.getMergeableContent,\n        () => store.getTransactionMergeableChanges(!isSynchronizer),\n        ([[changedTables], [changedValues]]) =>\n          !objIsEmpty(changedTables) || !objIsEmpty(changedValues),\n        store.setDefaultContent,\n      ]\n    : persist != 2 /* MergeableStoreOnly */\n      ? [\n          0,\n          store.getContent,\n          store.getTransactionChanges,\n          ([changedTables, changedValues]) =>\n            !objIsEmpty(changedTables) || !objIsEmpty(changedValues),\n          store.setContent,\n        ]\n      : errorNew('Store type not supported by this Persister');\nconst createCustomPersister = (\n  store,\n  getPersisted,\n  setPersisted,\n  addPersisterListener,\n  delPersisterListener,\n  onIgnoredError,\n  persist,\n  extra = {},\n  isSynchronizer = 0,\n  scheduleId = [],\n) => {\n  let status = 0; /* Idle */\n  let loads = 0;\n  let saves = 0;\n  let action;\n  let autoLoadHandle;\n  let autoSaveListenerId;\n  mapEnsure(scheduleRunning, scheduleId, () => 0);\n  mapEnsure(scheduleActions, scheduleId, () => []);\n  const statusListeners = mapNew();\n  const [\n    isMergeableStore,\n    getContent,\n    getChanges,\n    hasChanges,\n    setDefaultContent,\n  ] = getStoreFunctions(persist, store, isSynchronizer);\n  const [addListener, callListeners, delListenerImpl] = getListenerFunctions(\n    () => persister,\n  );\n  const setStatus = (newStatus) => {\n    if (newStatus != status) {\n      status = newStatus;\n      callListeners(statusListeners, void 0, status);\n    }\n  };\n  const run = async () => {\n    /* istanbul ignore else */\n    if (!mapGet(scheduleRunning, scheduleId)) {\n      mapSet(scheduleRunning, scheduleId, 1);\n      while (\n        !isUndefined((action = arrayShift(mapGet(scheduleActions, scheduleId))))\n      ) {\n        try {\n          await action();\n        } catch (error) {\n          /* istanbul ignore next */\n          onIgnoredError?.(error);\n        }\n      }\n      mapSet(scheduleRunning, scheduleId, 0);\n    }\n  };\n  const setContentOrChanges = (contentOrChanges) => {\n    (isMergeableStore && isArray(contentOrChanges?.[0])\n      ? contentOrChanges?.[2] === 1\n        ? store.applyMergeableChanges\n        : store.setMergeableContent\n      : contentOrChanges?.[2] === 1\n        ? store.applyChanges\n        : store.setContent)(contentOrChanges);\n  };\n  const load = async (initialContent) => {\n    /* istanbul ignore else */\n    if (status != 2 /* Saving */) {\n      setStatus(1 /* Loading */);\n      loads++;\n      await schedule(async () => {\n        try {\n          const content = await getPersisted();\n          if (isArray(content)) {\n            setContentOrChanges(content);\n          } else if (initialContent) {\n            setDefaultContent(initialContent);\n          } else {\n            errorNew(`Content is not an array: ${content}`);\n          }\n        } catch (error) {\n          onIgnoredError?.(error);\n          if (initialContent) {\n            setDefaultContent(initialContent);\n          }\n        }\n        setStatus(0 /* Idle */);\n      });\n    }\n    return persister;\n  };\n  const startAutoLoad = async (initialContent) => {\n    stopAutoLoad();\n    await load(initialContent);\n    try {\n      autoLoadHandle = await addPersisterListener(async (content, changes) => {\n        if (changes || content) {\n          /* istanbul ignore else */\n          if (status != 2 /* Saving */) {\n            setStatus(1 /* Loading */);\n            loads++;\n            setContentOrChanges(changes ?? content);\n            setStatus(0 /* Idle */);\n          }\n        } else {\n          await load();\n        }\n      });\n    } catch (error) {\n      /* istanbul ignore next */\n      onIgnoredError?.(error);\n    }\n    return persister;\n  };\n  const stopAutoLoad = () => {\n    if (autoLoadHandle) {\n      delPersisterListener(autoLoadHandle);\n      autoLoadHandle = void 0;\n    }\n    return persister;\n  };\n  const isAutoLoading = () => !isUndefined(autoLoadHandle);\n  const save = async (changes) => {\n    /* istanbul ignore else */\n    if (status != 1 /* Loading */) {\n      setStatus(2 /* Saving */);\n      saves++;\n      await schedule(async () => {\n        try {\n          await setPersisted(getContent, changes);\n        } catch (error) {\n          /* istanbul ignore next */\n          onIgnoredError?.(error);\n        }\n        setStatus(0 /* Idle */);\n      });\n    }\n    return persister;\n  };\n  const startAutoSave = async () => {\n    stopAutoSave();\n    await save();\n    autoSaveListenerId = store.addDidFinishTransactionListener(() => {\n      const changes = getChanges();\n      if (hasChanges(changes)) {\n        save(changes);\n      }\n    });\n    return persister;\n  };\n  const stopAutoSave = () => {\n    if (autoSaveListenerId) {\n      store.delListener(autoSaveListenerId);\n      autoSaveListenerId = void 0;\n    }\n    return persister;\n  };\n  const isAutoSaving = () => !isUndefined(autoSaveListenerId);\n  const getStatus = () => status;\n  const addStatusListener = (listener) =>\n    addListener(listener, statusListeners);\n  const delListener = (listenerId) => {\n    delListenerImpl(listenerId);\n    return store;\n  };\n  const schedule = async (...actions) => {\n    arrayPush(mapGet(scheduleActions, scheduleId), ...actions);\n    await run();\n    return persister;\n  };\n  const getStore = () => store;\n  const destroy = () => {\n    arrayClear(mapGet(scheduleActions, scheduleId));\n    return stopAutoLoad().stopAutoSave();\n  };\n  const getStats = () => ({loads, saves});\n  const persister = {\n    load,\n    startAutoLoad,\n    stopAutoLoad,\n    isAutoLoading,\n    save,\n    startAutoSave,\n    stopAutoSave,\n    isAutoSaving,\n    getStatus,\n    addStatusListener,\n    delListener,\n    schedule,\n    getStore,\n    destroy,\n    getStats,\n    ...extra,\n  };\n  return objFreeze(persister);\n};\n\nconst MASK6 = 63;\nconst ENCODE = /* @__PURE__ */ strSplit(\n  '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz',\n);\nconst encode = (num) => ENCODE[num & MASK6];\n\nconst getRandomValues = GLOBAL.crypto\n  ? (array) => GLOBAL.crypto.getRandomValues(array)\n  : /* istanbul ignore next */\n    (array) => arrayMap(array, () => mathFloor(math.random() * 256));\nconst getUniqueId = (length = 16) =>\n  arrayReduce(\n    getRandomValues(new Uint8Array(length)),\n    (uniqueId, number) => uniqueId + encode(number),\n    '',\n  );\n\nconst createCustomSynchronizer = (\n  store,\n  send,\n  registerReceive,\n  destroyImpl,\n  requestTimeoutSeconds,\n  onSend,\n  onReceive,\n  onIgnoredError,\n  extra = {},\n) => {\n  let syncing = 0;\n  let persisterListener;\n  let sends = 0;\n  let receives = 0;\n  const pendingRequests = mapNew();\n  const getTransactionId = () => getUniqueId(11);\n  const sendImpl = (toClientId, requestId, message, body) => {\n    sends++;\n    onSend?.(toClientId, requestId, message, body);\n    send(toClientId, requestId, message, body);\n  };\n  const request = async (toClientId, message, body, transactionId) =>\n    promiseNew((resolve, reject) => {\n      const requestId = transactionId + '.' + getUniqueId(4);\n      const timeout = startTimeout(() => {\n        collDel(pendingRequests, requestId);\n        reject(\n          `No response from ${toClientId ?? 'anyone'} to ${requestId}, ` +\n            message,\n        );\n      }, requestTimeoutSeconds);\n      mapSet(pendingRequests, requestId, [\n        toClientId,\n        (response, fromClientId) => {\n          clearTimeout(timeout);\n          collDel(pendingRequests, requestId);\n          resolve([response, fromClientId, transactionId]);\n        },\n      ]);\n      sendImpl(toClientId, requestId, message, body);\n    });\n  const mergeTablesStamps = (tablesStamp, [tableStamps2, tablesTime2]) => {\n    objForEach(tableStamps2, ([rowStamps2, tableTime2], tableId) => {\n      const tableStamp = objEnsure(tablesStamp[0], tableId, stampNewObj);\n      objForEach(rowStamps2, ([cellStamps2, rowTime2], rowId) => {\n        const rowStamp = objEnsure(tableStamp[0], rowId, stampNewObj);\n        objForEach(\n          cellStamps2,\n          ([cell2, cellTime2], cellId) =>\n            (rowStamp[0][cellId] = stampNew(cell2, cellTime2)),\n        );\n        rowStamp[1] = getLatestTime(rowStamp[1], rowTime2);\n      });\n      tableStamp[1] = getLatestTime(tableStamp[1], tableTime2);\n    });\n    tablesStamp[1] = getLatestTime(tablesStamp[1], tablesTime2);\n  };\n  const getChangesFromOtherStore = async (\n    otherClientId = null,\n    otherContentHashes,\n    transactionId = getTransactionId(),\n  ) => {\n    try {\n      if (isUndefined(otherContentHashes)) {\n        [otherContentHashes, otherClientId, transactionId] = await request(\n          null,\n          1 /* GetContentHashes */,\n          EMPTY_STRING,\n          transactionId,\n        );\n      }\n      const [otherTablesHash, otherValuesHash] = otherContentHashes;\n      const [tablesHash, valuesHash] = store.getMergeableContentHashes();\n      let tablesChanges = stampNewObj();\n      if (tablesHash != otherTablesHash) {\n        const [newTables, differentTableHashes] = (\n          await request(\n            otherClientId,\n            4 /* GetTableDiff */,\n            store.getMergeableTableHashes(),\n            transactionId,\n          )\n        )[0];\n        tablesChanges = newTables;\n        if (!objIsEmpty(differentTableHashes)) {\n          const [newRows, differentRowHashes] = (\n            await request(\n              otherClientId,\n              5 /* GetRowDiff */,\n              store.getMergeableRowHashes(differentTableHashes),\n              transactionId,\n            )\n          )[0];\n          mergeTablesStamps(tablesChanges, newRows);\n          if (!objIsEmpty(differentRowHashes)) {\n            const newCells = (\n              await request(\n                otherClientId,\n                6 /* GetCellDiff */,\n                store.getMergeableCellHashes(differentRowHashes),\n                transactionId,\n              )\n            )[0];\n            mergeTablesStamps(tablesChanges, newCells);\n          }\n        }\n      }\n      return [\n        tablesChanges,\n        valuesHash == otherValuesHash\n          ? stampNewObj()\n          : (\n              await request(\n                otherClientId,\n                7 /* GetValueDiff */,\n                store.getMergeableValueHashes(),\n                transactionId,\n              )\n            )[0],\n        1,\n      ];\n    } catch (error) {\n      onIgnoredError?.(error);\n    }\n  };\n  const getPersisted = async () => {\n    const changes = await getChangesFromOtherStore();\n    return changes && (!objIsEmpty(changes[0][0]) || !objIsEmpty(changes[1][0]))\n      ? changes\n      : void 0;\n  };\n  const setPersisted = async (_getContent, changes) =>\n    changes\n      ? sendImpl(null, getTransactionId(), 3 /* ContentDiff */, changes)\n      : sendImpl(\n          null,\n          getTransactionId(),\n          2 /* ContentHashes */,\n          store.getMergeableContentHashes(),\n        );\n  const addPersisterListener = (listener) => (persisterListener = listener);\n  const delPersisterListener = () => (persisterListener = void 0);\n  const startSync = async (initialContent) => {\n    syncing = 1;\n    return await (\n      await persister.startAutoLoad(initialContent)\n    ).startAutoSave();\n  };\n  const stopSync = () => {\n    syncing = 0;\n    return persister.stopAutoLoad().stopAutoSave();\n  };\n  const destroy = () => {\n    destroyImpl();\n    return persister.stopSync();\n  };\n  const getSynchronizerStats = () => ({sends, receives});\n  const persister = createCustomPersister(\n    store,\n    getPersisted,\n    setPersisted,\n    addPersisterListener,\n    delPersisterListener,\n    onIgnoredError,\n    2,\n    // MergeableStoreOnly\n    {startSync, stopSync, destroy, getSynchronizerStats, ...extra},\n    1,\n  );\n  registerReceive((fromClientId, transactionOrRequestId, message, body) => {\n    const isAutoLoading = syncing || persister.isAutoLoading();\n    receives++;\n    onReceive?.(fromClientId, transactionOrRequestId, message, body);\n    if (message == 0 /* Response */) {\n      ifNotUndefined(\n        mapGet(pendingRequests, transactionOrRequestId),\n        ([toClientId, handleResponse]) =>\n          isUndefined(toClientId) || toClientId == fromClientId\n            ? handleResponse(body, fromClientId)\n            : /* istanbul ignore next */\n              0,\n      );\n    } else if (message == 2 /* ContentHashes */ && isAutoLoading) {\n      getChangesFromOtherStore(\n        fromClientId,\n        body,\n        transactionOrRequestId ?? void 0,\n      )\n        .then((changes) => {\n          persisterListener?.(void 0, changes);\n        })\n        .catch(onIgnoredError);\n    } else if (message == 3 /* ContentDiff */ && isAutoLoading) {\n      persisterListener?.(void 0, body);\n    } else {\n      ifNotUndefined(\n        message == 1 /* GetContentHashes */ &&\n          (syncing || persister.isAutoSaving())\n          ? store.getMergeableContentHashes()\n          : message == 4 /* GetTableDiff */\n            ? store.getMergeableTableDiff(body)\n            : message == 5 /* GetRowDiff */\n              ? store.getMergeableRowDiff(body)\n              : message == 6 /* GetCellDiff */\n                ? store.getMergeableCellDiff(body)\n                : message == 7 /* GetValueDiff */\n                  ? store.getMergeableValueDiff(body)\n                  : void 0,\n        (response) => {\n          sendImpl(\n            fromClientId,\n            transactionOrRequestId,\n            0 /* Response */,\n            response,\n          );\n        },\n      );\n    }\n  });\n  return persister;\n};\n\nconst createWsSynchronizer = async (\n  store,\n  webSocket,\n  requestTimeoutSeconds = 1,\n  onSend,\n  onReceive,\n  onIgnoredError,\n) => {\n  const addEventListener = (event, handler) => {\n    webSocket.addEventListener(event, handler);\n    return () => webSocket.removeEventListener(event, handler);\n  };\n  const registerReceive = (receive) =>\n    addEventListener(MESSAGE, ({data}) =>\n      receivePayload(data.toString(UTF8), receive),\n    );\n  const send = (toClientId, ...args) =>\n    webSocket.send(createPayload(toClientId, ...args));\n  const destroy = () => {\n    webSocket.close();\n  };\n  const synchronizer = createCustomSynchronizer(\n    store,\n    send,\n    registerReceive,\n    destroy,\n    requestTimeoutSeconds,\n    onSend,\n    onReceive,\n    onIgnoredError,\n    {getWebSocket: () => webSocket},\n  );\n  return promiseNew((resolve) => {\n    if (webSocket.readyState != webSocket.OPEN) {\n      const onAttempt = (error) => {\n        if (error) {\n          onIgnoredError?.(error);\n        }\n        removeOpenListener();\n        removeErrorListener();\n        resolve(synchronizer);\n      };\n      const removeOpenListener = addEventListener(OPEN, () => onAttempt());\n      const removeErrorListener = addEventListener(ERROR, onAttempt);\n    } else {\n      resolve(synchronizer);\n    }\n  });\n};\n\nexport {createWsSynchronizer};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6079, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6085, "column": 0}, "map": {"version":3,"sources":["file:///home/corey/workspace/game-time-plus-next/node_modules/.pnpm/tinybase%405.4.8_%40cloudflare%2Bworkers-types%404.20250224.0_prettier%403.5.2_react-dom%4019.0.0_r_f119fa6fd70ae136b14596e010fc1b02/node_modules/tinybase/ui-react-inspector/index.js"],"sourcesContent":["import React from 'react';\nimport {\n  useCell,\n  useValue,\n  useSetValueCallback,\n  useSetCellCallback,\n  ValueView,\n  useValueIds,\n  useStoreOrStoreById,\n  useIndexesOrIndexesById,\n  useSliceRowIds,\n  useTableCellIds,\n  useResultRowCount,\n  useResultSortedRowIds,\n  ResultCellView,\n  useResultTableCellIds,\n  useRelationshipsOrRelationshipsById,\n  CellView,\n  useRowIds,\n  useRemoteRowId,\n  useRowCount,\n  useSortedRowIds,\n  useIndexes,\n  useIndexIds,\n  useSliceIds,\n  useMetrics,\n  useMetricIds,\n  useMetric,\n  useQueries,\n  useQueryIds,\n  useRelationships,\n  useRelationshipIds,\n  useStore,\n  useTableIds,\n  useValues,\n  useStoreIds,\n  useMetricsIds,\n  useIndexesIds,\n  useRelationshipsIds,\n  useQueriesIds,\n  useCreateStore,\n  useCreatePersister,\n} from '../ui-react/index.js';\n\nconst getTypeOf = (thing) => typeof thing;\nconst EMPTY_STRING = '';\nconst STRING = getTypeOf(EMPTY_STRING);\nconst BOOLEAN = getTypeOf(true);\nconst NUMBER = getTypeOf(0);\nconst FUNCTION = getTypeOf(getTypeOf);\nconst TYPE = 'type';\nconst DEFAULT = 'default';\nconst LISTENER = 'Listener';\nconst ADD = 'add';\nconst HAS = 'Has';\nconst IDS = 'Ids';\nconst TABLE = 'Table';\nconst TABLES = TABLE + 's';\nconst TABLE_IDS = TABLE + IDS;\nconst ROW = 'Row';\nconst ROW_COUNT = ROW + 'Count';\nconst ROW_IDS = ROW + IDS;\nconst CELL = 'Cell';\nconst CELL_IDS = CELL + IDS;\nconst VALUE = 'Value';\nconst VALUES = VALUE + 's';\nconst VALUE_IDS = VALUE + IDS;\nconst CURRENT_TARGET = 'currentTarget';\nconst _VALUE = 'value';\nconst UNDEFINED = '\\uFFFC';\nconst id = (key) => EMPTY_STRING + key;\nconst strSplit = (str, separator = EMPTY_STRING, limit) =>\n  str.split(separator, limit);\n\nconst GLOBAL = globalThis;\nconst WINDOW = GLOBAL.window;\nconst math = Math;\nconst mathMin = math.min;\nconst mathFloor = math.floor;\nconst isFiniteNumber = isFinite;\nconst isInstanceOf = (thing, cls) => thing instanceof cls;\nconst isUndefined = (thing) => thing == void 0;\nconst ifNotUndefined = (value, then, otherwise) =>\n  isUndefined(value) ? otherwise?.() : then(value);\nconst isTypeStringOrBoolean = (type) => type == STRING || type == BOOLEAN;\nconst isString = (thing) => getTypeOf(thing) == STRING;\nconst isFunction = (thing) => getTypeOf(thing) == FUNCTION;\nconst isArray = (thing) => Array.isArray(thing);\nconst slice = (arrayOrString, start, end) => arrayOrString.slice(start, end);\nconst size = (arrayOrString) => arrayOrString.length;\nconst test = (regex, subject) => regex.test(subject);\nconst errorNew = (message) => {\n  throw new Error(message);\n};\n\nconst {\n  PureComponent,\n  Fragment,\n  createContext,\n  createElement,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n  useSyncExternalStore,\n} = React;\nconst getProps = (getProps2, ...ids) =>\n  isUndefined(getProps2) ? {} : getProps2(...ids);\nconst getRelationshipsStoreTableIds = (relationships, relationshipId) => [\n  relationships,\n  relationships?.getStore(),\n  relationships?.getLocalTableId(relationshipId),\n  relationships?.getRemoteTableId(relationshipId),\n];\nconst getIndexStoreTableId = (indexes, indexId) => [\n  indexes,\n  indexes?.getStore(),\n  indexes?.getTableId(indexId),\n];\n\nconst arrayHas = (array, value) => array.includes(value);\nconst arrayEvery = (array, cb) => array.every(cb);\nconst arrayIsEqual = (array1, array2) =>\n  size(array1) === size(array2) &&\n  arrayEvery(array1, (value1, index) => array2[index] === value1);\nconst arraySort = (array, sorter) => array.sort(sorter);\nconst arrayForEach = (array, cb) => array.forEach(cb);\nconst arrayJoin = (array, sep = EMPTY_STRING) => array.join(sep);\nconst arrayMap = (array, cb) => array.map(cb);\nconst arrayIsEmpty = (array) => size(array) == 0;\nconst arrayReduce = (array, cb, initial) => array.reduce(cb, initial);\nconst arrayClear = (array, to) => array.splice(0, to);\nconst arrayPush = (array, ...values) => array.push(...values);\nconst arrayShift = (array) => array.shift();\n\nconst object = Object;\nconst getPrototypeOf = (obj) => object.getPrototypeOf(obj);\nconst objEntries = object.entries;\nconst objFrozen = object.isFrozen;\nconst isObject = (obj) =>\n  !isUndefined(obj) &&\n  ifNotUndefined(\n    getPrototypeOf(obj),\n    (objPrototype) =>\n      objPrototype == object.prototype ||\n      isUndefined(getPrototypeOf(objPrototype)),\n\n    /* istanbul ignore next */\n    () => true,\n  );\nconst objIds = object.keys;\nconst objFreeze = object.freeze;\nconst objNew = (entries = []) => object.fromEntries(entries);\nconst objHas = (obj, id) => id in obj;\nconst objDel = (obj, id) => {\n  delete obj[id];\n  return obj;\n};\nconst objForEach = (obj, cb) =>\n  arrayForEach(objEntries(obj), ([id, value]) => cb(value, id));\nconst objToArray = (obj, cb) =>\n  arrayMap(objEntries(obj), ([id, value]) => cb(value, id));\nconst objMap = (obj, cb) =>\n  objNew(objToArray(obj, (value, id) => [id, cb(value, id)]));\nconst objSize = (obj) => size(objIds(obj));\nconst objIsEmpty = (obj) => isObject(obj) && objSize(obj) == 0;\nconst objValidate = (obj, validateChild, onInvalidObj, emptyIsValid = 0) => {\n  if (\n    isUndefined(obj) ||\n    !isObject(obj) ||\n    (!emptyIsValid && objIsEmpty(obj)) ||\n    objFrozen(obj)\n  ) {\n    onInvalidObj?.();\n    return false;\n  }\n  objForEach(obj, (child, id) => {\n    if (!validateChild(child, id)) {\n      objDel(obj, id);\n    }\n  });\n  return emptyIsValid ? true : !objIsEmpty(obj);\n};\n\nconst jsonString = JSON.stringify;\nconst jsonParse = JSON.parse;\nconst jsonStringWithMap = (obj) =>\n  jsonString(obj, (_key, value) =>\n    isInstanceOf(value, Map) ? object.fromEntries([...value]) : value,\n  );\nconst jsonStringWithUndefined = (obj) =>\n  jsonString(obj, (_key, value) => (value === void 0 ? UNDEFINED : value));\nconst jsonParseWithUndefined = (str) =>\n  jsonParse(str, (_key, value) => (value === UNDEFINED ? void 0 : value));\n\nconst UNIQUE_ID = 'tinybaseInspector';\nconst TITLE = 'TinyBase Inspector';\nconst POSITIONS = ['left', 'top', 'bottom', 'right', 'full'];\nconst STATE_TABLE = 'state';\nconst SORT_CELL = 'sort';\nconst OPEN_CELL = 'open';\nconst POSITION_VALUE = 'position';\nconst OPEN_VALUE = OPEN_CELL;\nconst EDITABLE_CELL = 'editable';\nconst getUniqueId = (...args) => jsonStringWithMap(args);\nconst sortedIdsMap = (ids, callback) => arrayMap(arraySort([...ids]), callback);\nconst useEditable = (uniqueId, s) => [\n  !!useCell(STATE_TABLE, uniqueId, EDITABLE_CELL, s),\n  useCallback(\n    (event) => {\n      s.setCell(STATE_TABLE, uniqueId, EDITABLE_CELL, (editable) => !editable);\n      event.preventDefault();\n    },\n    [s, uniqueId],\n  ),\n];\n\nvar img =\n  \"data:image/svg+xml,%3csvg viewBox='0 0 680 680' xmlns='http://www.w3.org/2000/svg' style='width:680px%3bheight:680px'%3e %3cpath stroke='white' stroke-width='80' fill='none' d='M340 617a84 241 90 11.01 0zM131 475a94 254 70 10428-124 114 286 70 01-428 124zm0-140a94 254 70 10428-124 114 286 70 01-428 124zm-12-127a94 254 70 00306 38 90 260 90 01-306-38zm221 3a74 241 90 11.01 0z' /%3e %3cpath fill='%23d81b60' d='M131 475a94 254 70 10428-124 114 286 70 01-428 124zm0-140a94 254 70 10428-124 114 286 70 01-428 124z' /%3e %3cpath d='M249 619a94 240 90 00308-128 114 289 70 01-308 128zM119 208a94 254 70 00306 38 90 260 90 01-306-38zm221 3a74 241 90 11.01 0z' /%3e%3c/svg%3e\";\n\nconst PENCIL = 'M20 80l5-15l40-40l10 10l-40 40l-15 5m5-15l10 10';\nconst PRE_CSS = 'content:url(\"';\nconst POST_CSS = '\")';\nconst PRE =\n  PRE_CSS +\n  `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' stroke-width='4' stroke='white' fill='none'>`;\nconst POST = `</svg>` + POST_CSS;\nconst LOGO_SVG = PRE_CSS + img + POST_CSS;\nconst POSITIONS_SVG = arrayMap(\n  [\n    [20, 20, 20, 60],\n    [20, 20, 60, 20],\n    [20, 60, 60, 20],\n    [60, 20, 20, 60],\n    [30, 30, 40, 40],\n  ],\n  ([x, y, w, h]) =>\n    PRE +\n    `<rect x='20' y='20' width='60' height='60' fill='grey'/><rect x='${x}' y='${y}' width='${w}' height='${h}' fill='white'/>` +\n    POST,\n);\nconst CLOSE_SVG = PRE + `<path d='M20 20l60 60M20 80l60-60' />` + POST;\nconst EDIT_SVG = PRE + `<path d='${PENCIL}' />` + POST;\nconst DONE_SVG = PRE + `<path d='${PENCIL}M20 20l60 60' />` + POST;\n\nconst SCROLLBAR = '*::-webkit-scrollbar';\nconst APP_STYLESHEET = arrayJoin(\n  objToArray(\n    {\n      '': 'all:initial;font-family:sans-serif;font-size:0.75rem;position:fixed;z-index:999999',\n      '*': 'all:revert',\n      '*::before': 'all:revert',\n      '*::after': 'all:revert',\n      [SCROLLBAR]: 'width:0.5rem;height:0.5rem;',\n      [SCROLLBAR + '-track']: 'background:#111',\n      [SCROLLBAR + '-thumb']: 'background:#999;border:1px solid #111',\n      [SCROLLBAR + '-thumb:hover']: 'background:#fff',\n      [SCROLLBAR + '-corner']: 'background:#111',\n      img: 'width:1rem;height:1rem;background:#111;border:0;vertical-align:text-bottom',\n      // Nub\n      '>img': 'padding:0.25rem;bottom:0;right:0;position:fixed;' + LOGO_SVG,\n      ...objNew(\n        arrayMap(['bottom:0;left:0', 'top:0;right:0'], (css, p) => [\n          `>img[data-position='${p}']`,\n          css,\n        ]),\n      ),\n      // Panel\n      main: 'display:flex;flex-direction:column;background:#111d;color:#fff;position:fixed;',\n      ...objNew(\n        arrayMap(\n          [\n            'bottom:0;left:0;width:35vw;height:100vh',\n            'top:0;right:0;width:100vw;height:30vh',\n            'bottom:0;left:0;width:100vw;height:30vh',\n            'top:0;right:0;width:35vw;height:100vh',\n            'top:0;right:0;width:100vw;height:100vh',\n          ],\n          (css, p) => [`main[data-position='${p}']`, css],\n        ),\n      ),\n      // Header\n      header: 'display:flex;padding:0.25rem;background:#000;align-items:center',\n      'header>img:nth-of-type(1)': LOGO_SVG,\n      'header>img:nth-of-type(6)': CLOSE_SVG,\n      ...objNew(\n        arrayMap(POSITIONS_SVG, (SVG, p) => [\n          `header>img[data-id='${p}']`,\n          SVG,\n        ]),\n      ),\n      'header>span':\n        'flex:1;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin-left:0.25rem',\n      // Body\n      article: 'padding:0.25rem 0.25rem 0.25rem 0.5rem;overflow:auto;flex:1',\n      details: 'margin-left:0.75rem;width:fit-content;',\n      'details img': 'display:none',\n      'details[open]>summary img':\n        'display:unset;background:none;margin-left:0.25rem',\n      'details[open]>summary img.edit': EDIT_SVG,\n      'details[open]>summary img.done': DONE_SVG,\n      summary:\n        'margin-left:-0.75rem;line-height:1.25rem;user-select:none;width:fit-content',\n      // tables\n      table: 'border-collapse:collapse;table-layout:fixed;margin-bottom:0.5rem',\n      'table input':\n        'background:#111;color:unset;padding:0 0.25rem;border:0;font-size:unset;vertical-align:top;margin:0',\n      'table input[type=\"number\"]': 'width:4rem',\n      'table tbody button':\n        'font-size:0;background:#fff;border-radius:50%;margin:0 0.125rem 0 0;width:0.85rem;color:#111',\n      'table button:first-letter': 'font-size:0.75rem',\n      thead: 'background:#222',\n      'th:nth-of-type(1)': 'min-width:2rem;',\n      'th.sorted': 'background:#000',\n      'table caption': 'text-align:left;white-space:nowrap;line-height:1.25rem',\n      button: 'width:1.5rem;border:none;background:none;color:#fff;padding:0',\n      'button[disabled]': 'color:#777',\n      'button.next': 'margin-right:0.5rem',\n      [`th,#${UNIQUE_ID} td`]:\n        'overflow:hidden;text-overflow:ellipsis;padding:0.25rem 0.5rem;max-width:12rem;white-space:nowrap;border-width:1px 0;border-style:solid;border-color:#777;text-align:left',\n      'span.warn': 'margin:0.25rem;color:#d81b60',\n    },\n    (style, selector) => (style ? `#${UNIQUE_ID} ${selector}{${style}}` : ''),\n  ),\n);\n\nconst Nub = ({s}) => {\n  const position = useValue(POSITION_VALUE, s) ?? 1;\n  const handleOpen = useSetValueCallback(OPEN_VALUE, () => true, [], s);\n  return useValue(OPEN_VALUE, s)\n    ? null\n    : /* @__PURE__ */ createElement('img', {\n        onClick: handleOpen,\n        title: TITLE,\n        'data-position': position,\n      });\n};\n\nconst Details = ({\n  uniqueId,\n  summary,\n  editable,\n  handleEditable,\n  children,\n  s,\n}) => {\n  const open = !!useCell(STATE_TABLE, uniqueId, OPEN_CELL, s);\n  const handleToggle = useSetCellCallback(\n    STATE_TABLE,\n    uniqueId,\n    OPEN_CELL,\n    (event) => event[CURRENT_TARGET].open,\n    [],\n    s,\n  );\n  return /* @__PURE__ */ createElement(\n    'details',\n    {open, onToggle: handleToggle},\n    /* @__PURE__ */ createElement(\n      'summary',\n      null,\n      summary,\n      handleEditable\n        ? /* @__PURE__ */ createElement('img', {\n            onClick: handleEditable,\n            className: editable ? 'done' : 'edit',\n          })\n        : null,\n    ),\n    children,\n  );\n};\n\nconst getCellOrValueType = (cellOrValue) => {\n  const type = getTypeOf(cellOrValue);\n  return isTypeStringOrBoolean(type) ||\n    (type == NUMBER && isFiniteNumber(cellOrValue))\n    ? type\n    : void 0;\n};\nconst setOrDelCell = (store, tableId, rowId, cellId, cell) =>\n  isUndefined(cell)\n    ? store.delCell(tableId, rowId, cellId, true)\n    : store.setCell(tableId, rowId, cellId, cell);\nconst setOrDelValue = (store, valueId, value) =>\n  isUndefined(value) ? store.delValue(valueId) : store.setValue(valueId, value);\nconst getTypeCase = (type, stringCase, numberCase, booleanCase) =>\n  type == STRING ? stringCase : type == NUMBER ? numberCase : booleanCase;\n\nconst DOT = '.';\nconst EDITABLE = 'editable';\nconst LEFT_ARROW = '\\u2190';\nconst UP_ARROW = '\\u2191';\nconst RIGHT_ARROW = '\\u2192';\nconst DOWN_ARROW = '\\u2193';\nconst useDottedCellIds = (tableId, store) =>\n  arrayMap(useTableCellIds(tableId, store), (cellId) => tableId + DOT + cellId);\nconst useCallbackOrUndefined = (callback, deps, test) => {\n  const returnCallback = useCallback(callback, deps);\n  return test ? returnCallback : void 0;\n};\nconst useParams = (...args) =>\n  useMemo(\n    () => args,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    args,\n  );\nconst useStoreCellComponentProps = (store, tableId) =>\n  useMemo(() => ({store, tableId}), [store, tableId]);\nconst useQueriesCellComponentProps = (queries, queryId) =>\n  useMemo(() => ({queries, queryId}), [queries, queryId]);\nconst useSortingAndPagination = (\n  cellId,\n  descending = false,\n  sortOnClick,\n  offset = 0,\n  limit,\n  total,\n  paginator,\n  onChange,\n) => {\n  const [[currentCellId, currentDescending, currentOffset], setState] =\n    useState([cellId, descending, offset]);\n  const setStateAndChange = useCallback(\n    (sortAndOffset) => {\n      setState(sortAndOffset);\n      onChange?.(sortAndOffset);\n    },\n    [onChange],\n  );\n  const handleSort = useCallbackOrUndefined(\n    (cellId2) =>\n      setStateAndChange([\n        cellId2,\n        cellId2 == currentCellId ? !currentDescending : false,\n        currentOffset,\n      ]),\n    [setStateAndChange, currentCellId, currentDescending, currentOffset],\n    sortOnClick,\n  );\n  const handleChangeOffset = useCallback(\n    (offset2) => setStateAndChange([currentCellId, currentDescending, offset2]),\n    [setStateAndChange, currentCellId, currentDescending],\n  );\n  const PaginatorComponent =\n    paginator === true ? SortedTablePaginator : paginator;\n  return [\n    [currentCellId, currentDescending, currentOffset],\n    handleSort,\n    useMemo(\n      () =>\n        paginator === false\n          ? null\n          : /* @__PURE__ */ createElement(PaginatorComponent, {\n              offset: currentOffset,\n              limit,\n              total,\n              onChange: handleChangeOffset,\n            }),\n      [\n        paginator,\n        PaginatorComponent,\n        currentOffset,\n        limit,\n        total,\n        handleChangeOffset,\n      ],\n    ),\n  ];\n};\nconst useCells = (defaultCellIds, customCells, defaultCellComponent) =>\n  useMemo(() => {\n    const cellIds = customCells ?? defaultCellIds;\n    return objMap(\n      isArray(cellIds)\n        ? objNew(arrayMap(cellIds, (cellId) => [cellId, cellId]))\n        : cellIds,\n      (labelOrCustomCell, cellId) => ({\n        ...{label: cellId, component: defaultCellComponent},\n        ...(isString(labelOrCustomCell)\n          ? {label: labelOrCustomCell}\n          : labelOrCustomCell),\n      }),\n    );\n  }, [customCells, defaultCellComponent, defaultCellIds]);\nconst HtmlTable = ({\n  className,\n  headerRow,\n  idColumn,\n  params: [\n    cells,\n    cellComponentProps,\n    rowIds,\n    sortAndOffset,\n    handleSort,\n    paginatorComponent,\n  ],\n}) =>\n  /* @__PURE__ */ createElement(\n    'table',\n    {className},\n    paginatorComponent\n      ? /* @__PURE__ */ createElement('caption', null, paginatorComponent)\n      : null,\n    headerRow === false\n      ? null\n      : /* @__PURE__ */ createElement(\n          'thead',\n          null,\n          /* @__PURE__ */ createElement(\n            'tr',\n            null,\n            idColumn === false\n              ? null\n              : /* @__PURE__ */ createElement(HtmlHeaderCell, {\n                  sort: sortAndOffset ?? [],\n                  label: 'Id',\n                  onClick: handleSort,\n                }),\n            objToArray(cells, ({label}, cellId) =>\n              /* @__PURE__ */ createElement(HtmlHeaderCell, {\n                key: cellId,\n                cellId,\n                label,\n                sort: sortAndOffset ?? [],\n                onClick: handleSort,\n              }),\n            ),\n          ),\n        ),\n    /* @__PURE__ */ createElement(\n      'tbody',\n      null,\n      arrayMap(rowIds, (rowId) =>\n        /* @__PURE__ */ createElement(\n          'tr',\n          {key: rowId},\n          idColumn === false\n            ? null\n            : /* @__PURE__ */ createElement('th', null, rowId),\n          objToArray(\n            cells,\n            ({component: CellView2, getComponentProps}, cellId) =>\n              /* @__PURE__ */ createElement(\n                'td',\n                {key: cellId},\n                /* @__PURE__ */ createElement(CellView2, {\n                  ...getProps(getComponentProps, rowId, cellId),\n                  ...cellComponentProps,\n                  rowId,\n                  cellId,\n                }),\n              ),\n          ),\n        ),\n      ),\n    ),\n  );\nconst HtmlHeaderCell = ({\n  cellId,\n  sort: [sortCellId, sortDescending],\n  label = cellId ?? EMPTY_STRING,\n  onClick,\n}) =>\n  /* @__PURE__ */ createElement(\n    'th',\n    {\n      onClick: useCallbackOrUndefined(\n        () => onClick?.(cellId),\n        [onClick, cellId],\n        onClick,\n      ),\n      className:\n        isUndefined(sortDescending) || sortCellId != cellId\n          ? void 0\n          : `sorted ${sortDescending ? 'de' : 'a'}scending`,\n    },\n    isUndefined(sortDescending) || sortCellId != cellId\n      ? null\n      : (sortDescending ? DOWN_ARROW : UP_ARROW) + ' ',\n    label,\n  );\nconst RelationshipInHtmlRow = ({\n  localRowId,\n  params: [\n    idColumn,\n    cells,\n    localTableId,\n    remoteTableId,\n    relationshipId,\n    relationships,\n    store,\n  ],\n}) => {\n  const remoteRowId = useRemoteRowId(relationshipId, localRowId, relationships);\n  return /* @__PURE__ */ createElement(\n    'tr',\n    null,\n    idColumn === false\n      ? null\n      : /* @__PURE__ */ createElement(\n          Fragment,\n          null,\n          /* @__PURE__ */ createElement('th', null, localRowId),\n          /* @__PURE__ */ createElement('th', null, remoteRowId),\n        ),\n    objToArray(\n      cells,\n      ({component: CellView2, getComponentProps}, compoundCellId) => {\n        const [tableId, cellId] = strSplit(compoundCellId, DOT, 2);\n        const rowId =\n          tableId === localTableId\n            ? localRowId\n            : tableId === remoteTableId\n              ? remoteRowId\n              : null;\n        return isUndefined(rowId)\n          ? null\n          : /* @__PURE__ */ createElement(\n              'td',\n              {key: compoundCellId},\n              /* @__PURE__ */ createElement(CellView2, {\n                ...getProps(getComponentProps, rowId, cellId),\n                store,\n                tableId,\n                rowId,\n                cellId,\n              }),\n            );\n      },\n    ),\n  );\n};\nconst EditableThing = ({\n  thing,\n  onThingChange,\n  className,\n  hasSchema,\n  showType = true,\n}) => {\n  const [thingType, setThingType] = useState();\n  const [currentThing, setCurrentThing] = useState();\n  const [stringThing, setStringThing] = useState();\n  const [numberThing, setNumberThing] = useState();\n  const [booleanThing, setBooleanThing] = useState();\n  if (currentThing !== thing) {\n    setThingType(getCellOrValueType(thing));\n    setCurrentThing(thing);\n    setStringThing(String(thing));\n    setNumberThing(Number(thing) || 0);\n    setBooleanThing(Boolean(thing));\n  }\n  const handleThingChange = useCallback(\n    (thing2, setTypedThing) => {\n      setTypedThing(thing2);\n      setCurrentThing(thing2);\n      onThingChange(thing2);\n    },\n    [onThingChange],\n  );\n  const handleTypeChange = useCallback(() => {\n    if (!hasSchema?.()) {\n      const nextType = getTypeCase(thingType, NUMBER, BOOLEAN, STRING);\n      const thing2 = getTypeCase(\n        nextType,\n        stringThing,\n        numberThing,\n        booleanThing,\n      );\n      setThingType(nextType);\n      setCurrentThing(thing2);\n      onThingChange(thing2);\n    }\n  }, [\n    hasSchema,\n    onThingChange,\n    stringThing,\n    numberThing,\n    booleanThing,\n    thingType,\n  ]);\n  return /* @__PURE__ */ createElement(\n    'div',\n    {className},\n    showType\n      ? /* @__PURE__ */ createElement(\n          'button',\n          {className: thingType, onClick: handleTypeChange},\n          thingType,\n        )\n      : null,\n    getTypeCase(\n      thingType,\n      /* @__PURE__ */ createElement('input', {\n        key: thingType,\n        value: stringThing,\n        onChange: useCallback(\n          (event) =>\n            handleThingChange(\n              String(event[CURRENT_TARGET][_VALUE]),\n              setStringThing,\n            ),\n          [handleThingChange],\n        ),\n      }),\n      /* @__PURE__ */ createElement('input', {\n        key: thingType,\n        type: 'number',\n        value: numberThing,\n        onChange: useCallback(\n          (event) =>\n            handleThingChange(\n              Number(event[CURRENT_TARGET][_VALUE] || 0),\n              setNumberThing,\n            ),\n          [handleThingChange],\n        ),\n      }),\n      /* @__PURE__ */ createElement('input', {\n        key: thingType,\n        type: 'checkbox',\n        checked: booleanThing,\n        onChange: useCallback(\n          (event) =>\n            handleThingChange(\n              Boolean(event[CURRENT_TARGET].checked),\n              setBooleanThing,\n            ),\n          [handleThingChange],\n        ),\n      }),\n    ),\n  );\n};\nconst SortedTableInHtmlTable = ({\n  tableId,\n  cellId,\n  descending,\n  offset,\n  limit,\n  store,\n  editable,\n  sortOnClick,\n  paginator = false,\n  onChange,\n  customCells,\n  ...props\n}) => {\n  const [sortAndOffset, handleSort, paginatorComponent] =\n    useSortingAndPagination(\n      cellId,\n      descending,\n      sortOnClick,\n      offset,\n      limit,\n      useRowCount(tableId, store),\n      paginator,\n      onChange,\n    );\n  return /* @__PURE__ */ createElement(HtmlTable, {\n    ...props,\n    params: useParams(\n      useCells(\n        useTableCellIds(tableId, store),\n        customCells,\n        editable ? EditableCellView : CellView,\n      ),\n      useStoreCellComponentProps(store, tableId),\n      useSortedRowIds(tableId, ...sortAndOffset, limit, store),\n      sortAndOffset,\n      handleSort,\n      paginatorComponent,\n    ),\n  });\n};\nconst ValuesInHtmlTable = ({\n  store,\n  editable = false,\n  valueComponent: Value = editable ? EditableValueView : ValueView,\n  getValueComponentProps,\n  className,\n  headerRow,\n  idColumn,\n}) =>\n  /* @__PURE__ */ createElement(\n    'table',\n    {className},\n    headerRow === false\n      ? null\n      : /* @__PURE__ */ createElement(\n          'thead',\n          null,\n          /* @__PURE__ */ createElement(\n            'tr',\n            null,\n            idColumn === false\n              ? null\n              : /* @__PURE__ */ createElement('th', null, 'Id'),\n            /* @__PURE__ */ createElement('th', null, VALUE),\n          ),\n        ),\n    /* @__PURE__ */ createElement(\n      'tbody',\n      null,\n      arrayMap(useValueIds(store), (valueId) =>\n        /* @__PURE__ */ createElement(\n          'tr',\n          {key: valueId},\n          idColumn === false\n            ? null\n            : /* @__PURE__ */ createElement('th', null, valueId),\n          /* @__PURE__ */ createElement(\n            'td',\n            null,\n            /* @__PURE__ */ createElement(Value, {\n              ...getProps(getValueComponentProps, valueId),\n              valueId,\n              store,\n            }),\n          ),\n        ),\n      ),\n    ),\n  );\nconst SliceInHtmlTable = ({\n  indexId,\n  sliceId,\n  indexes,\n  editable,\n  customCells,\n  ...props\n}) => {\n  const [resolvedIndexes, store, tableId] = getIndexStoreTableId(\n    useIndexesOrIndexesById(indexes),\n    indexId,\n  );\n  return /* @__PURE__ */ createElement(HtmlTable, {\n    ...props,\n    params: useParams(\n      useCells(\n        useTableCellIds(tableId, store),\n        customCells,\n        editable ? EditableCellView : CellView,\n      ),\n      useStoreCellComponentProps(store, tableId),\n      useSliceRowIds(indexId, sliceId, resolvedIndexes),\n    ),\n  });\n};\nconst RelationshipInHtmlTable = ({\n  relationshipId,\n  relationships,\n  editable,\n  customCells,\n  className,\n  headerRow,\n  idColumn = true,\n}) => {\n  const [resolvedRelationships, store, localTableId, remoteTableId] =\n    getRelationshipsStoreTableIds(\n      useRelationshipsOrRelationshipsById(relationships),\n      relationshipId,\n    );\n  const cells = useCells(\n    [\n      ...useDottedCellIds(localTableId, store),\n      ...useDottedCellIds(remoteTableId, store),\n    ],\n    customCells,\n    editable ? EditableCellView : CellView,\n  );\n  const params = useParams(\n    idColumn,\n    cells,\n    localTableId,\n    remoteTableId,\n    relationshipId,\n    resolvedRelationships,\n    store,\n  );\n  return /* @__PURE__ */ createElement(\n    'table',\n    {className},\n    headerRow === false\n      ? null\n      : /* @__PURE__ */ createElement(\n          'thead',\n          null,\n          /* @__PURE__ */ createElement(\n            'tr',\n            null,\n            idColumn === false\n              ? null\n              : /* @__PURE__ */ createElement(\n                  Fragment,\n                  null,\n                  /* @__PURE__ */ createElement(\n                    'th',\n                    null,\n                    localTableId,\n                    '.Id',\n                  ),\n                  /* @__PURE__ */ createElement(\n                    'th',\n                    null,\n                    remoteTableId,\n                    '.Id',\n                  ),\n                ),\n            objToArray(cells, ({label}, cellId) =>\n              /* @__PURE__ */ createElement('th', {key: cellId}, label),\n            ),\n          ),\n        ),\n    /* @__PURE__ */ createElement(\n      'tbody',\n      null,\n      arrayMap(useRowIds(localTableId, store), (localRowId) =>\n        /* @__PURE__ */ createElement(RelationshipInHtmlRow, {\n          key: localRowId,\n          localRowId,\n          params,\n        }),\n      ),\n    ),\n  );\n};\nconst ResultSortedTableInHtmlTable = ({\n  queryId,\n  cellId,\n  descending,\n  offset,\n  limit,\n  queries,\n  sortOnClick,\n  paginator = false,\n  customCells,\n  onChange,\n  ...props\n}) => {\n  const [sortAndOffset, handleSort, paginatorComponent] =\n    useSortingAndPagination(\n      cellId,\n      descending,\n      sortOnClick,\n      offset,\n      limit,\n      useResultRowCount(queryId, queries),\n      paginator,\n      onChange,\n    );\n  return /* @__PURE__ */ createElement(HtmlTable, {\n    ...props,\n    params: useParams(\n      useCells(\n        useResultTableCellIds(queryId, queries),\n        customCells,\n        ResultCellView,\n      ),\n      useQueriesCellComponentProps(queries, queryId),\n      useResultSortedRowIds(queryId, ...sortAndOffset, limit, queries),\n      sortAndOffset,\n      handleSort,\n      paginatorComponent,\n    ),\n  });\n};\nconst EditableCellView = ({\n  tableId,\n  rowId,\n  cellId,\n  store,\n  className,\n  showType,\n}) =>\n  /* @__PURE__ */ createElement(EditableThing, {\n    thing: useCell(tableId, rowId, cellId, store),\n    onThingChange: useSetCellCallback(\n      tableId,\n      rowId,\n      cellId,\n      (cell) => cell,\n      [],\n      store,\n    ),\n    className: className ?? EDITABLE + CELL,\n    showType,\n    hasSchema: useStoreOrStoreById(store)?.hasTablesSchema,\n  });\nconst EditableValueView = ({valueId, store, className, showType}) =>\n  /* @__PURE__ */ createElement(EditableThing, {\n    thing: useValue(valueId, store),\n    onThingChange: useSetValueCallback(valueId, (value) => value, [], store),\n    className: className ?? EDITABLE + VALUE,\n    showType,\n    hasSchema: useStoreOrStoreById(store)?.hasValuesSchema,\n  });\nconst SortedTablePaginator = ({\n  onChange,\n  total,\n  offset = 0,\n  limit = total,\n  singular = 'row',\n  plural = singular + 's',\n}) => {\n  if (offset > total || offset < 0) {\n    offset = 0;\n    onChange(0);\n  }\n  const handlePrevClick = useCallbackOrUndefined(\n    () => onChange(offset - limit),\n    [onChange, offset, limit],\n    offset > 0,\n  );\n  const handleNextClick = useCallbackOrUndefined(\n    () => onChange(offset + limit),\n    [onChange, offset, limit],\n    offset + limit < total,\n  );\n  return /* @__PURE__ */ createElement(\n    Fragment,\n    null,\n    total > limit &&\n      /* @__PURE__ */ createElement(\n        Fragment,\n        null,\n        /* @__PURE__ */ createElement(\n          'button',\n          {\n            className: 'previous',\n            disabled: offset == 0,\n            onClick: handlePrevClick,\n          },\n          LEFT_ARROW,\n        ),\n        /* @__PURE__ */ createElement(\n          'button',\n          {\n            className: 'next',\n            disabled: offset + limit >= total,\n            onClick: handleNextClick,\n          },\n          RIGHT_ARROW,\n        ),\n        offset + 1,\n        ' to ',\n        mathMin(total, offset + limit),\n        ' of ',\n      ),\n    total,\n    ' ',\n    total != 1 ? plural : singular,\n  );\n};\n\nconst IndexView = ({indexes, indexesId, indexId, s}) =>\n  /* @__PURE__ */ createElement(\n    Details,\n    {\n      uniqueId: getUniqueId('i', indexesId, indexId),\n      summary: 'Index: ' + indexId,\n      s,\n    },\n    arrayMap(useSliceIds(indexId, indexes), (sliceId) =>\n      /* @__PURE__ */ createElement(SliceView, {\n        indexes,\n        indexesId,\n        indexId,\n        sliceId,\n        s,\n        key: sliceId,\n      }),\n    ),\n  );\nconst SliceView = ({indexes, indexesId, indexId, sliceId, s}) => {\n  const uniqueId = getUniqueId('i', indexesId, indexId, sliceId);\n  const [editable, handleEditable] = useEditable(uniqueId, s);\n  return /* @__PURE__ */ createElement(\n    Details,\n    {\n      uniqueId,\n      summary: 'Slice: ' + sliceId,\n      editable,\n      handleEditable,\n      s,\n    },\n    /* @__PURE__ */ createElement(SliceInHtmlTable, {\n      sliceId,\n      indexId,\n      indexes,\n      editable,\n    }),\n  );\n};\nconst IndexesView = ({indexesId, s}) => {\n  const indexes = useIndexes(indexesId);\n  const indexIds = useIndexIds(indexes);\n  return isUndefined(indexes)\n    ? null\n    : /* @__PURE__ */ createElement(\n        Details,\n        {\n          uniqueId: getUniqueId('i', indexesId),\n          summary: 'Indexes: ' + (indexesId ?? DEFAULT),\n          s,\n        },\n        arrayIsEmpty(indexIds)\n          ? 'No indexes defined'\n          : sortedIdsMap(indexIds, (indexId) =>\n              /* @__PURE__ */ createElement(IndexView, {\n                indexes,\n                indexesId,\n                indexId,\n                s,\n                key: indexId,\n              }),\n            ),\n      );\n};\n\nconst MetricRow = ({metrics, metricId}) =>\n  /* @__PURE__ */ createElement(\n    'tr',\n    null,\n    /* @__PURE__ */ createElement('th', null, metricId),\n    /* @__PURE__ */ createElement('td', null, metrics?.getTableId(metricId)),\n    /* @__PURE__ */ createElement('td', null, useMetric(metricId, metrics)),\n  );\nconst MetricsView = ({metricsId, s}) => {\n  const metrics = useMetrics(metricsId);\n  const metricIds = useMetricIds(metrics);\n  return isUndefined(metrics)\n    ? null\n    : /* @__PURE__ */ createElement(\n        Details,\n        {\n          uniqueId: getUniqueId('m', metricsId),\n          summary: 'Metrics: ' + (metricsId ?? DEFAULT),\n          s,\n        },\n        arrayIsEmpty(metricIds)\n          ? 'No metrics defined'\n          : /* @__PURE__ */ createElement(\n              'table',\n              null,\n              /* @__PURE__ */ createElement(\n                'thead',\n                null,\n                /* @__PURE__ */ createElement('th', null, 'Metric Id'),\n                /* @__PURE__ */ createElement('th', null, 'Table Id'),\n                /* @__PURE__ */ createElement('th', null, 'Metric'),\n              ),\n              /* @__PURE__ */ createElement(\n                'tbody',\n                null,\n                arrayMap(metricIds, (metricId) =>\n                  /* @__PURE__ */ createElement(MetricRow, {\n                    metrics,\n                    metricId,\n                    key: metricId,\n                  }),\n                ),\n              ),\n            ),\n      );\n};\n\nconst QueryView = ({queries, queriesId, queryId, s}) => {\n  const uniqueId = getUniqueId('q', queriesId, queryId);\n  const [cellId, descending, offset] = jsonParse(\n    useCell(STATE_TABLE, uniqueId, SORT_CELL, s) ?? '[]',\n  );\n  const handleChange = useSetCellCallback(\n    STATE_TABLE,\n    uniqueId,\n    SORT_CELL,\n    jsonStringWithMap,\n    [],\n    s,\n  );\n  return /* @__PURE__ */ createElement(\n    Details,\n    {uniqueId, summary: 'Query: ' + queryId, s},\n    /* @__PURE__ */ createElement(ResultSortedTableInHtmlTable, {\n      queryId,\n      queries,\n      cellId,\n      descending,\n      offset,\n      limit: 10,\n      paginator: true,\n      sortOnClick: true,\n      onChange: handleChange,\n    }),\n  );\n};\nconst QueriesView = ({queriesId, s}) => {\n  const queries = useQueries(queriesId);\n  const queryIds = useQueryIds(queries);\n  return isUndefined(queries)\n    ? null\n    : /* @__PURE__ */ createElement(\n        Details,\n        {\n          uniqueId: getUniqueId('q', queriesId),\n          summary: 'Queries: ' + (queriesId ?? DEFAULT),\n          s,\n        },\n        arrayIsEmpty(queryIds)\n          ? 'No queries defined'\n          : sortedIdsMap(queryIds, (queryId) =>\n              /* @__PURE__ */ createElement(QueryView, {\n                queries,\n                queriesId,\n                queryId,\n                s,\n                key: queryId,\n              }),\n            ),\n      );\n};\n\nconst RelationshipView = ({\n  relationships,\n  relationshipsId,\n  relationshipId,\n  s,\n}) => {\n  const uniqueId = getUniqueId('r', relationshipsId, relationshipId);\n  const [editable, handleEditable] = useEditable(uniqueId, s);\n  return /* @__PURE__ */ createElement(\n    Details,\n    {\n      uniqueId,\n      summary: 'Relationship: ' + relationshipId,\n      editable,\n      handleEditable,\n      s,\n    },\n    /* @__PURE__ */ createElement(RelationshipInHtmlTable, {\n      relationshipId,\n      relationships,\n      editable,\n    }),\n  );\n};\nconst RelationshipsView = ({relationshipsId, s}) => {\n  const relationships = useRelationships(relationshipsId);\n  const relationshipIds = useRelationshipIds(relationships);\n  return isUndefined(relationships)\n    ? null\n    : /* @__PURE__ */ createElement(\n        Details,\n        {\n          uniqueId: getUniqueId('r', relationshipsId),\n          summary: 'Relationships: ' + (relationshipsId ?? DEFAULT),\n          s,\n        },\n        arrayIsEmpty(relationshipIds)\n          ? 'No relationships defined'\n          : sortedIdsMap(relationshipIds, (relationshipId) =>\n              /* @__PURE__ */ createElement(RelationshipView, {\n                relationships,\n                relationshipsId,\n                relationshipId,\n                s,\n                key: relationshipId,\n              }),\n            ),\n      );\n};\n\nconst TableView = ({tableId, store, storeId, s}) => {\n  const uniqueId = getUniqueId('t', storeId, tableId);\n  const [cellId, descending, offset] = jsonParse(\n    useCell(STATE_TABLE, uniqueId, SORT_CELL, s) ?? '[]',\n  );\n  const handleChange = useSetCellCallback(\n    STATE_TABLE,\n    uniqueId,\n    SORT_CELL,\n    jsonStringWithMap,\n    [],\n    s,\n  );\n  const [editable, handleEditable] = useEditable(uniqueId, s);\n  return /* @__PURE__ */ createElement(\n    Details,\n    {\n      uniqueId,\n      summary: TABLE + ': ' + tableId,\n      editable,\n      handleEditable,\n      s,\n    },\n    /* @__PURE__ */ createElement(SortedTableInHtmlTable, {\n      tableId,\n      store,\n      cellId,\n      descending,\n      offset,\n      limit: 10,\n      paginator: true,\n      sortOnClick: true,\n      onChange: handleChange,\n      editable,\n    }),\n  );\n};\nconst ValuesView = ({store, storeId, s}) => {\n  const uniqueId = getUniqueId('v', storeId);\n  const [editable, handleEditable] = useEditable(uniqueId, s);\n  return arrayIsEmpty(useValueIds(store))\n    ? null\n    : /* @__PURE__ */ createElement(\n        Details,\n        {\n          uniqueId,\n          summary: VALUES,\n          editable,\n          handleEditable,\n          s,\n        },\n        /* @__PURE__ */ createElement(ValuesInHtmlTable, {store, editable}),\n      );\n};\nconst StoreView = ({storeId, s}) => {\n  const store = useStore(storeId);\n  const tableIds = useTableIds(store);\n  return isUndefined(store)\n    ? null\n    : /* @__PURE__ */ createElement(\n        Details,\n        {\n          uniqueId: getUniqueId('s', storeId),\n          summary:\n            (store.isMergeable() ? 'Mergeable' : '') +\n            'Store: ' +\n            (storeId ?? DEFAULT),\n          s,\n        },\n        /* @__PURE__ */ createElement(ValuesView, {storeId, store, s}),\n        sortedIdsMap(tableIds, (tableId) =>\n          /* @__PURE__ */ createElement(TableView, {\n            store,\n            storeId,\n            tableId,\n            s,\n            key: tableId,\n          }),\n        ),\n      );\n};\n\nconst Body = ({s}) => {\n  const articleRef = useRef(null);\n  const idleCallbackRef = useRef(0);\n  const [scrolled, setScrolled] = useState(false);\n  const {scrollLeft, scrollTop} = useValues(s);\n  useLayoutEffect(() => {\n    const article = articleRef.current;\n    if (article && !scrolled) {\n      const observer = new MutationObserver(() => {\n        if (\n          article.scrollWidth >= mathFloor(scrollLeft) + article.clientWidth &&\n          article.scrollHeight >= mathFloor(scrollTop) + article.clientHeight\n        ) {\n          article.scrollTo(scrollLeft, scrollTop);\n        }\n      });\n      observer.observe(article, {childList: true, subtree: true});\n      return () => observer.disconnect();\n    }\n  }, [scrolled, scrollLeft, scrollTop]);\n  const handleScroll = useCallback(\n    (event) => {\n      const {scrollLeft: scrollLeft2, scrollTop: scrollTop2} =\n        event[CURRENT_TARGET];\n      cancelIdleCallback(idleCallbackRef.current);\n      idleCallbackRef.current = requestIdleCallback(() => {\n        setScrolled(true);\n        s.setPartialValues({scrollLeft: scrollLeft2, scrollTop: scrollTop2});\n      });\n    },\n    [s],\n  );\n  const store = useStore();\n  const storeIds = useStoreIds();\n  const metrics = useMetrics();\n  const metricsIds = useMetricsIds();\n  const indexes = useIndexes();\n  const indexesIds = useIndexesIds();\n  const relationships = useRelationships();\n  const relationshipsIds = useRelationshipsIds();\n  const queries = useQueries();\n  const queriesIds = useQueriesIds();\n  return isUndefined(store) &&\n    arrayIsEmpty(storeIds) &&\n    isUndefined(metrics) &&\n    arrayIsEmpty(metricsIds) &&\n    isUndefined(indexes) &&\n    arrayIsEmpty(indexesIds) &&\n    isUndefined(relationships) &&\n    arrayIsEmpty(relationshipsIds) &&\n    isUndefined(queries) &&\n    arrayIsEmpty(queriesIds)\n    ? /* @__PURE__ */ createElement(\n        'span',\n        {className: 'warn'},\n        'There are no Stores or other objects to inspect. Make sure you placed the Inspector inside a Provider component.',\n      )\n    : /* @__PURE__ */ createElement(\n        'article',\n        {ref: articleRef, onScroll: handleScroll},\n        /* @__PURE__ */ createElement(StoreView, {s}),\n        arrayMap(storeIds, (storeId) =>\n          /* @__PURE__ */ createElement(StoreView, {storeId, s, key: storeId}),\n        ),\n        /* @__PURE__ */ createElement(MetricsView, {s}),\n        arrayMap(metricsIds, (metricsId) =>\n          /* @__PURE__ */ createElement(MetricsView, {\n            metricsId,\n            s,\n            key: metricsId,\n          }),\n        ),\n        /* @__PURE__ */ createElement(IndexesView, {s}),\n        arrayMap(indexesIds, (indexesId) =>\n          /* @__PURE__ */ createElement(IndexesView, {\n            indexesId,\n            s,\n            key: indexesId,\n          }),\n        ),\n        /* @__PURE__ */ createElement(RelationshipsView, {s}),\n        arrayMap(relationshipsIds, (relationshipsId) =>\n          /* @__PURE__ */ createElement(RelationshipsView, {\n            relationshipsId,\n            s,\n            key: relationshipsId,\n          }),\n        ),\n        /* @__PURE__ */ createElement(QueriesView, {s}),\n        arrayMap(queriesIds, (queriesId) =>\n          /* @__PURE__ */ createElement(QueriesView, {\n            queriesId,\n            s,\n            key: queriesId,\n          }),\n        ),\n      );\n};\n\nclass ErrorBoundary extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {e: 0};\n  }\n  static getDerivedStateFromError() {\n    return {e: 1};\n  }\n  // eslint-disable-next-line react/no-arrow-function-lifecycle\n  componentDidCatch = (error, info) =>\n    // eslint-disable-next-line no-console\n    console.error(error, info.componentStack);\n  render() {\n    return this.state.e\n      ? /* @__PURE__ */ createElement(\n          'span',\n          {className: 'warn'},\n          'Inspector error: please see console for details.',\n        )\n      : // eslint-disable-next-line react/prop-types\n        this.props.children;\n  }\n}\n\nconst Header = ({s}) => {\n  const position = useValue(POSITION_VALUE, s) ?? 1;\n  const handleClose = useSetValueCallback(OPEN_VALUE, () => false, [], s);\n  const handleDock = useSetValueCallback(\n    POSITION_VALUE,\n    (event) => Number(event[CURRENT_TARGET].dataset.id),\n    [],\n    s,\n  );\n  return /* @__PURE__ */ createElement(\n    'header',\n    null,\n    /* @__PURE__ */ createElement('img', {title: TITLE}),\n    /* @__PURE__ */ createElement('span', null, TITLE),\n    arrayMap(POSITIONS, (name, p) =>\n      p == position\n        ? null\n        : /* @__PURE__ */ createElement('img', {\n            onClick: handleDock,\n            'data-id': p,\n            title: 'Dock to ' + name,\n            key: p,\n          }),\n    ),\n    /* @__PURE__ */ createElement('img', {\n      onClick: handleClose,\n      title: 'Close',\n    }),\n  );\n};\n\nconst Panel = ({s}) => {\n  const position = useValue(POSITION_VALUE, s) ?? 1;\n  return useValue(OPEN_VALUE, s)\n    ? /* @__PURE__ */ createElement(\n        'main',\n        {'data-position': position},\n        /* @__PURE__ */ createElement(Header, {s}),\n        /* @__PURE__ */ createElement(\n          ErrorBoundary,\n          null,\n          /* @__PURE__ */ createElement(Body, {s}),\n        ),\n      )\n    : null;\n};\n\nconst collSizeN = (collSizer) => (coll) =>\n  arrayReduce(collValues(coll), (total, coll2) => total + collSizer(coll2), 0);\nconst collSize = (coll) => coll?.size ?? 0;\nconst collSize2 = collSizeN(collSize);\nconst collSize3 = collSizeN(collSize2);\nconst collSize4 = collSizeN(collSize3);\nconst collHas = (coll, keyOrValue) => coll?.has(keyOrValue) ?? false;\nconst collIsEmpty = (coll) => isUndefined(coll) || collSize(coll) == 0;\nconst collValues = (coll) => [...(coll?.values() ?? [])];\nconst collClear = (coll) => coll.clear();\nconst collForEach = (coll, cb) => coll?.forEach(cb);\nconst collDel = (coll, keyOrValue) => coll?.delete(keyOrValue);\n\nconst mapNew = (entries) => new Map(entries);\nconst mapKeys = (map) => [...(map?.keys() ?? [])];\nconst mapGet = (map, key) => map?.get(key);\nconst mapForEach = (map, cb) =>\n  collForEach(map, (value, key) => cb(key, value));\nconst mapMap = (coll, cb) =>\n  arrayMap([...(coll?.entries() ?? [])], ([key, value]) => cb(value, key));\nconst mapSet = (map, key, value) =>\n  isUndefined(value) ? (collDel(map, key), map) : map?.set(key, value);\nconst mapEnsure = (map, key, getDefaultValue, hadExistingValue) => {\n  if (!collHas(map, key)) {\n    mapSet(map, key, getDefaultValue());\n  } else {\n    hadExistingValue?.(mapGet(map, key));\n  }\n  return mapGet(map, key);\n};\nconst mapMatch = (map, obj, set, del = mapSet) => {\n  objMap(obj, (value, id) => set(map, id, value));\n  mapForEach(map, (id) => (objHas(obj, id) ? 0 : del(map, id)));\n  return map;\n};\nconst mapToObj = (map, valueMapper, excludeMapValue, excludeObjValue) => {\n  const obj = {};\n  collForEach(map, (mapValue, id) => {\n    if (!excludeMapValue?.(mapValue, id)) {\n      const objValue = valueMapper ? valueMapper(mapValue, id) : mapValue;\n      if (!excludeObjValue?.(objValue)) {\n        obj[id] = objValue;\n      }\n    }\n  });\n  return obj;\n};\nconst mapToObj2 = (map, valueMapper, excludeMapValue) =>\n  mapToObj(\n    map,\n    (childMap) => mapToObj(childMap, valueMapper, excludeMapValue),\n    collIsEmpty,\n    objIsEmpty,\n  );\nconst mapToObj3 = (map, valueMapper, excludeMapValue) =>\n  mapToObj(\n    map,\n    (childMap) => mapToObj2(childMap, valueMapper, excludeMapValue),\n    collIsEmpty,\n    objIsEmpty,\n  );\nconst mapClone = (map, mapValue) => {\n  const map2 = mapNew();\n  collForEach(map, (value, key) => map2.set(key, mapValue?.(value) ?? value));\n  return map2;\n};\nconst mapClone2 = (map) => mapClone(map, mapClone);\nconst mapClone3 = (map) => mapClone(map, mapClone2);\nconst visitTree = (node, path, ensureLeaf, pruneLeaf, p = 0) =>\n  ifNotUndefined(\n    (ensureLeaf ? mapEnsure : mapGet)(\n      node,\n      path[p],\n      p > size(path) - 2 ? ensureLeaf : mapNew,\n    ),\n    (nodeOrLeaf) => {\n      if (p > size(path) - 2) {\n        if (pruneLeaf?.(nodeOrLeaf)) {\n          mapSet(node, path[p]);\n        }\n        return nodeOrLeaf;\n      }\n      const leaf = visitTree(nodeOrLeaf, path, ensureLeaf, pruneLeaf, p + 1);\n      if (collIsEmpty(nodeOrLeaf)) {\n        mapSet(node, path[p]);\n      }\n      return leaf;\n    },\n  );\n\nconst setNew = (entryOrEntries) =>\n  new Set(\n    isArray(entryOrEntries) || isUndefined(entryOrEntries)\n      ? entryOrEntries\n      : [entryOrEntries],\n  );\nconst setAdd = (set, value) => set?.add(value);\n\nconst INTEGER = /^\\d+$/;\nconst getPoolFunctions = () => {\n  const pool = [];\n  let nextId = 0;\n  return [\n    (reuse) => (reuse ? arrayShift(pool) : null) ?? EMPTY_STRING + nextId++,\n    (id) => {\n      if (test(INTEGER, id) && size(pool) < 1e3) {\n        arrayPush(pool, id);\n      }\n    },\n  ];\n};\n\nconst getWildcardedLeaves = (deepIdSet, path = [EMPTY_STRING]) => {\n  const leaves = [];\n  const deep = (node, p) =>\n    p == size(path)\n      ? arrayPush(leaves, node)\n      : path[p] === null\n        ? collForEach(node, (node2) => deep(node2, p + 1))\n        : arrayForEach([path[p], null], (id) => deep(mapGet(node, id), p + 1));\n  deep(deepIdSet, 0);\n  return leaves;\n};\nconst getListenerFunctions = (getThing) => {\n  let thing;\n  const [getId, releaseId] = getPoolFunctions();\n  const allListeners = mapNew();\n  const addListener = (\n    listener,\n    idSetNode,\n    path,\n    pathGetters = [],\n    extraArgsGetter = () => [],\n  ) => {\n    thing ??= getThing();\n    const id = getId(1);\n    mapSet(allListeners, id, [\n      listener,\n      idSetNode,\n      path,\n      pathGetters,\n      extraArgsGetter,\n    ]);\n    setAdd(visitTree(idSetNode, path ?? [EMPTY_STRING], setNew), id);\n    return id;\n  };\n  const callListeners = (idSetNode, ids, ...extraArgs) =>\n    arrayForEach(getWildcardedLeaves(idSetNode, ids), (set) =>\n      collForEach(set, (id) =>\n        mapGet(allListeners, id)[0](thing, ...(ids ?? []), ...extraArgs),\n      ),\n    );\n  const delListener = (id) =>\n    ifNotUndefined(mapGet(allListeners, id), ([, idSetNode, idOrNulls]) => {\n      visitTree(idSetNode, idOrNulls ?? [EMPTY_STRING], void 0, (idSet) => {\n        collDel(idSet, id);\n        return collIsEmpty(idSet) ? 1 : 0;\n      });\n      mapSet(allListeners, id);\n      releaseId(id);\n      return idOrNulls;\n    });\n  const callListener = (id) =>\n    ifNotUndefined(\n      mapGet(allListeners, id),\n      ([listener, , path = [], pathGetters, extraArgsGetter]) => {\n        const callWithIds = (...ids) => {\n          const index = size(ids);\n          if (index == size(path)) {\n            listener(thing, ...ids, ...extraArgsGetter(ids));\n          } else if (isUndefined(path[index])) {\n            arrayForEach(pathGetters[index]?.(...ids) ?? [], (id2) =>\n              callWithIds(...ids, id2),\n            );\n          } else {\n            callWithIds(...ids, path[index]);\n          }\n        };\n        callWithIds();\n      },\n    );\n  return [addListener, callListeners, delListener, callListener];\n};\n\nconst scheduleRunning = mapNew();\nconst scheduleActions = mapNew();\nconst getStoreFunctions = (\n  persist = 1 /* StoreOnly */,\n  store,\n  isSynchronizer,\n) =>\n  persist != 1 /* StoreOnly */ && store.isMergeable()\n    ? [\n        1,\n        store.getMergeableContent,\n        () => store.getTransactionMergeableChanges(!isSynchronizer),\n        ([[changedTables], [changedValues]]) =>\n          !objIsEmpty(changedTables) || !objIsEmpty(changedValues),\n        store.setDefaultContent,\n      ]\n    : persist != 2 /* MergeableStoreOnly */\n      ? [\n          0,\n          store.getContent,\n          store.getTransactionChanges,\n          ([changedTables, changedValues]) =>\n            !objIsEmpty(changedTables) || !objIsEmpty(changedValues),\n          store.setContent,\n        ]\n      : errorNew('Store type not supported by this Persister');\nconst createCustomPersister = (\n  store,\n  getPersisted,\n  setPersisted,\n  addPersisterListener,\n  delPersisterListener,\n  onIgnoredError,\n  persist,\n  extra = {},\n  isSynchronizer = 0,\n  scheduleId = [],\n) => {\n  let status = 0; /* Idle */\n  let loads = 0;\n  let saves = 0;\n  let action;\n  let autoLoadHandle;\n  let autoSaveListenerId;\n  mapEnsure(scheduleRunning, scheduleId, () => 0);\n  mapEnsure(scheduleActions, scheduleId, () => []);\n  const statusListeners = mapNew();\n  const [\n    isMergeableStore,\n    getContent,\n    getChanges,\n    hasChanges,\n    setDefaultContent,\n  ] = getStoreFunctions(persist, store, isSynchronizer);\n  const [addListener, callListeners, delListenerImpl] = getListenerFunctions(\n    () => persister,\n  );\n  const setStatus = (newStatus) => {\n    if (newStatus != status) {\n      status = newStatus;\n      callListeners(statusListeners, void 0, status);\n    }\n  };\n  const run = async () => {\n    /* istanbul ignore else */\n    if (!mapGet(scheduleRunning, scheduleId)) {\n      mapSet(scheduleRunning, scheduleId, 1);\n      while (\n        !isUndefined((action = arrayShift(mapGet(scheduleActions, scheduleId))))\n      ) {\n        try {\n          await action();\n        } catch (error) {}\n      }\n      mapSet(scheduleRunning, scheduleId, 0);\n    }\n  };\n  const setContentOrChanges = (contentOrChanges) => {\n    (isMergeableStore && isArray(contentOrChanges?.[0])\n      ? contentOrChanges?.[2] === 1\n        ? store.applyMergeableChanges\n        : store.setMergeableContent\n      : contentOrChanges?.[2] === 1\n        ? store.applyChanges\n        : store.setContent)(contentOrChanges);\n  };\n  const load = async (initialContent) => {\n    /* istanbul ignore else */\n    if (status != 2 /* Saving */) {\n      setStatus(1 /* Loading */);\n      loads++;\n      await schedule(async () => {\n        try {\n          const content = await getPersisted();\n          if (isArray(content)) {\n            setContentOrChanges(content);\n          } else if (initialContent) {\n            setDefaultContent(initialContent);\n          } else {\n            errorNew(`Content is not an array: ${content}`);\n          }\n        } catch (error) {\n          if (initialContent) {\n            setDefaultContent(initialContent);\n          }\n        }\n        setStatus(0 /* Idle */);\n      });\n    }\n    return persister;\n  };\n  const startAutoLoad = async (initialContent) => {\n    stopAutoLoad();\n    await load(initialContent);\n    try {\n      autoLoadHandle = await addPersisterListener(async (content, changes) => {\n        if (changes || content) {\n          /* istanbul ignore else */\n          if (status != 2 /* Saving */) {\n            setStatus(1 /* Loading */);\n            loads++;\n            setContentOrChanges(changes ?? content);\n            setStatus(0 /* Idle */);\n          }\n        } else {\n          await load();\n        }\n      });\n    } catch (error) {}\n    return persister;\n  };\n  const stopAutoLoad = () => {\n    if (autoLoadHandle) {\n      delPersisterListener(autoLoadHandle);\n      autoLoadHandle = void 0;\n    }\n    return persister;\n  };\n  const isAutoLoading = () => !isUndefined(autoLoadHandle);\n  const save = async (changes) => {\n    /* istanbul ignore else */\n    if (status != 1 /* Loading */) {\n      setStatus(2 /* Saving */);\n      saves++;\n      await schedule(async () => {\n        try {\n          await setPersisted(getContent, changes);\n        } catch (error) {}\n        setStatus(0 /* Idle */);\n      });\n    }\n    return persister;\n  };\n  const startAutoSave = async () => {\n    stopAutoSave();\n    await save();\n    autoSaveListenerId = store.addDidFinishTransactionListener(() => {\n      const changes = getChanges();\n      if (hasChanges(changes)) {\n        save(changes);\n      }\n    });\n    return persister;\n  };\n  const stopAutoSave = () => {\n    if (autoSaveListenerId) {\n      store.delListener(autoSaveListenerId);\n      autoSaveListenerId = void 0;\n    }\n    return persister;\n  };\n  const isAutoSaving = () => !isUndefined(autoSaveListenerId);\n  const getStatus = () => status;\n  const addStatusListener = (listener) =>\n    addListener(listener, statusListeners);\n  const delListener = (listenerId) => {\n    delListenerImpl(listenerId);\n    return store;\n  };\n  const schedule = async (...actions) => {\n    arrayPush(mapGet(scheduleActions, scheduleId), ...actions);\n    await run();\n    return persister;\n  };\n  const getStore = () => store;\n  const destroy = () => {\n    arrayClear(mapGet(scheduleActions, scheduleId));\n    return stopAutoLoad().stopAutoSave();\n  };\n  const getStats = () => ({loads, saves});\n  const persister = {\n    load,\n    startAutoLoad,\n    stopAutoLoad,\n    isAutoLoading,\n    save,\n    startAutoSave,\n    stopAutoSave,\n    isAutoSaving,\n    getStatus,\n    addStatusListener,\n    delListener,\n    schedule,\n    getStore,\n    destroy,\n    getStats,\n    ...extra,\n  };\n  return objFreeze(persister);\n};\n\nconst STORAGE = 'storage';\nconst createStoragePersister = (\n  store,\n  storageName,\n  storage,\n  onIgnoredError,\n) => {\n  const getPersisted = async () =>\n    jsonParseWithUndefined(storage.getItem(storageName));\n  const setPersisted = async (getContent) =>\n    storage.setItem(storageName, jsonStringWithUndefined(getContent()));\n  const addPersisterListener = (listener) => {\n    const storageListener = (event) => {\n      if (event.storageArea === storage && event.key === storageName) {\n        try {\n          listener(jsonParse(event.newValue));\n        } catch {\n          listener();\n        }\n      }\n    };\n    WINDOW.addEventListener(STORAGE, storageListener);\n    return storageListener;\n  };\n  const delPersisterListener = (storageListener) =>\n    WINDOW.removeEventListener(STORAGE, storageListener);\n  return createCustomPersister(\n    store,\n    getPersisted,\n    setPersisted,\n    addPersisterListener,\n    delPersisterListener,\n    onIgnoredError,\n    3,\n    // StoreOrMergeableStore,\n    {getStorageName: () => storageName},\n  );\n};\nconst createSessionPersister = (store, storageName, onIgnoredError) =>\n  createStoragePersister(store, storageName, sessionStorage, onIgnoredError);\n\nconst pairNew = (value) => [value, value];\nconst pairCollSize2 = (pair, func = collSize2) => func(pair[0]) + func(pair[1]);\nconst pairNewMap = () => [mapNew(), mapNew()];\nconst pairClone = (array) => [...array];\nconst pairIsEqual = ([entry1, entry2]) => entry1 === entry2;\n\nconst defaultSorter = (sortKey1, sortKey2) =>\n  (sortKey1 ?? 0) < (sortKey2 ?? 0) ? -1 : 1;\n\nconst idsChanged = (changedIds, id2, addedOrRemoved) =>\n  mapSet(\n    changedIds,\n    id2,\n    mapGet(changedIds, id2) == -addedOrRemoved ? void 0 : addedOrRemoved,\n  );\nconst createStore = () => {\n  let hasTablesSchema;\n  let hasValuesSchema;\n  let hadTables = false;\n  let hadValues = false;\n  let transactions = 0;\n  let internalListeners = [];\n  const changedTableIds = mapNew();\n  const changedTableCellIds = mapNew();\n  const changedRowCount = mapNew();\n  const changedRowIds = mapNew();\n  const changedCellIds = mapNew();\n  const changedCells = mapNew();\n  const changedValueIds = mapNew();\n  const changedValues = mapNew();\n  const invalidCells = mapNew();\n  const invalidValues = mapNew();\n  const tablesSchemaMap = mapNew();\n  const tablesSchemaRowCache = mapNew();\n  const valuesSchemaMap = mapNew();\n  const valuesDefaulted = mapNew();\n  const valuesNonDefaulted = setNew();\n  const tablePoolFunctions = mapNew();\n  const tableCellIds = mapNew();\n  const tablesMap = mapNew();\n  const valuesMap = mapNew();\n  const hasTablesListeners = pairNewMap();\n  const tablesListeners = pairNewMap();\n  const tableIdsListeners = pairNewMap();\n  const hasTableListeners = pairNewMap();\n  const tableListeners = pairNewMap();\n  const tableCellIdsListeners = pairNewMap();\n  const hasTableCellListeners = pairNewMap();\n  const rowCountListeners = pairNewMap();\n  const rowIdsListeners = pairNewMap();\n  const sortedRowIdsListeners = pairNewMap();\n  const hasRowListeners = pairNewMap();\n  const rowListeners = pairNewMap();\n  const cellIdsListeners = pairNewMap();\n  const hasCellListeners = pairNewMap();\n  const cellListeners = pairNewMap();\n  const invalidCellListeners = pairNewMap();\n  const invalidValueListeners = pairNewMap();\n  const hasValuesListeners = pairNewMap();\n  const valuesListeners = pairNewMap();\n  const valueIdsListeners = pairNewMap();\n  const hasValueListeners = pairNewMap();\n  const valueListeners = pairNewMap();\n  const startTransactionListeners = mapNew();\n  const finishTransactionListeners = pairNewMap();\n  const [addListener, callListeners, delListenerImpl, callListenerImpl] =\n    getListenerFunctions(() => store);\n  const validateTablesSchema = (tableSchema) =>\n    objValidate(tableSchema, (tableSchema2) =>\n      objValidate(tableSchema2, validateCellOrValueSchema),\n    );\n  const validateValuesSchema = (valuesSchema) =>\n    objValidate(valuesSchema, validateCellOrValueSchema);\n  const validateCellOrValueSchema = (schema) => {\n    if (!objValidate(schema, (_child, id2) => arrayHas([TYPE, DEFAULT], id2))) {\n      return false;\n    }\n    const type = schema[TYPE];\n    if (!isTypeStringOrBoolean(type) && type != NUMBER) {\n      return false;\n    }\n    if (getCellOrValueType(schema[DEFAULT]) != type) {\n      objDel(schema, DEFAULT);\n    }\n    return true;\n  };\n  const validateContent = isArray;\n  const validateTables = (tables) =>\n    objValidate(tables, validateTable, cellInvalid);\n  const validateTable = (table, tableId) =>\n    (!hasTablesSchema ||\n      collHas(tablesSchemaMap, tableId) ||\n      /* istanbul ignore next */\n      cellInvalid(tableId)) &&\n    objValidate(\n      table,\n      (row, rowId) => validateRow(tableId, rowId, row),\n      () => cellInvalid(tableId),\n    );\n  const validateRow = (tableId, rowId, row, skipDefaults) =>\n    objValidate(\n      skipDefaults ? row : addDefaultsToRow(row, tableId, rowId),\n      (cell, cellId) =>\n        ifNotUndefined(\n          getValidatedCell(tableId, rowId, cellId, cell),\n          (validCell) => {\n            row[cellId] = validCell;\n            return true;\n          },\n          () => false,\n        ),\n      () => cellInvalid(tableId, rowId),\n    );\n  const getValidatedCell = (tableId, rowId, cellId, cell) =>\n    hasTablesSchema\n      ? ifNotUndefined(\n          mapGet(mapGet(tablesSchemaMap, tableId), cellId),\n          (cellSchema) =>\n            getCellOrValueType(cell) != cellSchema[TYPE]\n              ? cellInvalid(tableId, rowId, cellId, cell, cellSchema[DEFAULT])\n              : cell,\n          () => cellInvalid(tableId, rowId, cellId, cell),\n        )\n      : isUndefined(getCellOrValueType(cell))\n        ? cellInvalid(tableId, rowId, cellId, cell)\n        : cell;\n  const validateValues = (values, skipDefaults) =>\n    objValidate(\n      skipDefaults ? values : addDefaultsToValues(values),\n      (value, valueId) =>\n        ifNotUndefined(\n          getValidatedValue(valueId, value),\n          (validValue) => {\n            values[valueId] = validValue;\n            return true;\n          },\n          () => false,\n        ),\n      () => valueInvalid(),\n    );\n  const getValidatedValue = (valueId, value) =>\n    hasValuesSchema\n      ? ifNotUndefined(\n          mapGet(valuesSchemaMap, valueId),\n          (valueSchema) =>\n            getCellOrValueType(value) != valueSchema[TYPE]\n              ? valueInvalid(valueId, value, valueSchema[DEFAULT])\n              : value,\n          () => valueInvalid(valueId, value),\n        )\n      : isUndefined(getCellOrValueType(value))\n        ? valueInvalid(valueId, value)\n        : value;\n  const addDefaultsToRow = (row, tableId, rowId) => {\n    ifNotUndefined(\n      mapGet(tablesSchemaRowCache, tableId),\n      ([rowDefaulted, rowNonDefaulted]) => {\n        collForEach(rowDefaulted, (cell, cellId) => {\n          if (!objHas(row, cellId)) {\n            row[cellId] = cell;\n          }\n        });\n        collForEach(rowNonDefaulted, (cellId) => {\n          if (!objHas(row, cellId)) {\n            cellInvalid(tableId, rowId, cellId);\n          }\n        });\n      },\n    );\n    return row;\n  };\n  const addDefaultsToValues = (values) => {\n    if (hasValuesSchema) {\n      collForEach(valuesDefaulted, (value, valueId) => {\n        if (!objHas(values, valueId)) {\n          values[valueId] = value;\n        }\n      });\n      collForEach(valuesNonDefaulted, (valueId) => {\n        if (!objHas(values, valueId)) {\n          valueInvalid(valueId);\n        }\n      });\n    }\n    return values;\n  };\n  const setValidTablesSchema = (tablesSchema) =>\n    mapMatch(\n      tablesSchemaMap,\n      tablesSchema,\n      (_tablesSchema, tableId, tableSchema) => {\n        const rowDefaulted = mapNew();\n        const rowNonDefaulted = setNew();\n        mapMatch(\n          mapEnsure(tablesSchemaMap, tableId, mapNew),\n          tableSchema,\n          (tableSchemaMap, cellId, cellSchema) => {\n            mapSet(tableSchemaMap, cellId, cellSchema);\n            ifNotUndefined(\n              cellSchema[DEFAULT],\n              (def) => mapSet(rowDefaulted, cellId, def),\n              () => setAdd(rowNonDefaulted, cellId),\n            );\n          },\n        );\n        mapSet(tablesSchemaRowCache, tableId, [rowDefaulted, rowNonDefaulted]);\n      },\n      (_tablesSchema, tableId) => {\n        mapSet(tablesSchemaMap, tableId);\n        mapSet(tablesSchemaRowCache, tableId);\n      },\n    );\n  const setValidValuesSchema = (valuesSchema) =>\n    mapMatch(\n      valuesSchemaMap,\n      valuesSchema,\n      (_valuesSchema, valueId, valueSchema) => {\n        mapSet(valuesSchemaMap, valueId, valueSchema);\n        ifNotUndefined(\n          valueSchema[DEFAULT],\n          (def) => mapSet(valuesDefaulted, valueId, def),\n          () => setAdd(valuesNonDefaulted, valueId),\n        );\n      },\n      (_valuesSchema, valueId) => {\n        mapSet(valuesSchemaMap, valueId);\n        mapSet(valuesDefaulted, valueId);\n        collDel(valuesNonDefaulted, valueId);\n      },\n    );\n  const setOrDelTables = (tables) =>\n    objIsEmpty(tables) ? delTables() : setTables(tables);\n  const setValidContent = ([tables, values]) => {\n    (objIsEmpty(tables) ? delTables : setTables)(tables);\n    (objIsEmpty(values) ? delValues : setValues)(values);\n  };\n  const setValidTables = (tables) =>\n    mapMatch(\n      tablesMap,\n      tables,\n      (_tables, tableId, table) => setValidTable(tableId, table),\n      (_tables, tableId) => delValidTable(tableId),\n    );\n  const setValidTable = (tableId, table) =>\n    mapMatch(\n      mapEnsure(tablesMap, tableId, () => {\n        tableIdsChanged(tableId, 1);\n        mapSet(tablePoolFunctions, tableId, getPoolFunctions());\n        mapSet(tableCellIds, tableId, mapNew());\n        return mapNew();\n      }),\n      table,\n      (tableMap, rowId, row) => setValidRow(tableId, tableMap, rowId, row),\n      (tableMap, rowId) => delValidRow(tableId, tableMap, rowId),\n    );\n  const setValidRow = (tableId, tableMap, rowId, row, forceDel) =>\n    mapMatch(\n      mapEnsure(tableMap, rowId, () => {\n        rowIdsChanged(tableId, rowId, 1);\n        return mapNew();\n      }),\n      row,\n      (rowMap, cellId, cell) =>\n        setValidCell(tableId, rowId, rowMap, cellId, cell),\n      (rowMap, cellId) =>\n        delValidCell(tableId, tableMap, rowId, rowMap, cellId, forceDel),\n    );\n  const setValidCell = (tableId, rowId, rowMap, cellId, cell) => {\n    if (!collHas(rowMap, cellId)) {\n      cellIdsChanged(tableId, rowId, cellId, 1);\n    }\n    const oldCell = mapGet(rowMap, cellId);\n    if (cell !== oldCell) {\n      cellChanged(tableId, rowId, cellId, oldCell, cell);\n      mapSet(rowMap, cellId, cell);\n    }\n  };\n  const setCellIntoDefaultRow = (tableId, tableMap, rowId, cellId, validCell) =>\n    ifNotUndefined(\n      mapGet(tableMap, rowId),\n      (rowMap) => setValidCell(tableId, rowId, rowMap, cellId, validCell),\n      () =>\n        setValidRow(\n          tableId,\n          tableMap,\n          rowId,\n          addDefaultsToRow({[cellId]: validCell}, tableId, rowId),\n        ),\n    );\n  const setOrDelValues = (values) =>\n    objIsEmpty(values) ? delValues() : setValues(values);\n  const setValidValues = (values) =>\n    mapMatch(\n      valuesMap,\n      values,\n      (_valuesMap, valueId, value) => setValidValue(valueId, value),\n      (_valuesMap, valueId) => delValidValue(valueId),\n    );\n  const setValidValue = (valueId, value) => {\n    if (!collHas(valuesMap, valueId)) {\n      valueIdsChanged(valueId, 1);\n    }\n    const oldValue = mapGet(valuesMap, valueId);\n    if (value !== oldValue) {\n      valueChanged(valueId, oldValue, value);\n      mapSet(valuesMap, valueId, value);\n    }\n  };\n  const getNewRowId = (tableId, reuse) => {\n    const [getId] = mapGet(tablePoolFunctions, tableId);\n    let rowId;\n    do {\n      rowId = getId(reuse);\n    } while (collHas(mapGet(tablesMap, tableId), rowId));\n    return rowId;\n  };\n  const getOrCreateTable = (tableId) =>\n    mapGet(tablesMap, tableId) ?? setValidTable(tableId, {});\n  const delValidTable = (tableId) => setValidTable(tableId, {});\n  const delValidRow = (tableId, tableMap, rowId) => {\n    const [, releaseId] = mapGet(tablePoolFunctions, tableId);\n    releaseId(rowId);\n    setValidRow(tableId, tableMap, rowId, {}, true);\n  };\n  const delValidCell = (tableId, table, rowId, row, cellId, forceDel) => {\n    const defaultCell = mapGet(\n      mapGet(tablesSchemaRowCache, tableId)?.[0],\n      cellId,\n    );\n    if (!isUndefined(defaultCell) && !forceDel) {\n      return setValidCell(tableId, rowId, row, cellId, defaultCell);\n    }\n    const delCell2 = (cellId2) => {\n      cellChanged(tableId, rowId, cellId2, mapGet(row, cellId2));\n      cellIdsChanged(tableId, rowId, cellId2, -1);\n      mapSet(row, cellId2);\n    };\n    if (isUndefined(defaultCell)) {\n      delCell2(cellId);\n    } else {\n      mapForEach(row, delCell2);\n    }\n    if (collIsEmpty(row)) {\n      rowIdsChanged(tableId, rowId, -1);\n      if (collIsEmpty(mapSet(table, rowId))) {\n        tableIdsChanged(tableId, -1);\n        mapSet(tablesMap, tableId);\n        mapSet(tablePoolFunctions, tableId);\n        mapSet(tableCellIds, tableId);\n      }\n    }\n  };\n  const delValidValue = (valueId) => {\n    const defaultValue = mapGet(valuesDefaulted, valueId);\n    if (!isUndefined(defaultValue)) {\n      return setValidValue(valueId, defaultValue);\n    }\n    valueChanged(valueId, mapGet(valuesMap, valueId));\n    valueIdsChanged(valueId, -1);\n    mapSet(valuesMap, valueId);\n  };\n  const tableIdsChanged = (tableId, addedOrRemoved) =>\n    idsChanged(changedTableIds, tableId, addedOrRemoved);\n  const rowIdsChanged = (tableId, rowId, addedOrRemoved) =>\n    idsChanged(\n      mapEnsure(changedRowIds, tableId, mapNew),\n      rowId,\n      addedOrRemoved,\n    ) &&\n    mapSet(\n      changedRowCount,\n      tableId,\n      mapEnsure(changedRowCount, tableId, () => 0) + addedOrRemoved,\n    );\n  const cellIdsChanged = (tableId, rowId, cellId, addedOrRemoved) => {\n    const cellIds = mapGet(tableCellIds, tableId);\n    const count = mapGet(cellIds, cellId) ?? 0;\n    if (\n      (count == 0 && addedOrRemoved == 1) ||\n      (count == 1 && addedOrRemoved == -1)\n    ) {\n      idsChanged(\n        mapEnsure(changedTableCellIds, tableId, mapNew),\n        cellId,\n        addedOrRemoved,\n      );\n    }\n    mapSet(\n      cellIds,\n      cellId,\n      count != -addedOrRemoved ? count + addedOrRemoved : null,\n    );\n    idsChanged(\n      mapEnsure(mapEnsure(changedCellIds, tableId, mapNew), rowId, mapNew),\n      cellId,\n      addedOrRemoved,\n    );\n  };\n  const cellChanged = (tableId, rowId, cellId, oldCell, newCell) => {\n    mapEnsure(\n      mapEnsure(mapEnsure(changedCells, tableId, mapNew), rowId, mapNew),\n      cellId,\n      () => [oldCell, 0],\n    )[1] = newCell;\n    internalListeners[3]?.(tableId, rowId, cellId, newCell);\n  };\n  const valueIdsChanged = (valueId, addedOrRemoved) =>\n    idsChanged(changedValueIds, valueId, addedOrRemoved);\n  const valueChanged = (valueId, oldValue, newValue) => {\n    mapEnsure(changedValues, valueId, () => [oldValue, 0])[1] = newValue;\n    internalListeners[4]?.(valueId, newValue);\n  };\n  const cellInvalid = (tableId, rowId, cellId, invalidCell, defaultedCell) => {\n    arrayPush(\n      mapEnsure(\n        mapEnsure(mapEnsure(invalidCells, tableId, mapNew), rowId, mapNew),\n        cellId,\n        () => [],\n      ),\n      invalidCell,\n    );\n    return defaultedCell;\n  };\n  const valueInvalid = (valueId, invalidValue, defaultedValue) => {\n    arrayPush(\n      mapEnsure(invalidValues, valueId, () => []),\n      invalidValue,\n    );\n    return defaultedValue;\n  };\n  const getCellChange = (tableId, rowId, cellId) =>\n    ifNotUndefined(\n      mapGet(mapGet(mapGet(changedCells, tableId), rowId), cellId),\n      ([oldCell, newCell]) => [true, oldCell, newCell],\n      () => [false, ...pairNew(getCell(tableId, rowId, cellId))],\n    );\n  const getValueChange = (valueId) =>\n    ifNotUndefined(\n      mapGet(changedValues, valueId),\n      ([oldValue, newValue]) => [true, oldValue, newValue],\n      () => [false, ...pairNew(getValue(valueId))],\n    );\n  const callInvalidCellListeners = (mutator) =>\n    !collIsEmpty(invalidCells) && !collIsEmpty(invalidCellListeners[mutator])\n      ? collForEach(\n          mutator ? mapClone3(invalidCells) : invalidCells,\n          (rows, tableId) =>\n            collForEach(rows, (cells, rowId) =>\n              collForEach(cells, (invalidCell, cellId) =>\n                callListeners(\n                  invalidCellListeners[mutator],\n                  [tableId, rowId, cellId],\n                  invalidCell,\n                ),\n              ),\n            ),\n        )\n      : 0;\n  const callInvalidValueListeners = (mutator) =>\n    !collIsEmpty(invalidValues) && !collIsEmpty(invalidValueListeners[mutator])\n      ? collForEach(\n          mutator ? mapClone(invalidValues) : invalidValues,\n          (invalidValue, valueId) =>\n            callListeners(\n              invalidValueListeners[mutator],\n              [valueId],\n              invalidValue,\n            ),\n        )\n      : 0;\n  const callIdsAndHasListenersIfChanged = (\n    changedIds,\n    idListeners,\n    hasListeners,\n    ids,\n  ) => {\n    if (!collIsEmpty(changedIds)) {\n      callListeners(idListeners, ids, () => mapToObj(changedIds));\n      mapForEach(changedIds, (changedId, changed) =>\n        callListeners(hasListeners, [...(ids ?? []), changedId], changed == 1),\n      );\n      return 1;\n    }\n  };\n  const callTabularListenersForChanges = (mutator) => {\n    const hasTablesNow = hasTables();\n    if (hasTablesNow != hadTables) {\n      callListeners(hasTablesListeners[mutator], void 0, hasTablesNow);\n    }\n    const emptySortedRowIdListeners = collIsEmpty(\n      sortedRowIdsListeners[mutator],\n    );\n    const emptyIdAndHasListeners =\n      collIsEmpty(cellIdsListeners[mutator]) &&\n      collIsEmpty(hasCellListeners[mutator]) &&\n      collIsEmpty(rowIdsListeners[mutator]) &&\n      collIsEmpty(hasRowListeners[mutator]) &&\n      collIsEmpty(tableCellIdsListeners[mutator]) &&\n      collIsEmpty(hasTableCellListeners[mutator]) &&\n      collIsEmpty(rowCountListeners[mutator]) &&\n      emptySortedRowIdListeners &&\n      collIsEmpty(tableIdsListeners[mutator]) &&\n      collIsEmpty(hasTableListeners[mutator]);\n    const emptyOtherListeners =\n      collIsEmpty(cellListeners[mutator]) &&\n      collIsEmpty(rowListeners[mutator]) &&\n      collIsEmpty(tableListeners[mutator]) &&\n      collIsEmpty(tablesListeners[mutator]);\n    if (!emptyIdAndHasListeners || !emptyOtherListeners) {\n      const changes = mutator\n        ? [\n            mapClone(changedTableIds),\n            mapClone2(changedTableCellIds),\n            mapClone(changedRowCount),\n            mapClone2(changedRowIds),\n            mapClone3(changedCellIds),\n            mapClone3(changedCells),\n          ]\n        : [\n            changedTableIds,\n            changedTableCellIds,\n            changedRowCount,\n            changedRowIds,\n            changedCellIds,\n            changedCells,\n          ];\n      if (!emptyIdAndHasListeners) {\n        callIdsAndHasListenersIfChanged(\n          changes[0],\n          tableIdsListeners[mutator],\n          hasTableListeners[mutator],\n        );\n        collForEach(changes[1], (changedIds, tableId) =>\n          callIdsAndHasListenersIfChanged(\n            changedIds,\n            tableCellIdsListeners[mutator],\n            hasTableCellListeners[mutator],\n            [tableId],\n          ),\n        );\n        collForEach(changes[2], (changedCount, tableId) => {\n          if (changedCount != 0) {\n            callListeners(\n              rowCountListeners[mutator],\n              [tableId],\n              getRowCount(tableId),\n            );\n          }\n        });\n        const calledSortableTableIds = setNew();\n        collForEach(changes[3], (changedIds, tableId) => {\n          if (\n            callIdsAndHasListenersIfChanged(\n              changedIds,\n              rowIdsListeners[mutator],\n              hasRowListeners[mutator],\n              [tableId],\n            ) &&\n            !emptySortedRowIdListeners\n          ) {\n            callListeners(sortedRowIdsListeners[mutator], [tableId, null]);\n            setAdd(calledSortableTableIds, tableId);\n          }\n        });\n        if (!emptySortedRowIdListeners) {\n          collForEach(changes[5], (rows, tableId) => {\n            if (!collHas(calledSortableTableIds, tableId)) {\n              const sortableCellIds = setNew();\n              collForEach(rows, (cells) =>\n                collForEach(cells, ([oldCell, newCell], cellId) =>\n                  newCell !== oldCell\n                    ? setAdd(sortableCellIds, cellId)\n                    : collDel(cells, cellId),\n                ),\n              );\n              collForEach(sortableCellIds, (cellId) =>\n                callListeners(sortedRowIdsListeners[mutator], [\n                  tableId,\n                  cellId,\n                ]),\n              );\n            }\n          });\n        }\n        collForEach(changes[4], (rowCellIds, tableId) =>\n          collForEach(rowCellIds, (changedIds, rowId) =>\n            callIdsAndHasListenersIfChanged(\n              changedIds,\n              cellIdsListeners[mutator],\n              hasCellListeners[mutator],\n              [tableId, rowId],\n            ),\n          ),\n        );\n      }\n      if (!emptyOtherListeners) {\n        let tablesChanged;\n        collForEach(changes[5], (rows, tableId) => {\n          let tableChanged;\n          collForEach(rows, (cells, rowId) => {\n            let rowChanged;\n            collForEach(cells, ([oldCell, newCell], cellId) => {\n              if (newCell !== oldCell) {\n                callListeners(\n                  cellListeners[mutator],\n                  [tableId, rowId, cellId],\n                  newCell,\n                  oldCell,\n                  getCellChange,\n                );\n                tablesChanged = tableChanged = rowChanged = 1;\n              }\n            });\n            if (rowChanged) {\n              callListeners(\n                rowListeners[mutator],\n                [tableId, rowId],\n                getCellChange,\n              );\n            }\n          });\n          if (tableChanged) {\n            callListeners(tableListeners[mutator], [tableId], getCellChange);\n          }\n        });\n        if (tablesChanged) {\n          callListeners(tablesListeners[mutator], void 0, getCellChange);\n        }\n      }\n    }\n  };\n  const callValuesListenersForChanges = (mutator) => {\n    const hasValuesNow = hasValues();\n    if (hasValuesNow != hadValues) {\n      callListeners(hasValuesListeners[mutator], void 0, hasValuesNow);\n    }\n    const emptyIdAndHasListeners =\n      collIsEmpty(valueIdsListeners[mutator]) &&\n      collIsEmpty(hasValueListeners[mutator]);\n    const emptyOtherListeners =\n      collIsEmpty(valueListeners[mutator]) &&\n      collIsEmpty(valuesListeners[mutator]);\n    if (!emptyIdAndHasListeners || !emptyOtherListeners) {\n      const changes = mutator\n        ? [mapClone(changedValueIds), mapClone(changedValues)]\n        : [changedValueIds, changedValues];\n      if (!emptyIdAndHasListeners) {\n        callIdsAndHasListenersIfChanged(\n          changes[0],\n          valueIdsListeners[mutator],\n          hasValueListeners[mutator],\n        );\n      }\n      if (!emptyOtherListeners) {\n        let valuesChanged;\n        collForEach(changes[1], ([oldValue, newValue], valueId) => {\n          if (newValue !== oldValue) {\n            callListeners(\n              valueListeners[mutator],\n              [valueId],\n              newValue,\n              oldValue,\n              getValueChange,\n            );\n            valuesChanged = 1;\n          }\n        });\n        if (valuesChanged) {\n          callListeners(valuesListeners[mutator], void 0, getValueChange);\n        }\n      }\n    }\n  };\n  const fluentTransaction = (actions, ...args) => {\n    transaction(() => actions(...arrayMap(args, id)));\n    return store;\n  };\n  const getContent = () => [getTables(), getValues()];\n  const getTables = () => mapToObj3(tablesMap);\n  const getTableIds = () => mapKeys(tablesMap);\n  const getTable = (tableId) => mapToObj2(mapGet(tablesMap, id(tableId)));\n  const getTableCellIds = (tableId) =>\n    mapKeys(mapGet(tableCellIds, id(tableId)));\n  const getRowCount = (tableId) => collSize(mapGet(tablesMap, id(tableId)));\n  const getRowIds = (tableId) => mapKeys(mapGet(tablesMap, id(tableId)));\n  const getSortedRowIds = (tableId, cellId, descending, offset = 0, limit) =>\n    arrayMap(\n      slice(\n        arraySort(\n          mapMap(mapGet(tablesMap, id(tableId)), (row, rowId) => [\n            isUndefined(cellId) ? rowId : mapGet(row, id(cellId)),\n            rowId,\n          ]),\n          ([cell1], [cell2]) =>\n            defaultSorter(cell1, cell2) * (descending ? -1 : 1),\n        ),\n        offset,\n        isUndefined(limit) ? limit : offset + limit,\n      ),\n      ([, rowId]) => rowId,\n    );\n  const getRow = (tableId, rowId) =>\n    mapToObj(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)));\n  const getCellIds = (tableId, rowId) =>\n    mapKeys(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)));\n  const getCell = (tableId, rowId, cellId) =>\n    mapGet(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), id(cellId));\n  const getValues = () => mapToObj(valuesMap);\n  const getValueIds = () => mapKeys(valuesMap);\n  const getValue = (valueId) => mapGet(valuesMap, id(valueId));\n  const hasTables = () => !collIsEmpty(tablesMap);\n  const hasTable = (tableId) => collHas(tablesMap, id(tableId));\n  const hasTableCell = (tableId, cellId) =>\n    collHas(mapGet(tableCellIds, id(tableId)), id(cellId));\n  const hasRow = (tableId, rowId) =>\n    collHas(mapGet(tablesMap, id(tableId)), id(rowId));\n  const hasCell = (tableId, rowId, cellId) =>\n    collHas(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), id(cellId));\n  const hasValues = () => !collIsEmpty(valuesMap);\n  const hasValue = (valueId) => collHas(valuesMap, id(valueId));\n  const getTablesJson = () => jsonStringWithMap(tablesMap);\n  const getValuesJson = () => jsonStringWithMap(valuesMap);\n  const getJson = () => jsonStringWithMap([tablesMap, valuesMap]);\n  const getTablesSchemaJson = () => jsonStringWithMap(tablesSchemaMap);\n  const getValuesSchemaJson = () => jsonStringWithMap(valuesSchemaMap);\n  const getSchemaJson = () =>\n    jsonStringWithMap([tablesSchemaMap, valuesSchemaMap]);\n  const setContent = (content) =>\n    fluentTransaction(() => {\n      const content2 = isFunction(content) ? content() : content;\n      if (validateContent(content2)) {\n        setValidContent(content2);\n      }\n    });\n  const setTables = (tables) =>\n    fluentTransaction(() =>\n      validateTables(tables) ? setValidTables(tables) : 0,\n    );\n  const setTable = (tableId, table) =>\n    fluentTransaction(\n      (tableId2) =>\n        validateTable(table, tableId2) ? setValidTable(tableId2, table) : 0,\n      tableId,\n    );\n  const setRow = (tableId, rowId, row) =>\n    fluentTransaction(\n      (tableId2, rowId2) =>\n        validateRow(tableId2, rowId2, row)\n          ? setValidRow(tableId2, getOrCreateTable(tableId2), rowId2, row)\n          : 0,\n      tableId,\n      rowId,\n    );\n  const addRow = (tableId, row, reuseRowIds = true) =>\n    transaction(() => {\n      let rowId = void 0;\n      if (validateRow(tableId, rowId, row)) {\n        tableId = id(tableId);\n        setValidRow(\n          tableId,\n          getOrCreateTable(tableId),\n          (rowId = getNewRowId(tableId, reuseRowIds ? 1 : 0)),\n          row,\n        );\n      }\n      return rowId;\n    });\n  const setPartialRow = (tableId, rowId, partialRow) =>\n    fluentTransaction(\n      (tableId2, rowId2) => {\n        if (validateRow(tableId2, rowId2, partialRow, 1)) {\n          const table = getOrCreateTable(tableId2);\n          objMap(partialRow, (cell, cellId) =>\n            setCellIntoDefaultRow(tableId2, table, rowId2, cellId, cell),\n          );\n        }\n      },\n      tableId,\n      rowId,\n    );\n  const setCell = (tableId, rowId, cellId, cell) =>\n    fluentTransaction(\n      (tableId2, rowId2, cellId2) =>\n        ifNotUndefined(\n          getValidatedCell(\n            tableId2,\n            rowId2,\n            cellId2,\n            isFunction(cell) ? cell(getCell(tableId2, rowId2, cellId2)) : cell,\n          ),\n          (validCell) =>\n            setCellIntoDefaultRow(\n              tableId2,\n              getOrCreateTable(tableId2),\n              rowId2,\n              cellId2,\n              validCell,\n            ),\n        ),\n      tableId,\n      rowId,\n      cellId,\n    );\n  const setValues = (values) =>\n    fluentTransaction(() =>\n      validateValues(values) ? setValidValues(values) : 0,\n    );\n  const setPartialValues = (partialValues) =>\n    fluentTransaction(() =>\n      validateValues(partialValues, 1)\n        ? objMap(partialValues, (value, valueId) =>\n            setValidValue(valueId, value),\n          )\n        : 0,\n    );\n  const setValue = (valueId, value) =>\n    fluentTransaction(\n      (valueId2) =>\n        ifNotUndefined(\n          getValidatedValue(\n            valueId2,\n            isFunction(value) ? value(getValue(valueId2)) : value,\n          ),\n          (validValue) => setValidValue(valueId2, validValue),\n        ),\n      valueId,\n    );\n  const applyChanges = (changes) =>\n    fluentTransaction(() => {\n      objMap(changes[0], (table, tableId) =>\n        isUndefined(table)\n          ? delTable(tableId)\n          : objMap(table, (row, rowId) =>\n              isUndefined(row)\n                ? delRow(tableId, rowId)\n                : objMap(row, (cell, cellId) =>\n                    setOrDelCell(store, tableId, rowId, cellId, cell),\n                  ),\n            ),\n      );\n      objMap(changes[1], (value, valueId) =>\n        setOrDelValue(store, valueId, value),\n      );\n    });\n  const setTablesJson = (tablesJson) => {\n    try {\n      setOrDelTables(jsonParse(tablesJson));\n    } catch {}\n    return store;\n  };\n  const setValuesJson = (valuesJson) => {\n    try {\n      setOrDelValues(jsonParse(valuesJson));\n    } catch {}\n    return store;\n  };\n  const setJson = (tablesAndValuesJson) =>\n    fluentTransaction(() => {\n      try {\n        const [tables, values] = jsonParse(tablesAndValuesJson);\n        setOrDelTables(tables);\n        setOrDelValues(values);\n      } catch {\n        setTablesJson(tablesAndValuesJson);\n      }\n    });\n  const setTablesSchema = (tablesSchema) =>\n    fluentTransaction(() => {\n      if ((hasTablesSchema = validateTablesSchema(tablesSchema))) {\n        setValidTablesSchema(tablesSchema);\n        if (!collIsEmpty(tablesMap)) {\n          const tables = getTables();\n          delTables();\n          setTables(tables);\n        }\n      }\n    });\n  const setValuesSchema = (valuesSchema) =>\n    fluentTransaction(() => {\n      if ((hasValuesSchema = validateValuesSchema(valuesSchema))) {\n        const values = getValues();\n        delValuesSchema();\n        delValues();\n        hasValuesSchema = true;\n        setValidValuesSchema(valuesSchema);\n        setValues(values);\n      }\n    });\n  const setSchema = (tablesSchema, valuesSchema) =>\n    fluentTransaction(() => {\n      setTablesSchema(tablesSchema);\n      setValuesSchema(valuesSchema);\n    });\n  const delTables = () => fluentTransaction(() => setValidTables({}));\n  const delTable = (tableId) =>\n    fluentTransaction(\n      (tableId2) =>\n        collHas(tablesMap, tableId2) ? delValidTable(tableId2) : 0,\n      tableId,\n    );\n  const delRow = (tableId, rowId) =>\n    fluentTransaction(\n      (tableId2, rowId2) =>\n        ifNotUndefined(mapGet(tablesMap, tableId2), (tableMap) =>\n          collHas(tableMap, rowId2)\n            ? delValidRow(tableId2, tableMap, rowId2)\n            : 0,\n        ),\n      tableId,\n      rowId,\n    );\n  const delCell = (tableId, rowId, cellId, forceDel) =>\n    fluentTransaction(\n      (tableId2, rowId2, cellId2) =>\n        ifNotUndefined(mapGet(tablesMap, tableId2), (tableMap) =>\n          ifNotUndefined(mapGet(tableMap, rowId2), (rowMap) =>\n            collHas(rowMap, cellId2)\n              ? delValidCell(\n                  tableId2,\n                  tableMap,\n                  rowId2,\n                  rowMap,\n                  cellId2,\n                  forceDel,\n                )\n              : 0,\n          ),\n        ),\n      tableId,\n      rowId,\n      cellId,\n    );\n  const delValues = () => fluentTransaction(() => setValidValues({}));\n  const delValue = (valueId) =>\n    fluentTransaction(\n      (valueId2) =>\n        collHas(valuesMap, valueId2) ? delValidValue(valueId2) : 0,\n      valueId,\n    );\n  const delTablesSchema = () =>\n    fluentTransaction(() => {\n      setValidTablesSchema({});\n      hasTablesSchema = false;\n    });\n  const delValuesSchema = () =>\n    fluentTransaction(() => {\n      setValidValuesSchema({});\n      hasValuesSchema = false;\n    });\n  const delSchema = () =>\n    fluentTransaction(() => {\n      delTablesSchema();\n      delValuesSchema();\n    });\n  const transaction = (actions, doRollback) => {\n    if (transactions != -1) {\n      startTransaction();\n      const result = actions();\n      finishTransaction(doRollback);\n      return result;\n    }\n  };\n  const startTransaction = () => {\n    if (transactions != -1) {\n      transactions++;\n    }\n    if (transactions == 1) {\n      internalListeners[0]?.();\n      callListeners(startTransactionListeners);\n    }\n    return store;\n  };\n  const getTransactionChanges = () => [\n    mapToObj(\n      changedCells,\n      (table, tableId) =>\n        mapGet(changedTableIds, tableId) === -1\n          ? void 0\n          : mapToObj(\n              table,\n              (row, rowId) =>\n                mapGet(mapGet(changedRowIds, tableId), rowId) === -1\n                  ? void 0\n                  : mapToObj(\n                      row,\n                      ([, newCell]) => newCell,\n                      (changedCell) => pairIsEqual(changedCell),\n                    ),\n              collIsEmpty,\n              objIsEmpty,\n            ),\n      collIsEmpty,\n      objIsEmpty,\n    ),\n    mapToObj(\n      changedValues,\n      ([, newValue]) => newValue,\n      (changedValue) => pairIsEqual(changedValue),\n    ),\n    1,\n  ];\n  const getTransactionLog = () => [\n    !collIsEmpty(changedCells),\n    !collIsEmpty(changedValues),\n    mapToObj3(changedCells, pairClone, pairIsEqual),\n    mapToObj3(invalidCells),\n    mapToObj(changedValues, pairClone, pairIsEqual),\n    mapToObj(invalidValues),\n    mapToObj(changedTableIds),\n    mapToObj2(changedRowIds),\n    mapToObj3(changedCellIds),\n    mapToObj(changedValueIds),\n  ];\n  const finishTransaction = (doRollback) => {\n    if (transactions > 0) {\n      transactions--;\n      if (transactions == 0) {\n        transactions = 1;\n        callInvalidCellListeners(1);\n        if (!collIsEmpty(changedCells)) {\n          callTabularListenersForChanges(1);\n        }\n        callInvalidValueListeners(1);\n        if (!collIsEmpty(changedValues)) {\n          callValuesListenersForChanges(1);\n        }\n        if (doRollback?.(store)) {\n          collForEach(changedCells, (table, tableId) =>\n            collForEach(table, (row, rowId) =>\n              collForEach(row, ([oldCell], cellId) =>\n                setOrDelCell(store, tableId, rowId, cellId, oldCell),\n              ),\n            ),\n          );\n          collClear(changedCells);\n          collForEach(changedValues, ([oldValue], valueId) =>\n            setOrDelValue(store, valueId, oldValue),\n          );\n          collClear(changedValues);\n        }\n        callListeners(finishTransactionListeners[0], void 0);\n        transactions = -1;\n        callInvalidCellListeners(0);\n        if (!collIsEmpty(changedCells)) {\n          callTabularListenersForChanges(0);\n        }\n        callInvalidValueListeners(0);\n        if (!collIsEmpty(changedValues)) {\n          callValuesListenersForChanges(0);\n        }\n        internalListeners[1]?.();\n        callListeners(finishTransactionListeners[1], void 0);\n        internalListeners[2]?.();\n        transactions = 0;\n        hadTables = hasTables();\n        hadValues = hasValues();\n        arrayForEach(\n          [\n            changedTableIds,\n            changedTableCellIds,\n            changedRowCount,\n            changedRowIds,\n            changedCellIds,\n            changedCells,\n            invalidCells,\n            changedValueIds,\n            changedValues,\n            invalidValues,\n          ],\n          collClear,\n        );\n      }\n    }\n    return store;\n  };\n  const forEachTable = (tableCallback) =>\n    collForEach(tablesMap, (tableMap, tableId) =>\n      tableCallback(tableId, (rowCallback) =>\n        collForEach(tableMap, (rowMap, rowId) =>\n          rowCallback(rowId, (cellCallback) =>\n            mapForEach(rowMap, cellCallback),\n          ),\n        ),\n      ),\n    );\n  const forEachTableCell = (tableId, tableCellCallback) =>\n    mapForEach(mapGet(tableCellIds, id(tableId)), tableCellCallback);\n  const forEachRow = (tableId, rowCallback) =>\n    collForEach(mapGet(tablesMap, id(tableId)), (rowMap, rowId) =>\n      rowCallback(rowId, (cellCallback) => mapForEach(rowMap, cellCallback)),\n    );\n  const forEachCell = (tableId, rowId, cellCallback) =>\n    mapForEach(mapGet(mapGet(tablesMap, id(tableId)), id(rowId)), cellCallback);\n  const forEachValue = (valueCallback) => mapForEach(valuesMap, valueCallback);\n  const addSortedRowIdsListener = (\n    tableId,\n    cellId,\n    descending,\n    offset,\n    limit,\n    listener,\n    mutator,\n  ) => {\n    let sortedRowIds = getSortedRowIds(\n      tableId,\n      cellId,\n      descending,\n      offset,\n      limit,\n    );\n    return addListener(\n      () => {\n        const newSortedRowIds = getSortedRowIds(\n          tableId,\n          cellId,\n          descending,\n          offset,\n          limit,\n        );\n        if (!arrayIsEqual(newSortedRowIds, sortedRowIds)) {\n          sortedRowIds = newSortedRowIds;\n          listener(\n            store,\n            tableId,\n            cellId,\n            descending,\n            offset,\n            limit,\n            sortedRowIds,\n          );\n        }\n      },\n      sortedRowIdsListeners[mutator ? 1 : 0],\n      [tableId, cellId],\n      [getTableIds],\n    );\n  };\n  const addStartTransactionListener = (listener) =>\n    addListener(listener, startTransactionListeners);\n  const addWillFinishTransactionListener = (listener) =>\n    addListener(listener, finishTransactionListeners[0]);\n  const addDidFinishTransactionListener = (listener) =>\n    addListener(listener, finishTransactionListeners[1]);\n  const callListener = (listenerId) => {\n    callListenerImpl(listenerId);\n    return store;\n  };\n  const delListener = (listenerId) => {\n    delListenerImpl(listenerId);\n    return store;\n  };\n  const getListenerStats = () => ({\n    hasTables: pairCollSize2(hasTablesListeners),\n    tables: pairCollSize2(tablesListeners),\n    tableIds: pairCollSize2(tableIdsListeners),\n    hasTable: pairCollSize2(hasTableListeners),\n    table: pairCollSize2(tableListeners),\n    tableCellIds: pairCollSize2(tableCellIdsListeners),\n    hasTableCell: pairCollSize2(hasTableCellListeners, collSize3),\n    rowCount: pairCollSize2(rowCountListeners),\n    rowIds: pairCollSize2(rowIdsListeners),\n    sortedRowIds: pairCollSize2(sortedRowIdsListeners),\n    hasRow: pairCollSize2(hasRowListeners, collSize3),\n    row: pairCollSize2(rowListeners, collSize3),\n    cellIds: pairCollSize2(cellIdsListeners, collSize3),\n    hasCell: pairCollSize2(hasCellListeners, collSize4),\n    cell: pairCollSize2(cellListeners, collSize4),\n    invalidCell: pairCollSize2(invalidCellListeners, collSize4),\n    hasValues: pairCollSize2(hasValuesListeners),\n    values: pairCollSize2(valuesListeners),\n    valueIds: pairCollSize2(valueIdsListeners),\n    hasValue: pairCollSize2(hasValueListeners),\n    value: pairCollSize2(valueListeners),\n    invalidValue: pairCollSize2(invalidValueListeners),\n    transaction:\n      collSize2(startTransactionListeners) +\n      pairCollSize2(finishTransactionListeners),\n  });\n  const setInternalListeners = (\n    preStartTransaction,\n    preFinishTransaction,\n    postFinishTransaction,\n    cellChanged2,\n    valueChanged2,\n  ) =>\n    (internalListeners = [\n      preStartTransaction,\n      preFinishTransaction,\n      postFinishTransaction,\n      cellChanged2,\n      valueChanged2,\n    ]);\n  const store = {\n    getContent,\n    getTables,\n    getTableIds,\n    getTable,\n    getTableCellIds,\n    getRowCount,\n    getRowIds,\n    getSortedRowIds,\n    getRow,\n    getCellIds,\n    getCell,\n    getValues,\n    getValueIds,\n    getValue,\n    hasTables,\n    hasTable,\n    hasTableCell,\n    hasRow,\n    hasCell,\n    hasValues,\n    hasValue,\n    getTablesJson,\n    getValuesJson,\n    getJson,\n    getTablesSchemaJson,\n    getValuesSchemaJson,\n    getSchemaJson,\n    hasTablesSchema: () => hasTablesSchema,\n    hasValuesSchema: () => hasValuesSchema,\n    setContent,\n    setTables,\n    setTable,\n    setRow,\n    addRow,\n    setPartialRow,\n    setCell,\n    setValues,\n    setPartialValues,\n    setValue,\n    applyChanges,\n    setTablesJson,\n    setValuesJson,\n    setJson,\n    setTablesSchema,\n    setValuesSchema,\n    setSchema,\n    delTables,\n    delTable,\n    delRow,\n    delCell,\n    delValues,\n    delValue,\n    delTablesSchema,\n    delValuesSchema,\n    delSchema,\n    transaction,\n    startTransaction,\n    getTransactionChanges,\n    getTransactionLog,\n    finishTransaction,\n    forEachTable,\n    forEachTableCell,\n    forEachRow,\n    forEachCell,\n    forEachValue,\n    addSortedRowIdsListener,\n    addStartTransactionListener,\n    addWillFinishTransactionListener,\n    addDidFinishTransactionListener,\n    callListener,\n    delListener,\n    getListenerStats,\n    isMergeable: () => false,\n    // only used internally by other modules\n    createStore,\n    addListener,\n    callListeners,\n    setInternalListeners,\n  };\n  objMap(\n    {\n      [HAS + TABLES]: [0, hasTablesListeners, [], () => [hasTables()]],\n      [TABLES]: [0, tablesListeners],\n      [TABLE_IDS]: [0, tableIdsListeners],\n      [HAS + TABLE]: [\n        1,\n        hasTableListeners,\n        [getTableIds],\n        (ids) => [hasTable(...ids)],\n      ],\n      [TABLE]: [1, tableListeners, [getTableIds]],\n      [TABLE + CELL_IDS]: [1, tableCellIdsListeners, [getTableIds]],\n      [HAS + TABLE + CELL]: [\n        2,\n        hasTableCellListeners,\n        [getTableIds, getTableCellIds],\n        (ids) => [hasTableCell(...ids)],\n      ],\n      [ROW_COUNT]: [1, rowCountListeners, [getTableIds]],\n      [ROW_IDS]: [1, rowIdsListeners, [getTableIds]],\n      [HAS + ROW]: [\n        2,\n        hasRowListeners,\n        [getTableIds, getRowIds],\n        (ids) => [hasRow(...ids)],\n      ],\n      [ROW]: [2, rowListeners, [getTableIds, getRowIds]],\n      [CELL_IDS]: [2, cellIdsListeners, [getTableIds, getRowIds]],\n      [HAS + CELL]: [\n        3,\n        hasCellListeners,\n        [getTableIds, getRowIds, getCellIds],\n        (ids) => [hasCell(...ids)],\n      ],\n      [CELL]: [\n        3,\n        cellListeners,\n        [getTableIds, getRowIds, getCellIds],\n        (ids) => pairNew(getCell(...ids)),\n      ],\n      InvalidCell: [3, invalidCellListeners],\n      [HAS + VALUES]: [0, hasValuesListeners, [], () => [hasValues()]],\n      [VALUES]: [0, valuesListeners],\n      [VALUE_IDS]: [0, valueIdsListeners],\n      [HAS + VALUE]: [\n        1,\n        hasValueListeners,\n        [getValueIds],\n        (ids) => [hasValue(...ids)],\n      ],\n      [VALUE]: [\n        1,\n        valueListeners,\n        [getValueIds],\n        (ids) => pairNew(getValue(ids[0])),\n      ],\n      InvalidValue: [1, invalidValueListeners],\n    },\n    ([argumentCount, idSetNode, pathGetters, extraArgsGetter], listenable) => {\n      store[ADD + listenable + LISTENER] = (...args) =>\n        addListener(\n          args[argumentCount],\n          idSetNode[args[argumentCount + 1] ? 1 : 0],\n          argumentCount > 0 ? slice(args, 0, argumentCount) : void 0,\n          pathGetters,\n          extraArgsGetter,\n        );\n    },\n  );\n  return objFreeze(store);\n};\n\nconst Inspector = ({position = 'right', open = false}) => {\n  const s = useCreateStore(createStore);\n  const index = POSITIONS.indexOf(position);\n  useCreatePersister(\n    s,\n    (s2) => createSessionPersister(s2, UNIQUE_ID),\n    void 0,\n    async (persister) => {\n      await persister.load([\n        {},\n        {\n          position: index == -1 ? 1 : index,\n          open: !!open,\n        },\n      ]);\n      await persister.startAutoSave();\n    },\n  );\n  return /* @__PURE__ */ createElement(\n    Fragment,\n    null,\n    /* @__PURE__ */ createElement(\n      'aside',\n      {id: UNIQUE_ID},\n      /* @__PURE__ */ createElement(Nub, {s}),\n      /* @__PURE__ */ createElement(Panel, {s}),\n    ),\n    /* @__PURE__ */ createElement('style', null, APP_STYLESHEET),\n  );\n};\n\nexport {Inspector};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8307, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}